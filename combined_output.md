# Combined Markdown Export

Generated: 2025-06-03T12:51:30.123120


## Index


### 1: Componenrts
- `frontend\src\components\api\VersionHistoryViewer.tsx` — ~993 tokens
- `frontend\src\components\editors\JsonEditor.tsx` — ~611 tokens
- `frontend\src\components\theme-provider.tsx` — ~218 tokens
- `frontend\src\components\theme-toggle.tsx` — ~125 tokens

### 2: UI
> User Interface Components
- `frontend\src\components\ui\accordion.tsx` — ~191 tokens
- `frontend\src\components\ui\alert-dialog.tsx` — ~397 tokens
- `frontend\src\components\ui\alert.tsx` — ~192 tokens
- `frontend\src\components\ui\avatar.tsx` — ~155 tokens
- `frontend\src\components\ui\badge.tsx` — ~135 tokens
- `frontend\src\components\ui\breadcrumb.tsx` — ~324 tokens
- `frontend\src\components\ui\button.tsx` — ~231 tokens
- `frontend\src\components\ui\calendar.tsx` — ~287 tokens
- `frontend\src\components\ui\card.tsx` — ~232 tokens
- `frontend\src\components\ui\checkbox.tsx` — ~107 tokens
- `frontend\src\components\ui\command.tsx` — ~472 tokens
- `frontend\src\components\ui\dialog.tsx` — ~365 tokens
- `frontend\src\components\ui\drawer.tsx` — ~329 tokens
- `frontend\src\components\ui\dropdown-menu.tsx` — ~654 tokens
- `frontend\src\components\ui\input.tsx` — ~91 tokens
- `frontend\src\components\ui\label.tsx` — ~90 tokens
- `frontend\src\components\ui\menubar.tsx` — ~811 tokens
- `frontend\src\components\ui\navigation-menu.tsx` — ~436 tokens
- `frontend\src\components\ui\pagination.tsx` — ~340 tokens
- `frontend\src\components\ui\popover.tsx` — ~123 tokens
- `frontend\src\components\ui\progress.tsx` — ~94 tokens
- `frontend\src\components\ui\scroll-area.tsx` — ~159 tokens
- `frontend\src\components\ui\select.tsx` — ~505 tokens
- `frontend\src\components\ui\separator.tsx` — ~94 tokens
- `frontend\src\components\ui\sheet.tsx` — ~433 tokens
- `frontend\src\components\ui\sidebar.tsx` — ~2480 tokens
- `frontend\src\components\ui\skeleton.tsx` — ~37 tokens
- `frontend\src\components\ui\switch.tsx` — ~113 tokens
- `frontend\src\components\ui\table.tsx` — ~319 tokens
- `frontend\src\components\ui\tabs.tsx` — ~187 tokens
- `frontend\src\components\ui\textarea.tsx` — ~81 tokens
- `frontend\src\components\ui\tooltip.tsx` — ~117 tokens

### 3: Frontend App Main
- `frontend\.eslintrc.cjs` — ~70 tokens
- `frontend\.prettierrc` — ~26 tokens
- `frontend\components.json` — ~50 tokens
- `frontend\index.html` — ~50 tokens
- `frontend\package.json` — ~191 tokens
- `frontend\postcss.config.js` — ~14 tokens
- `frontend\src\App.tsx` — ~424 tokens
- `frontend\src\index.css` — ~384 tokens
- `frontend\src\main.tsx` — ~49 tokens
- `frontend\tailwind.config.js` — ~244 tokens
- `frontend\tsconfig.json` — ~81 tokens
- `frontend\tsconfig.node.json` — ~22 tokens
- `frontend\vite.config.ts` — ~61 tokens

### 4: Documentation
- `docs\design.md` — ~1933 tokens
- `docs\tasks.md` — ~1332 tokens

### 5: Backend Main
- `backend\.env` — ~47 tokens
- `backend\.env.example` — ~81 tokens
- `backend\.eslintrc.cjs` — ~67 tokens
- `backend\.prettierrc` — ~23 tokens
- `backend\drizzle.config.ts` — ~43 tokens
- `backend\package.json` — ~127 tokens
- `backend\src\config.ts` — ~590 tokens
- `backend\src\env.ts` — ~331 tokens
- `backend\src\index.ts` — ~553 tokens
- `backend\tsconfig.json` — ~35 tokens

### 6: Backend API Import
- `backend\src\controllers\api-import.controller.ts` — ~258 tokens
- `backend\src\controllers\api-import\activate.ts` — ~389 tokens
- `backend\src\controllers\api-import\git.ts` — ~222 tokens
- `backend\src\controllers\api-import\import.ts` — ~716 tokens
- `backend\src\controllers\api-import\schemas.ts` — ~264 tokens
- `backend\src\controllers\api-import\share.ts` — ~170 tokens
- `backend\src\controllers\api-import\validate.ts` — ~159 tokens

### 7: Backend Database
- `backend\src\db\index.ts` — ~182 tokens
- `backend\src\db\lifecycle.ts` — ~742 tokens
- `backend\src\db\migrations\0000_initial_schema.sql` — ~504 tokens
- `backend\src\db\schema.ts` — ~561 tokens
- `backend\src\db\transactions.ts` — ~786 tokens

### 8: Backend Logging
- `backend\src\logging\constants.ts` — ~113 tokens
- `backend\src\logging\core.ts` — ~1085 tokens
- `backend\src\logging\database.ts` — ~712 tokens
- `backend\src\logging\drivers\base-driver.ts` — ~356 tokens
- `backend\src\logging\drivers\file-driver.ts` — ~774 tokens
- `backend\src\logging\drivers\sqlite-driver.ts` — ~815 tokens
- `backend\src\logging\index.ts` — ~163 tokens
- `backend\src\logging\lifecycle.ts` — ~420 tokens
- `backend\src\logging\manager.ts` — ~1529 tokens
- `backend\src\logging\middleware.ts` — ~506 tokens
- `backend\src\logging\types.ts` — ~473 tokens

### 9: Backend Services
- `backend\src\services\api-import.service.ts` — ~760 tokens
- `backend\src\services\config-file.service.d.ts` — ~85 tokens
- `backend\src\services\config-fs.service.ts` — ~468 tokens
- `backend\src\services\git.service.ts` — ~355 tokens
- `backend\src\services\import-validator.service.ts` — ~562 tokens

### Ungrouped Files
- `backend\config\orchestrator.json` — ~70 tokens
- `backend\src\api\client.ts` — ~2290 tokens
- `backend\src\config\index.ts` — ~643 tokens
- `backend\src\lifecycle\index.ts` — ~496 tokens
- `backend\src\routes\api.ts` — ~961 tokens
- `backend\src\routes\apis.ts` — ~2029 tokens
- `backend\src\routes\dcr.ts` — ~492 tokens
- `backend\src\routes\webhooks.ts` — ~1536 tokens
- `backend\src\scheduler\index.ts` — ~433 tokens
- `backend\src\schemas\api.schema.ts` — ~206 tokens
- `backend\src\scripts\archive-logs.ts` — ~367 tokens
- `backend\src\scripts\check-db.ts` — ~254 tokens
- `backend\src\scripts\generate-migration.ts` — ~703 tokens
- `backend\src\scripts\migrate.ts` — ~421 tokens
- `backend\src\scripts\run-migrations.ts` — ~65 tokens
- `backend\src\scripts\schema-inspector.ts` — ~216 tokens
- `backend\src\scripts\seed.ts` — ~1182 tokens
- `backend\src\scripts\test-db.ts` — ~272 tokens
- `backend\src\utils\fs-utils.ts` — ~461 tokens
- `backend\src\utils\fs.ts` — ~74 tokens
- `backend\src\webhooks\index.ts` — ~1087 tokens
- `docs\examples\Ally Code Webally API.postman_collection.json` — ~945 tokens
- `docs\examples\Document Processing API.postman_collection.json` — ~1200 tokens
- `frontend\src\hooks\use-mobile.tsx` — ~74 tokens
- `frontend\src\layouts\DashboardLayout.tsx` — ~627 tokens
- `frontend\src\lib\schemas\api-schema.ts` — ~448 tokens
- `frontend\src\lib\tailwind-plugin.js` — ~23 tokens
- `frontend\src\lib\utils.ts` — ~29 tokens
- `frontend\src\pages\auth\ForgotPasswordPage.tsx` — ~406 tokens
- `frontend\src\pages\auth\LoginPage.tsx` — ~285 tokens
- `frontend\src\pages\auth\ResetPasswordPage.tsx` — ~528 tokens
- `frontend\src\pages\dashboard\DashboardPage.tsx` — ~1131 tokens
- `frontend\src\pages\orchestrator\ApiEditorPage.tsx` — ~1135 tokens
- `frontend\src\pages\orchestrator\ApiImportPage.tsx` — ~1493 tokens
- `frontend\src\pages\orchestrator\ApiListPage.tsx` — ~1025 tokens
- `shared\schemas\index.ts` — ~332 tokens

**Total tokens: ~57424**

---

## 1: Componenrts

### `frontend\src\components\api\VersionHistoryViewer.tsx`

```tsx
import { useState, useEffect } from "react";
import { 
  GitBranch, 
  GitCommit, 
  Clock, 
  User, 
  RefreshCw,
  CheckCircle2,
  AlertCircle,
  ArrowLeftRight,
} from "lucide-react";

import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Alert,
  AlertDescription,
  AlertTitle,
} from "@/components/ui/alert";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Skeleton } from "@/components/ui/skeleton";

interface CommitInfo {
  hash: string;
  shortHash: string;
  message: string;
  author: string;
  date: string;
  changes: {
    added: number;
    modified: number;
    deleted: number;
  };
}

interface VersionHistoryViewerProps {
  apiId: string;
  apiName: string;
  showFileDiff?: boolean;
  onVersionSelect?: (version: string) => void;
}

export default function VersionHistoryViewer({
  apiId,
  apiName,
  showFileDiff = false,
  onVersionSelect,
}: VersionHistoryViewerProps) {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [commits, setCommits] = useState<CommitInfo[]>([]);
  const [selectedCommit, setSelectedCommit] = useState<CommitInfo | null>(null);
  const [diffDialogOpen, setDiffDialogOpen] = useState(false);
  const [diffContent, setDiffContent] = useState<string | null>(null);
  const [diffLoading, setDiffLoading] = useState(false);
  
  useEffect(() => {
    // In a real app, fetch from API
    fetchCommitHistory();
  }, [apiId]);
  
  const fetchCommitHistory = () => {
    setLoading(true);
    setError(null);
    
    // Simulate API call with mock data
    setTimeout(() => {
      try {
        const mockCommits: CommitInfo[] = [
          {
            hash: "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0",
            shortHash: "a1b2c3d",
            message: "Update authentication parameters for weather API",
            author: "jane.doe@example.com",
            date: "2025-06-03T09:45:22+02:00",
            changes: { added: 5, modified: 12, deleted: 2 }
          },
          {
            hash: "b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1",
            shortHash: "b2c3d4e",
            message: "Add rate limiting configuration",
            author: "john.smith@example.com",
            date: "2025-06-02T14:32:15+02:00",
            changes: { added: 8, modified: 3, deleted: 0 }
          },
          {
            hash: "c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2",
            shortHash: "c3d4e5f",
            message: "Initial import from Postman collection",
            author: "system",
            date: "2025-06-01T11:15:08+02:00",
            changes: { added: 35, modified: 0, deleted: 0 }
          }
        ];
        
        setCommits(mockCommits);
        setLoading(false);
      } catch (err) {
        setError("Failed to load commit history");
        setLoading(false);
      }
    }, 1200);
  };
  
  const handleViewDiff = (commit: CommitInfo) => {
    setSelectedCommit(commit);
    setDiffLoading(true);
    setDiffDialogOpen(true);
    
    // Simulate API call for diff content
    setTimeout(() => {
      const mockDiff = `diff --git a/apis/weather-api/v1/config.json b/apis/weather-api/v1/config.json
--- a/apis/weather-api/v1/config.json
+++ b/apis/weather-api/v1/config.json
@@ -15,9 +15,14 @@
   "authentication": {
-    "type": "apiKey",
-    "headerName": "X-API-Key"
+    "type": "oauth2",
+    "tokenUrl": "https://api.weather.example.com/oauth/token",
+    "clientId": "{{CLIENT_ID}}",
+    "clientSecret": "{{CLIENT_SECRET}}",
+    "scopes": ["read", "write"]
   },
   "rateLimit": {
-    "requestsPerMinute": 60
+    "requestsPerMinute": 100,
+    "burstSize": 10,
+    "strategy": "token-bucket"
   }
 }`;
      
      setDiffContent(mockDiff);
      setDiffLoading(false);
    }, 800);
  };
  
  const handleSelectVersion = () => {
    if (selectedCommit && onVersionSelect) {
      onVersionSelect(selectedCommit.shortHash);
      setDiffDialogOpen(false);
    }
  };
  
  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleString();
  };
  
  return (
    <Card className="w-full">
      <CardHeader className="pb-3">
        <div className="flex justify-between items-center">
          <div>
            <CardTitle className="text-xl flex items-center gap-2">
              <GitBranch className="h-5 w-5" />
              Version History
            </CardTitle>
            <CardDescription>
              Configuration changes for {apiName}
            </CardDescription>
          </div>
          <Button
            size="sm"
            className="flex items-center gap-1"
            onClick={fetchCommitHistory}
            disabled={loading}
          >
            <RefreshCw className={`h-4 w-4 ${loading ? 'animate-spin' : ''}`} />
            {loading ? 'Loading...' : 'Refresh'}
          </Button>
        </div>
      </CardHeader>
      <CardContent>
        {error && (
          <Alert className="mb-4 border-destructive/50 text-destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>Error</AlertTitle>
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
        
        <ScrollArea className="h-[350px]">
          {loading ? (
            // Loading skeleton
            Array(3).fill(0).map((_, i) => (
              <div key={i} className="flex flex-col space-y-3 mb-4">
                <div className="flex gap-2 items-center">
                  <Skeleton className="h-4 w-4 rounded-full" />
                  <Skeleton className="h-4 w-24" />
                </div>
                <Skeleton className="h-4 w-full" />
                <div className="flex gap-4">
                  <Skeleton className="h-3 w-32" />
                  <Skeleton className="h-3 w-24" />
                </div>
                {i < 2 && <Skeleton className="h-px w-full bg-border mt-2" />}
              </div>
            ))
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-[100px]">Commit</TableHead>
                  <TableHead>Message</TableHead>
                  <TableHead>Author</TableHead>
                  <TableHead>Date</TableHead>
                  <TableHead className="text-right">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {commits.map((commit) => (
                  <TableRow key={commit.hash}>
                    <TableCell className="font-mono text-xs">
                      <div className="flex items-center gap-1">
                        <GitCommit className="h-3.5 w-3.5 text-muted-foreground" />
                        {commit.shortHash}
                      </div>
                    </TableCell>
                    <TableCell>{commit.message}</TableCell>
                    <TableCell>
                      <div className="flex items-center gap-1">
                        <User className="h-3.5 w-3.5 text-muted-foreground" />
                        {commit.author}
                      </div>
                    </TableCell>
                    <TableCell>
                      <div className="flex items-center gap-1">
                        <Clock className="h-3.5 w-3.5 text-muted-foreground" />
                        {formatDate(commit.date)}
                      </div>
                    </TableCell>
                    <TableCell className="text-right">
                      <Button 
                        size="sm"
                        className="h-8 gap-1"
                        onClick={() => handleViewDiff(commit)}
                      >
                        <ArrowLeftRight className="h-3.5 w-3.5" />
                        View Changes
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </ScrollArea>
      </CardContent>
      
      {/* Diff Dialog */}
      <Dialog open={diffDialogOpen} onOpenChange={setDiffDialogOpen}>
        <DialogContent className="max-w-4xl max-h-[80vh] flex flex-col">
          <DialogHeader>
            <DialogTitle>Changes for commit {selectedCommit?.shortHash}</DialogTitle>
            <DialogDescription>
              {selectedCommit?.message} - by {selectedCommit?.author} on {selectedCommit && formatDate(selectedCommit.date)}
            </DialogDescription>
          </DialogHeader>
          
          <div className="flex-1 min-h-0 overflow-hidden my-4">
            {diffLoading ? (
              <div className="space-y-2 p-4">
                <Skeleton className="h-4 w-full" />
                <Skeleton className="h-4 w-3/4" />
                <Skeleton className="h-4 w-5/6" />
                <Skeleton className="h-4 w-2/3" />
              </div>
            ) : (
              <ScrollArea className="h-[400px] border rounded-md">
                <pre className="p-4 text-xs font-mono whitespace-pre-wrap bg-muted">
                  {diffContent}
                </pre>
              </ScrollArea>
            )}
          </div>
          
          <DialogFooter>
            <div className="flex justify-between w-full">
              <Button 
                className="bg-background border border-input hover:bg-accent hover:text-accent-foreground"
                onClick={() => setDiffDialogOpen(false)}
              >
                Close
              </Button>
              
              {showFileDiff && onVersionSelect && (
                <Button onClick={handleSelectVersion}>
                  <CheckCircle2 className="mr-2 h-4 w-4" />
                  Use This Version
                </Button>
              )}
            </div>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </Card>
  );
}
```


### `frontend\src\components\editors\JsonEditor.tsx`

```tsx
import { useRef, useState, useEffect } from "react";
import Editor, { Monaco, OnMount } from "@monaco-editor/react";
import { z } from "zod";
import { cn } from "@/lib/utils";
import { useTheme } from "@/components/theme-provider";
import { Moon, Sun } from "lucide-react";

interface JsonEditorProps {
  initialValue: string;
  onChange?: (value: string) => void;
  onValidate?: (isValid: boolean) => void;
  schema?: z.ZodType<any>;
  height?: string;
  className?: string;
  readOnly?: boolean;
}

export default function JsonEditor({
  initialValue,
  onChange,
  onValidate,
  schema,
  height = "500px",
  className,
  readOnly = false,
}: JsonEditorProps) {
  const [, setEditorContent] = useState<string>(initialValue); // Only using the setter
  const editorRef = useRef<any>(null);
  const monacoRef = useRef<Monaco | null>(null);
  const { theme } = useTheme();
  
  // Track if editor is in dark mode
  const [isDarkTheme, setIsDarkTheme] = useState(theme === 'dark' || 
    (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches));
  
  const validateJson = (value: string) => {
    try {
      const parsed = JSON.parse(value);
      
      if (schema) {
        const result = schema.safeParse(parsed);
        if (onValidate) {
          onValidate(result.success);
        }
        return result.success;
      } else {
        if (onValidate) {
          onValidate(true);
        }
        return true;
      }
    } catch (e) {
      if (onValidate) {
        onValidate(false);
      }
      return false;
    }
  };
  
  const handleEditorChange = (value: string | undefined) => {
    const newValue = value || "";
    setEditorContent(newValue);
    
    if (onChange) {
      onChange(newValue);
    }
    
    validateJson(newValue);
  };
  
  // Effect to update editor theme when app theme changes
  useEffect(() => {
    const isDark = theme === 'dark' || 
      (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);
    setIsDarkTheme(isDark);
    
    // Update Monaco theme if editor is already mounted
    if (monacoRef.current && editorRef.current) {
      monacoRef.current.editor.setTheme(isDark ? 'vs-dark' : 'vs-light');
    }
  }, [theme]);
  
  const handleEditorDidMount: OnMount = (editor, monaco) => {
    editorRef.current = editor;
    monacoRef.current = monaco;
    
    // Set editor theme based on current app theme
    monaco.editor.setTheme(isDarkTheme ? 'vs-dark' : 'vs-light');
    
    // Set editor options
    editor.updateOptions({
      minimap: {
        enabled: false,
      },
      scrollBeyondLastLine: false,
      folding: true,
      lineNumbers: "on",
      renderLineHighlight: "all",
      readOnly,
      scrollbar: {
        verticalScrollbarSize: 10,
        horizontalScrollbarSize: 10,
      },
    });
    
    // Configure JSON language features
    monaco.languages.json.jsonDefaults.setDiagnosticsOptions({
      validate: true,
      allowComments: true,
      schemas: [],
      enableSchemaRequest: true,
    });
    
    // Initial validation
    validateJson(initialValue);
  };
  
  const formatDocument = () => {
    if (editorRef.current) {
      editorRef.current.getAction("editor.action.formatDocument").run();
    }
  };
  
  // Toggle editor theme manually
  const toggleEditorTheme = () => {
    if (monacoRef.current && editorRef.current) {
      const newTheme = !isDarkTheme;
      setIsDarkTheme(newTheme);
      monacoRef.current.editor.setTheme(newTheme ? 'vs-dark' : 'vs-light');
    }
  };

  return (
    <div className={cn("border rounded-md", className)}>
      <div className="flex items-center justify-end p-2 bg-muted border-b">
        <button
          onClick={toggleEditorTheme}
          className="p-1 rounded-md hover:bg-accent transition-colors" 
          title={isDarkTheme ? "Switch to light theme" : "Switch to dark theme"}
        >
          {isDarkTheme ? 
            <Sun className="h-4 w-4" /> : 
            <Moon className="h-4 w-4" />}
        </button>
      </div>
      <Editor
        height={height}
        defaultLanguage="json"
        defaultValue={initialValue}
        onChange={handleEditorChange}
        onMount={handleEditorDidMount}
        options={{
          readOnly,
          automaticLayout: true,
          formatOnPaste: true,
          formatOnType: true,
        }}
        theme={isDarkTheme ? 'vs-dark' : 'vs-light'}
      />
      {!readOnly && (
        <div className="flex justify-end p-2 bg-muted border-t">
          <button
            onClick={formatDocument}
            className="px-3 py-1 text-xs rounded-md bg-secondary text-secondary-foreground hover:bg-secondary/80"
          >
            Format
          </button>
        </div>
      )}
    </div>
  );
}
```


### `frontend\src\components\theme-provider.tsx`

```tsx
import { createContext, useContext, useEffect, useState } from "react"

type Theme = "dark" | "light" | "system"

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
}

const initialState: ThemeProviderState = {
  theme: "system",
  setTheme: () => null,
}

const ThemeProviderContext = createContext<ThemeProviderState>(initialState)

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "dcr-ui-theme",
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  )

  useEffect(() => {
    const root = window.document.documentElement

    root.classList.remove("light", "dark")

    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
        .matches
        ? "dark"
        : "light"

      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext)

  if (context === undefined)
    throw new Error("useTheme must be used within a ThemeProvider")

  return context
}
```


### `frontend\src\components\theme-toggle.tsx`

```tsx
import { Moon, Sun } from "lucide-react"

import { Button } from "./ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "./ui/dropdown-menu"
import { useTheme } from "./theme-provider"

export function ThemeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}
```

## 2: UI
> User Interface Components

### `frontend\src\components\ui\accordion.tsx`

```tsx
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline text-left [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))
AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
```


### `frontend\src\components\ui\alert-dialog.tsx`

```tsx
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
```


### `frontend\src\components\ui\alert.tsx`

```tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
```


### `frontend\src\components\ui\avatar.tsx`

```tsx
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
```


### `frontend\src\components\ui\badge.tsx`

```tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
```


### `frontend\src\components\ui\breadcrumb.tsx`

```tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
```


### `frontend\src\components\ui\button.tsx`

```tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        sidebar: "bg-sidebar-accent text-sidebar-accent-foreground hover:bg-sidebar-accent/90 hover:text-sidebar-accent-foreground",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
```


### `frontend\src\components\ui\calendar.tsx`

```tsx
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-8 w-8 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_start: "day-range-start",
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }
```


### `frontend\src\components\ui\card.tsx`

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
```


### `frontend\src\components\ui\checkbox.tsx`

```tsx
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
```


### `frontend\src\components\ui\command.tsx`

```tsx
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
```


### `frontend\src\components\ui\dialog.tsx`

```tsx
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
```


### `frontend\src\components\ui\drawer.tsx`

```tsx
import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
```


### `frontend\src\components\ui\dropdown-menu.tsx`

```tsx
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
```


### `frontend\src\components\ui\input.tsx`

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
```


### `frontend\src\components\ui\label.tsx`

```tsx
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
```


### `frontend\src\components\ui\menubar.tsx`

```tsx
import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup {...props} />
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-4 w-4 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}
```


### `frontend\src\components\ui\navigation-menu.tsx`

```tsx
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
```


### `frontend\src\components\ui\pagination.tsx`

```tsx
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
}
```


### `frontend\src\components\ui\popover.tsx`

```tsx
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
```


### `frontend\src\components\ui\progress.tsx`

```tsx
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-primary/20",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
```


### `frontend\src\components\ui\scroll-area.tsx`

```tsx
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
```


### `frontend\src\components\ui\select.tsx`

```tsx
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
```


### `frontend\src\components\ui\separator.tsx`

```tsx
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
```


### `frontend\src\components\ui\sheet.tsx`

```tsx
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
      {children}
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
```


### `frontend\src\components\ui\sidebar.tsx`

```tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContextProps>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <SheetHeader className="sr-only">
              <SheetTitle>Sidebar</SheetTitle>
              <SheetDescription>Displays the mobile sidebar.</SheetDescription>
            </SheetHeader>
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex w-full flex-1 flex-col bg-background",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
```


### `frontend\src\components\ui\skeleton.tsx`

```tsx
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  )
}

export { Skeleton }
```


### `frontend\src\components\ui\switch.tsx`

```tsx
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
```


### `frontend\src\components\ui\table.tsx`

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
```


### `frontend\src\components\ui\tabs.tsx`

```tsx
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
```


### `frontend\src\components\ui\textarea.tsx`

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }
```


### `frontend\src\components\ui\tooltip.tsx`

```tsx
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
```

## 3: Frontend App Main

### `frontend\.eslintrc.cjs`

```cjs
module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react-hooks/recommended',
    'prettier'
  ],
  ignorePatterns: ['dist', '.eslintrc.cjs'],
  parser: '@typescript-eslint/parser',
  plugins: ['react-refresh', 'prettier'],
  rules: {
    'react-refresh/only-export-components': [
      'warn',
      { allowConstantExport: true },
    ],
    'prettier/prettier': 'error',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/no-unused-vars': ['error', { 
      'argsIgnorePattern': '^_',
      'varsIgnorePattern': '^_' 
    }],
  },
}
```


### `frontend\.prettierrc`

```
{
  "semi": true,
  "tabWidth": 2,
  "printWidth": 100,
  "singleQuote": true,
  "trailingComma": "es5",
  "bracketSpacing": true,
  "jsxBracketSameLine": false,
  "arrowParens": "avoid",
  "endOfLine": "auto"
}
```


### `frontend\components.json`

```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
```


### `frontend\index.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DCR Dashboard</title>
    <meta name="description" content="Dynamic Configuration & Request Orchestrator Dashboard" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```


### `frontend\package.json`

```json
{
  "name": "dcr-frontend",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.0.1",
    "@monaco-editor/react": "^4.7.0",
    "@radix-ui/react-accordion": "^1.2.11",
    "@radix-ui/react-alert-dialog": "^1.1.14",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.2",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-icons": "^1.3.0",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-menubar": "^1.1.15",
    "@radix-ui/react-navigation-menu": "^1.2.13",
    "@radix-ui/react-popover": "^1.1.14",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-tabs": "^1.0.4",
    "@radix-ui/react-toast": "^1.1.4",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@tailwindcss/vite": "^4.1.8",
    "@tanstack/react-table": "^8.10.7",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "d3": "^7.8.5",
    "date-fns": "^3.6.0",
    "lucide-react": "^0.293.0",
    "react": "^18.2.0",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^1.1.2",
    "zod": "^3.25.49"
  },
  "devDependencies": {
    "@types/d3": "^7.4.3",
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.37",
    "@types/react-dom": "^18.2.15",
    "@typescript-eslint/eslint-plugin": "^6.10.0",
    "@typescript-eslint/parser": "^6.10.0",
    "@vitejs/plugin-react": "^4.2.0",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.53.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.4",
    "postcss": "^8.4.31",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.2.2",
    "vite": "^5.0.0"
  }
}
```


### `frontend\postcss.config.js`

```js
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```


### `frontend\src\App.tsx`

```tsx
import { Route, Routes, Navigate } from 'react-router-dom';
import { Suspense, lazy } from 'react';
import DashboardLayout from './layouts/DashboardLayout';

// Auth Pages
const LoginPage = lazy(() => import('./pages/auth/LoginPage'));
const ForgotPasswordPage = lazy(() => import('./pages/auth/ForgotPasswordPage'));
const ResetPasswordPage = lazy(() => import('./pages/auth/ResetPasswordPage'));

// Dashboard Pages
const DashboardPage = lazy(() => import('./pages/dashboard/DashboardPage'));

// Orchestrator Pages
const ApiListPage = lazy(() => import('./pages/orchestrator/ApiListPage'));
const ApiEditorPage = lazy(() => import('./pages/orchestrator/ApiEditorPage'));
const ApiImportPage = lazy(() => import('./pages/orchestrator/ApiImportPage'));

// Loading Fallback
function LoadingFallback() {
  return (
    <div className="flex h-screen w-screen items-center justify-center">
      <div className="h-16 w-16 animate-spin rounded-full border-4 border-primary border-t-transparent"></div>
    </div>
  );
}

// Protected Route Helper
function ProtectedRoute({ children }: { children: React.ReactNode }) {
  // This would be replaced with actual auth check logic
  const isAuthenticated = true; // For development, assuming logged in
  
  // In a real app, redirect to login if not authenticated
  if (!isAuthenticated) {
    window.location.href = '/auth/login';
    return <LoadingFallback />;
  }
  
  return <>{children}</>;
}

export default function App() {
  return (
    <Suspense fallback={<LoadingFallback />}>
      <Routes>
        {/* Auth Routes */}
        <Route path="/auth/login" element={<LoginPage />} />
        <Route path="/auth/forgot-password" element={<ForgotPasswordPage />} />
        <Route path="/auth/reset-password" element={<ResetPasswordPage />} />
        
        {/* Protected Dashboard Routes */}
        <Route path="/" element={
          <ProtectedRoute>
            <DashboardLayout />
          </ProtectedRoute>
        }>
          <Route index element={<DashboardPage />} />
          
          {/* Orchestrator Routes */}
          <Route path="orchestrator" element={<Navigate to="/orchestrator/apis" replace />} />
          <Route path="orchestrator/apis" element={<Suspense fallback={<LoadingFallback />}><ApiListPage /></Suspense>} />
          <Route path="orchestrator/apis/import" element={<Suspense fallback={<LoadingFallback />}><ApiImportPage /></Suspense>} />
          <Route path="orchestrator/apis/:apiId" element={<Suspense fallback={<LoadingFallback />}><ApiEditorPage /></Suspense>} />
          <Route path="plugins" element={<div className="p-6"><h1 className="text-2xl font-bold">Plugins</h1><p className="mt-4 text-muted-foreground">This page will contain the plugin management interface.</p></div>} />
          <Route path="logs" element={<div className="p-6"><h1 className="text-2xl font-bold">Logs</h1><p className="mt-4 text-muted-foreground">This page will contain the log viewer and filtering interface.</p></div>} />
          <Route path="scheduler" element={<div className="p-6"><h1 className="text-2xl font-bold">Scheduler</h1><p className="mt-4 text-muted-foreground">This page will contain the request scheduling interface.</p></div>} />
          <Route path="users" element={<div className="p-6"><h1 className="text-2xl font-bold">Users</h1><p className="mt-4 text-muted-foreground">This page will contain the user management interface.</p></div>} />
          <Route path="settings" element={<div className="p-6"><h1 className="text-2xl font-bold">Settings</h1><p className="mt-4 text-muted-foreground">This page will contain the system settings interface.</p></div>} />
        </Route>
      </Routes>
    </Suspense>
  );
}
```


### `frontend\src\index.css`

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;

    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
 
    --primary: 240 5.9% 10%;
    --primary-foreground: 0 0% 98%;
 
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
 
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
 
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
 
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;

    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 240 10% 3.9%;
 
    --radius: 0.5rem;
 
    --chart-1: 12 76% 61%;
 
    --chart-2: 173 58% 39%;
 
    --chart-3: 197 37% 24%;
 
    --chart-4: 43 74% 66%;
 
    --chart-5: 27 87% 67%;
 
    --sidebar-background: 0 0% 98%;
 
    --sidebar-foreground: 240 5.3% 26.1%;
 
    --sidebar-primary: 240 5.9% 10%;
 
    --sidebar-primary-foreground: 0 0% 98%;
 
    --sidebar-accent: 240 4.8% 95.9%;
 
    --sidebar-accent-foreground: 240 5.9% 10%;
 
    --sidebar-border: 220 13% 91%;
 
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
 
  .dark {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
 
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
 
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
 
    --primary: 0 0% 98%;
    --primary-foreground: 240 5.9% 10%;
 
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
 
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
 
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
 
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
 
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 240 4.9% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
```


### `frontend\src\main.tsx`

```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import App from './App.tsx'
import './index.css'
import { ThemeProvider } from './components/theme-provider'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ThemeProvider defaultTheme="dark">
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </ThemeProvider>
  </React.StrictMode>,
)
```


### `frontend\tailwind.config.js`

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
  	container: {
  		center: true,
  		padding: '2rem',
  		screens: {
  			'2xl': '1400px'
  		}
  	},
  	extend: {
  		colors: {
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			},
  			sidebar: {
  				DEFAULT: 'hsl(var(--sidebar-background))',
  				foreground: 'hsl(var(--sidebar-foreground))',
  				primary: 'hsl(var(--sidebar-primary))',
  				'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
  				accent: 'hsl(var(--sidebar-accent))',
  				'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
  				border: 'hsl(var(--sidebar-border))',
  				ring: 'hsl(var(--sidebar-ring))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			}
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
}
```


### `frontend\tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Paths */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```


### `frontend\tsconfig.node.json`

```json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
```


### `frontend\vite.config.ts`

```ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from "path";


// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },  
  },
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      },
    },
  },
});
```

## 4: Documentation

### `docs\design.md`

```md
# Digital Cabinet Relay - Comprehensive Design Document

## 1. Overview

The DCR is a fullstack, extensible orchestration engine designed to:

* Import Postman collections and expose them as modular, managed endpoints
* Integrate and communicate with arbitrary sub-APIs (microservices) via HTTP, WebSocket (WS), and RPC
* Apply a declarative lifecycle execution model to each request and DB operation
* Store configuration, permission, and user data in a persistent database
* Log all activities, errors, and metadata to SQLite, with scheduled export to S3
* Visualize runtime and flow graphs via a D3-based dashboard frontend
* Support runtime configuration overrides, caching, retries, auth, and webhooks at every phase

The system is designed for **runtime flexibility**, **multi-tech interoperability**, and **developer observability**.

---

## 2. Technology Stack

| Layer         | Technology                      | Notes                                         |
| ------------- | ------------------------------- | --------------------------------------------- |
| Web Framework | Hono (Node.js + TypeScript)     | Fast, ESM-friendly web server with WS support |
| ORM           | Drizzle ORM                     | Type-safe, SQLite & Postgres compatible       |
| DB (runtime)  | SQLite (local), Postgres (prod) | Logs + Users + Endpoint definitions           |
| Validation    | Zod                             | Shared schema between frontend/backend        |
| Config        | `.env` + hierarchical `.json`   | Global + API-level + Endpoint-level overrides |
| Frontend      | Vite + React + ShadCN           | Dashboard, dark/light mode, D3 visualizer     |
| Visualization | D3.js                           | Flow diagram of request lifecycles            |
| State Sharing | WebSocket, HTTP, RPC (custom)   | For real-time communication and fallback      |
| Logging       | Configurable (SQLite, PG, MySQL, File) + Archival (S3, FTP, Local) | Driver-based, typed, with lifecycle & archival |
| Auth          | JWT / API key / per-endpoint    | Pluggable in lifecycle hooks                  |

---

## 3. `.env` Structure

```ini
# Main Database
DATABASE_URL="sqlite:///./data/dcr.db"

# Orchestrator Mode
ORCHESTRATOR_MODE=dev # dev, prod, test

# AWS Credentials (used for S3 log archiving and potentially other AWS services)
AWS_ACCESS_KEY_ID=your_aws_access_key_id
AWS_SECRET_ACCESS_KEY=your_aws_secret_access_key
S3_REGION=your_s3_region # e.g., us-east-1

# Log Archiving & Storage Configuration
LOG_STORAGE_DRIVER=s3 # s3, ftp, archive
LOG_STORAGE_INTERVAL=7 # In days, how long to keep logs locally before archiving
LOG_STORAGE_ZIP_OPTION=zipPerLog # zipPerLog, zipAllTogether, none

# S3 Specific Log Storage
S3_BUCKET_NAME=your_dcr_archived_logs_bucket
S3_STORAGE_PREFIX=logs/production/ # Optional prefix within the bucket

# FTP Specific Log Storage
FTP_HOST=your_ftp_host
FTP_PORT=21
FTP_USER=your_ftp_user
FTP_PASSWORD=your_ftp_password
FTP_REMOTE_PATH=/dcr_archived_logs/

# Archive (Local Filesystem) Specific Log Storage
LOG_STORAGE_ARCHIVE_PATH=/mnt/dcr_archived_logs/
```

---

## 4. Config Hierarchy

### 4.1 Orchestrator Config (`config/orchestrator.json`)

```json
{
  "logLevel": "debug",
  "defaultRetries": 3,
  "defaultCacheTtl": 300,
  "lifecycle": {
    "beforeRequest": ["auth", "cache", "log"],
    "request": ["fetch"],
    "afterRequest": ["log", "webhook"]
  }
}
```

### 4.2 API Config (`apis/salesforce/config.json`)

```json
{
  "auth": {
    "type": "oauth2",
    "tokenUrl": "https://login.salesforce.com/oauth2/token"
  },
  "baseUrl": "https://api.salesforce.com/v1"
}
```

### 4.3 Endpoint Config (`apis/salesforce/endpoints/getUsers.json`)

### 4.4 Logging and Archiving Strategy

The DCR employs a flexible and configurable logging system for both main orchestrator/API operations and for archiving logs to long-term storage.

#### 4.4.1 Main Logging System

The primary logging system is designed to be adaptable to different database backends and file-based outputs.

*   **Log Drivers**: Each defined log type can specify a driver. Supported drivers include:
    *   `mysql`: For logging to a MySQL database.
    *   `postgresql`: For logging to a PostgreSQL database.
    *   `sqlite`: Default for local/runtime logs before archiving (uses the main `DATABASE_URL` or a separate one).
    *   `file`: For simple file-based logging (e.g., rotating log files).
*   **Log Classification/Types**: Logs will be categorized (e.g., `application`, `security`, `request_lifecycle`, `database_query`, `external_api_call`) to allow for granular configuration, filtering, and routing to different drivers or storage.
*   **Configuration**:
    *   Main logging configuration (default driver, log levels per type, driver-specific settings) will reside in `config/orchestrator.json`.
    *   This configuration is inherited by sub-APIs, which can override parts of it in their respective API-level or endpoint-level `config.json` files.
    *   Example `orchestrator.json` addition for logging:
        ```json
        {
          // ... existing orchestrator config (logLevel, defaultRetries, etc.) ...
          "logging": {
            "defaultDriver": "sqlite", 
            "logTypes": {
              "application": { "driver": "file", "level": "info" },
              "request_lifecycle": { "driver": "sqlite", "level": "debug" },
              "security": { "driver": "mysql", "level": "warn" }
            },
            "drivers": {
              "sqlite": {
                // Uses main DATABASE_URL by default if not specified
                // "connectionString": "sqlite:///./data/dcr_audit_logs.db" 
              },
              "file": {
                "basePath": "./logs/", // Base directory for log files
                "maxSizeMB": 10,      // Max size per log file before rotation
                "maxFiles": 7         // Number of rotated files to keep
              },
              "mysql": {
                "connectionString": "mysql://user:pass@host:port/dbname_logs"
              },
              "postgresql": {
                "connectionString": "postgresql://user:pass@host:port/dbname_logs"
              }
            }
          }
        }
        ```

#### 4.4.2 Log Archiving and Long-Term Storage

Logs, especially those initially stored in transient systems like SQLite or local files, will be periodically archived to a more permanent storage location based on their age.

*   **Storage Drivers**: Configured via `LOG_STORAGE_DRIVER` environment variable or within the orchestrator config (e.g., `logging.archival.driver`).
    *   `s3`: Amazon S3.
    *   `ftp`: FTP/SFTP server.
    *   `archive`: Local filesystem archive (moving files to a different directory).
*   **Archival Interval**: Configured via `LOG_STORAGE_INTERVAL` (e.g., `7` for 7 days). Logs older than this interval are targeted for archiving.
*   **Compression Options**: Configured via `LOG_STORAGE_ZIP_OPTION`.
    *   `zipPerLog`: Each individual log source/file (e.g., a daily rotated file, or logs for a specific endpoint if stored separately) is zipped.
    *   `zipAllTogether`: All logs qualifying for an archival run are consolidated into a single zip archive.
    *   `none`: Logs are transferred/moved without compression.
*   **Driver-Specific Configuration**: Primarily managed via `.env` variables (as shown in Section 3) and potentially referenced or overridden in the orchestrator config.
    *   **S3**: Requires `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `S3_BUCKET_NAME`, `S3_REGION`, and an optional `S3_STORAGE_PREFIX`.
    *   **FTP**: Requires `FTP_HOST`, `FTP_PORT`, `FTP_USER`, `FTP_PASSWORD`, and `FTP_REMOTE_PATH`.
    *   **Archive (Local Filesystem)**: Requires `LOG_STORAGE_ARCHIVE_PATH`.

```json
{
  "method": "GET",
  "path": "/users",
  "authOverride": "none",
  "cacheTtl": 600,
  "lifecycle": {
    "beforeRequest": ["cache", "log"],
    "request": ["http"],
    "afterRequest": ["log", "webhook"]
  },
  "webhooks": {
    "onSuccess": "https://hooks.site/ok",
    "onError": "https://hooks.site/fail"
  }
}
```

---

## 5. Database Schema (Drizzle ORM)

### Tables

* `users`: { id, email, passwordHash, role }
* `permissions`: { userId, apiName, endpointPath, verb, allowed }
* `apis`: { id, name, baseUrl, type, configJson }
* `endpoints`: { id, apiId, path, method, configJson }
* `logs`: { id, timestamp, endpointId, phase, success, message, metadataJson }
* `webhooks`: { id, endpointId, phase, statusCode, url }
* `cache`: { key, valueJson, expiresAt }
* `retry_schedule`: { requestId, endpointId, nextTry, attempts, status }

---

## 6. Lifecycle Execution Model

### Request Lifecycle

1. `beforeRequest`

   * Auth check (JWT, API key, OAuth2)
   * Cache lookup
   * Log intent
2. `request`

   * HTTP request
   * WS message
   * Local RPC call
3. `afterRequest`

   * Log response
   * Webhook emission (by response code)
   * Cache update (if applicable)

### ORM Lifecycle

1. `beforeExecute`

   * Input validation
   * Cache read
2. `execute`

   * Drizzle query or raw SQL
3. `afterExecute`

   * Log result
   * Webhook (success/failure)
   * Retry trigger (if enabled)

---

## 7. Logging

* All phases (`beforeRequest`, `afterExecute`, etc.) log to SQLite
* Log format:

```ts
{
  id: number,
  timestamp: string,
  endpointId: number,
  phase: 'beforeRequest' | 'execute' | 'afterExecute',
  success: boolean,
  message: string,
  metadataJson: object
}
```

* Export to S3 every 24h:

  * Cron job runs daily
  * Uploads logs from exactly 7 days ago

---

## 8. Sub-API / Postman Mapping

### Supported Input:

* Postman v2.1 collections
* OpenAPI 3.1 (future)
* Manual `.json` config for custom sub-APIs

### Mapping:

| Postman Element | AOC Equivalent           |
| --------------- | ------------------------ |
| Collection      | API registration         |
| Request URL     | Endpoint path + method   |
| Auth            | Lifecycle `auth`         |
| Tests / Scripts | Lifecycle `afterRequest` |

---

## 9. Communication Protocols

| Protocol  | Use                                   | Fallback                   |
| --------- | ------------------------------------- | -------------------------- |
| HTTP      | RESTful endpoints                     | Retry, failover via config |
| WebSocket | Live dashboard feed, long-running ops | Auto-reconnect             |
| RPC       | Local sub-api exec                    | HTTP fallback              |

All protocols are routed through lifecycle hooks and use shared logging.

---

## 10. Retry & Scheduling

Each request config can include:

```json
"retry": {
  "count": 3,
  "backoff": "exponential",
  "initialDelay": 1000
}
```

If request fails, it’s queued in `retry_schedule` with timestamped `nextTry`.

---

## 11. Dashboard UI (React + ShadCN)

### Pages

* Dashboard: Live D3 visualization of endpoints
* Logs: Table viewer with filters
* Users: Admin panel with permission editor
* Endpoints: Config + lifecycle management
* Sub-API Registry: Add/edit APIs + upload Postman
* Webhooks: Attach URL per phase & status code

### Features

* Dark/light mode toggle (ShadCN + Tailwind)
* D3 graph nodes per endpoint + lifecycle stage
* Pinning of logs + cache hits to graph points
* WebSocket-based live updates
* Manual trigger of retries

---

## 12. Summary

The AOC system provides a complete backend orchestration and visualization suite for managing APIs, Postman imports, lifecycle processing, retries, logs, and more. It combines speed (Hono), safety (Zod + Drizzle), extensibility (sub-APIs), and observability (D3 dashboard), and is deployable on AWS EC2 with full config-driven runtime behavior.
```


### `docs\tasks.md`

```md
# DCR Tasks - Project Breakdown

---

## 1. Project Setup

- [x] 1.1 Initialize backend project with TypeScript, Hono, Drizzle
- [x] 1.2 Initialize frontend project with Vite, React, Tailwind, ShadCN
- [x] 1.3 Create shared directory for Zod schemas

---

## 2. Environment & Config

- [x] 2.1 Setup `.env` loader and validate critical vars
- [x] 2.2 Create `config/orchestrator.json` default file
- [x] 2.3 Implement config merge logic (orchestrator > API > endpoint)

---

## 3. Backend Routing & Lifecycle

- [x] 3.1 Scaffold core Hono app (`/api` route base)
- [x] 3.2 Implement lifecycle phases: `beforeRequest`, `request`, `afterRequest`
- [x] 3.3 Support lifecycle method chaining and skipping (e.g. cache hit)
- [x] 3.4 Create DCR route for built-in endpoints

---

## 4. ORM & DB Schema

- [x] 4.1 Define Drizzle schema for all tables (`users`, `permissions`, `apis`, etc.)
- [x] 4.2 Implement lifecycle support for DB ops: `beforeExecute`, `execute`, `afterExecute`
- [x] 4.3 Create migration runner (SQL-based migrations)
- [x] 4.4 Add seed script (admin user + dummy endpoint)

---

## 5. Logging & Persistence

- [x] 5.1 Implement `logToDB()` with phase tagging
- [ ] 5.2 Schedule daily export to S3 (exactly 7 days old)
- [x] 5.3 Attach log hooks to each lifecycle phase
- [ ] 5.4 Implement logs viewer backend (with filters)

---

## 6. API Imports & Mapping

- [x] 6.1 Parse Postman collection v2.1 to internal format
- [x] 6.2 Generate `config.json` for each endpoint
- [x] 6.3 Store imported APIs in `apis` and `endpoints` tables with full JSON config
  - [x] Store config files on filesystem with version folders structure
  - [x] Store JSON content in database for redundancy
  - [x] Track config file hashes for integrity checking
- [ ] 6.4 Register and route imported endpoints
- [ ] 6.5 Implement API versioning system
  - [ ] Create version folder structure (`api-name/v1`, `api-name/v2`, etc.)
  - [ ] Add version switching in api.json (`currentVersion` field)
  - [ ] Support accessing multiple versions simultaneously
- [ ] 6.6 Implement local Git-based configuration tracking
  - [ ] Set up local Git repository for config files
  - [ ] Create auto-commit system for config changes
  - [ ] Build simple history viewer in dashboard
- [ ] 6.7 Create JSON configuration editor in dashboard
  - [ ] Monaco-based editor with syntax highlighting
  - [ ] Schema validation against Zod schemas
  - [ ] Auto-completion based on endpoint schemas

---

## 7. Sub-API + Multi-Protocol Communication

- [ ] 7.1 Register sub-APIs and configs
- [ ] 7.2 Implement HTTP, WebSocket, and local RPC request handlers
- [ ] 7.3 Implement fallback priority logic (RPC > HTTP > WS)
- [ ] 7.4 Add retry and delay scheduling with status tracking

---

## 8. Webhooks & Retry Engine

- [ ] 8.1 Attach webhook URL per lifecycle phase and status code
- [ ] 8.2 Implement retry queue table and worker
- [ ] 8.3 Allow manual retry via dashboard
- [ ] 8.4 Add backoff strategy support

---

## 9. Frontend UI

### 9.1 Core UI & Layout
- [x] 9.1.1 Create ShadCN + Tailwind layout (dark/light mode toggle)
- [x] 9.1.2 Implement responsive navigation and sidebar
- [x] 9.1.3 Create reusable components library
- [ ] 9.1.4 Implement global state management with React Context/Redux

### 9.2 Authentication Pages
- [ ] 9.2.1 Login page with JWT token handling
- [ ] 9.2.2 Forgot password page with email verification
- [ ] 9.2.3 Reset password page
- [ ] 9.2.4 User profile and settings page
- [ ] 9.2.5 JWT token refresh mechanism

### 9.3 Dashboard
- [x] 9.3.1 Main dashboard with key metrics
- [ ] 9.3.2 Live API call visualization with D3.js
- [ ] 9.3.3 System health indicators
- [ ] 9.3.4 Recent activity feed
- [x] 9.3.5 Quick access to common actions

### 9.4 Orchestrator
- [x] 9.4.1 API list and overview page
  - [x] API status indicators
  - [ ] Version selection
  - [x] Quick action buttons
- [x] 9.4.2 API detail page
  - [ ] Visual representation of API structure
  - [x] Authentication configuration
  - [x] Endpoint list
- [ ] 9.4.3 API import interface
  - [ ] Postman collection import
  - [ ] Custom format import
  - [ ] Import progress tracking
- [x] 9.4.4 Visual endpoint builder
  - [x] Request configuration
  - [x] Response handling
  - [ ] Lifecycle plugin selection

### 9.5 Plugin Management
- [ ] 9.5.1 Plugin directory and marketplace
- [ ] 9.5.2 Plugin configuration interface
- [ ] 9.5.3 Custom plugin creation wizard
- [ ] 9.5.4 Plugin testing environment

### 9.6 Logs Viewer
- [ ] 9.6.1 Advanced log filtering system
- [ ] 9.6.2 Log detail inspection
- [ ] 9.6.3 Log export functionality
- [ ] 9.6.4 Real-time log streaming
- [ ] 9.6.5 Log archiving interface

### 9.7 Configuration Editor
- [x] 9.7.1 Monaco-based JSON editor
- [x] 9.7.2 Schema validation visualization
- [x] 9.7.3 Config version history viewer
- [ ] 9.7.4 Config diff comparison tool

### 9.8 Scheduler
- [ ] 9.8.1 Request scheduling interface
- [ ] 9.8.2 Retry configuration
- [ ] 9.8.3 Scheduled tasks calendar view
- [ ] 9.8.4 Manual trigger options

### 9.9 User Management
- [ ] 9.9.1 User listing and CRUD operations
- [ ] 9.9.2 Role-based permissions editor
- [ ] 9.9.3 User activity monitoring
- [ ] 9.9.4 Team management

---

## 10. Shared Schemas & Type Safety

- [x] 10.1 Define Zod schemas for users, logs, endpoints, etc.
- [x] 10.2 Export types via `z.infer<typeof Schema>`
- [x] 10.3 Use schemas on backend validation
- [ ] 10.3.1 Use schemas on frontend forms
- [ ] 10.4 Implement schema-driven form builder (future)

---

## 11. Deployment Prep

- [ ] 11.1 Dockerize backend + frontend
- [ ] 11.2 Setup production-ready `.env` and config
- [ ] 11.3 Add system healthcheck endpoint (`/status`)
- [ ] 11.4 Deploy on AWS EC2, attach S3 bucket
```

## 5: Backend Main

### `backend\.env`

```
# DCR Backend Environment Variables

# Database Configuration
DATABASE_URL=sqlite:./data/dcr.db

# Server Configuration
PORT=3000
NODE_ENV=development

# Security (do not use these values in production)
JWT_SECRET=development_secret_key
JWT_S3_BUCKET_NAME=
HASH_ROUNDS=10

# Logging Configuration
LOG_LEVEL=info
SERVICE_ID=dcr-backend

# Feature Flags
ENABLE_LOGGING=true
ENABLE_CACHE=true
```


### `backend\.env.example`

```example
# Database configuration
DATABASE_URL=sqlite:///./data/dcr.db
# DATABASE_URL=postgres://user:password@localhost:5432/dcr_db

# Server settings
PORT=3000
NODE_ENV=development

# AWS S3 configuration
AWS_ACCESS_KEY_ID=your_access_key_id
AWS_SECRET_ACCESS_KEY=your_secret_access_key
S3_BUCKET_NAME=your_bucket_name
S3_REGION=us-east-1
S3_STORAGE_PREFIX=logs/development/

# Log Archiving & Storage Configuration
LOG_STORAGE_DRIVER=archive
LOG_STORAGE_INTERVAL=7
LOG_STORAGE_ZIP_OPTION=none

# FTP Storage Configuration (only needed if LOG_STORAGE_DRIVER=ftp)
#FTP_HOST=ftp.example.com
#FTP_PORT=21
#FTP_USER=ftpuser
#FTP_PASSWORD=ftppassword
#FTP_REMOTE_PATH=/logs/

# Archive (Local Filesystem) Storage
LOG_STORAGE_ARCHIVE_PATH=./archived_logs

# Logging Configuration
LOG_LEVEL=info
SERVICE_ID=dcr-backend-example

# Application mode
ORCHESTRATOR_MODE=dev  # 'dev' or 'prod'
```


### `backend\.eslintrc.cjs`

```cjs
module.exports = {
  root: true,
  env: {
    node: true,
    es2021: true
  },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'prettier'
  ],
  ignorePatterns: ['dist', '*.cjs'],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module'
  },
  plugins: ['@typescript-eslint', 'prettier'],
  rules: {
    'prettier/prettier': 'error',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/no-unused-vars': ['error', { 
      'argsIgnorePattern': '^_',
      'varsIgnorePattern': '^_' 
    }]
  }
}
```


### `backend\.prettierrc`

```
{
  "semi": true,
  "tabWidth": 2,
  "printWidth": 100,
  "singleQuote": true,
  "trailingComma": "es5",
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "endOfLine": "auto"
}
```


### `backend\drizzle.config.ts`

```ts
import type { Config } from 'drizzle-kit';
import * as dotenv from 'dotenv';

dotenv.config();

export default {
  schema: './src/db/schema.ts',
  out: './src/db/migrations',
  driver: 'better-sqlite',
  dbCredentials: {
    url: process.env.DATABASE_URL || './data/dcr.db'
  }
} satisfies Config;
```


### `backend\package.json`

```json
{
  "name": "dcr-backend",
  "version": "0.1.0",
  "description": "Digital Cabinet Relay - Backend Service",
  "type": "module",
  "main": "dist/index.js",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "db:migrate": "tsx src/scripts/run-migrations.ts",
    "db:generate": "drizzle-kit generate:sqlite",
    "db:seed": "tsx src/scripts/seed.ts",
    "db:setup": "npm run db:migrate && npm run db:seed"
  },
  "dependencies": {
    "@hono/node-server": "^1.4.0",
    "bcrypt": "^6.0.0",
    "better-sqlite3": "^11.10.0",
    "dotenv": "^16.3.1",
    "drizzle-orm": "^0.29.0",
    "hono": "^4.0.0",
    "node-cron": "^4.1.0",
    "simple-git": "^3.27.0",
    "sqlite3": "^5.1.6",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/better-sqlite3": "^7.6.13",
    "@types/node": "^20.10.0",
    "@typescript-eslint/eslint-plugin": "^6.10.0",
    "@typescript-eslint/parser": "^6.10.0",
    "drizzle-kit": "^0.20.6",
    "eslint": "^8.53.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.1",
    "prettier": "^3.1.0",
    "tsx": "^4.6.0",
    "typescript": "^5.3.2"
  }
}
```


### `backend\src\config.ts`

```ts
import fs from 'fs';
import path from 'path';
import { ensureDirectoryExists } from './utils/fs-utils.js';
import { z } from 'zod';

// Define log driver config schema
const LogDriverConfigSchema = z.object({
  connectionString: z.string().optional(),
  basePath: z.string().optional(),
  maxSizeMB: z.number().positive().optional(),
  maxFiles: z.number().positive().optional(),
  options: z.record(z.string(), z.any()).optional()
});

// Define log type config schema
const LogTypeConfigSchema = z.object({
  driver: z.string(),
  level: z.enum(['debug', 'info', 'warn', 'error', 'fatal']).default('info')
});

// Define logging config schema
const LoggingConfigSchema = z.object({
  defaultDriver: z.string().default('sqlite'),
  logTypes: z.record(z.string(), LogTypeConfigSchema).optional(),
  drivers: z.record(z.string(), LogDriverConfigSchema).optional(),
  archival: z.object({
    driver: z.enum(['s3', 'ftp', 'archive']).default('archive'),
    interval: z.number().int().positive().default(7),
    zipOption: z.enum(['zipPerLog', 'zipAllTogether', 'none']).default('none')
  }).optional()
});

// Define config schema with Zod
const ConfigSchema = z.object({
  logLevel: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
  defaultRetries: z.number().int().positive().default(3),
  defaultCacheTtl: z.number().int().positive().default(300),
  lifecycle: z.object({
    beforeRequest: z.array(z.string()).default(['auth', 'cache', 'log']),
    request: z.array(z.string()).default(['fetch']),
    afterRequest: z.array(z.string()).default(['log', 'webhook'])
  }),
  logging: LoggingConfigSchema.optional(),
  configDir: z.object({
    basePath: z.string().default('./config'),
    apiPath: z.string().default('apis'),
    gitEnabled: z.boolean().default(true),
    enableAutoCommit: z.boolean().default(true),
    syncWithDb: z.boolean().default(true)
  }).optional()
});

// Default config
const defaultConfig = {
  logLevel: 'debug',
  defaultRetries: 3,
  defaultCacheTtl: 300,
  lifecycle: {
    beforeRequest: ['auth', 'cache', 'log'],
    request: ['fetch'],
    afterRequest: ['log', 'webhook']
  },
  configDir: {
    basePath: './config',
    apiPath: 'apis',
    gitEnabled: true,
    enableAutoCommit: true,
    syncWithDb: true
  },
  logging: {
    defaultDriver: 'sqlite',
    logTypes: {
      application: { driver: 'sqlite', level: 'info' },
      security: { driver: 'sqlite', level: 'warn' },
      request_lifecycle: { driver: 'sqlite', level: 'debug' },
      database_query: { driver: 'sqlite', level: 'debug' },
      external_api_call: { driver: 'sqlite', level: 'debug' }
    },
    drivers: {
      sqlite: {
        // Uses main DATABASE_URL by default
      },
      file: {
        basePath: './logs/',
        maxSizeMB: 10,
        maxFiles: 7
      }
    },
    archival: {
      driver: 'archive',
      interval: 7,
      zipOption: 'none'
    }
  }
};

// Function to merge configs
export function mergeConfigs(base: any, override: any): any {
  const result = { ...base };

  for (const key in override) {
    if (override[key] === null || override[key] === undefined) {
      continue;
    }
    
    if (typeof override[key] === 'object' && !Array.isArray(override[key])) {
      result[key] = mergeConfigs(base[key] || {}, override[key]);
    } else {
      result[key] = override[key];
    }
  }

  return result;
}

// Load orchestrator config
function loadOrchestratorConfig() {
  try {
    const configPath = path.resolve(process.cwd(), 'config', 'orchestrator.json');
    if (fs.existsSync(configPath)) {
      const fileContent = fs.readFileSync(configPath, 'utf-8');
      const parsedConfig = JSON.parse(fileContent);
      return ConfigSchema.parse(parsedConfig);
    }
  } catch (error) {
    console.warn('Failed to load orchestrator config:', error);
  }
  
  return defaultConfig;
}

export const config = loadOrchestratorConfig();

// Get absolute path to the config base directory
export function getConfigBasePath(): string {
  const basePath = path.resolve(process.cwd(), config.configDir?.basePath || './config');
  ensureDirectoryExists(basePath).catch((err: Error) => console.error('Failed to create config directory:', err));
  return basePath;
}

// Get absolute path to the API configs directory
export function getApiConfigPath(): string {
  const apiPath = path.join(getConfigBasePath(), config.configDir?.apiPath || 'apis');
  ensureDirectoryExists(apiPath).catch((err: Error) => console.error('Failed to create API config directory:', err));
  return apiPath;
}

// Config directory path for convenience
export const configDir = {
  base: getConfigBasePath(),
  apis: getApiConfigPath()
};
```


### `backend\src\env.ts`

```ts
import { z } from 'zod';
import * as dotenv from 'dotenv';

// Load environment variables
dotenv.config();

// Define schema for environment variables
const envSchema = z.object({
  // Database
  DATABASE_URL: z.string().min(1, { message: 'DATABASE_URL is required' }),
  
  // Server settings
  PORT: z.string().transform((val) => parseInt(val, 10)).pipe(z.number().positive()),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  
  // Application info
  APP_VERSION: z.string().default('1.0.0'),
  
  // AWS S3 and other storage credentials
  AWS_ACCESS_KEY_ID: z.string().optional(),
  AWS_SECRET_ACCESS_KEY: z.string().optional(),
  S3_BUCKET_NAME: z.string().optional(),
  S3_REGION: z.string().optional(),
  S3_STORAGE_PREFIX: z.string().optional(),
  
  // Log Archiving & Storage Configuration
  LOG_STORAGE_DRIVER: z.enum(['s3', 'ftp', 'archive']).default('archive'),
  LOG_STORAGE_INTERVAL: z.coerce.number().default(7), // In days
  LOG_STORAGE_ZIP_OPTION: z.enum(['zipPerLog', 'zipAllTogether', 'none']).default('none'),
  
  // FTP Storage Configuration
  FTP_HOST: z.string().optional(),
  FTP_PORT: z.coerce.number().default(21),
  FTP_USER: z.string().optional(),
  FTP_PASSWORD: z.string().optional(),
  FTP_REMOTE_PATH: z.string().optional(),
  
  // Archive (Local Filesystem) Storage
  LOG_STORAGE_ARCHIVE_PATH: z.string().optional(),
  
  // Application mode
  ORCHESTRATOR_MODE: z.enum(['primary', 'worker', 'standalone', 'test', 'dev', 'prod']).default('dev'),
  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
  SERVICE_ID: z.string().default('dcr-backend'),
});

// Process environment variables
function validateEnv() {
  try {
    // Parse and validate environment variables
    const env = envSchema.safeParse(process.env);

    if (!env.success) {
      console.error('❌ Invalid environment variables:');
      const errors = env.error.format();
      console.error(JSON.stringify(errors, null, 2));
      
      // Check for critical errors that should prevent startup
      const criticalVars = ['DATABASE_URL', 'PORT'];
      const hasCriticalErrors = criticalVars.some(
        (varName) => errors[varName as keyof typeof errors]
      );

      if (hasCriticalErrors) {
        throw new Error('Critical environment variables missing or invalid');
      }

      // Return default values for non-critical errors
      return envSchema.parse({
        ...process.env,
        PORT: process.env.PORT || '3000',
        NODE_ENV: process.env.NODE_ENV || 'development',
        ORCHESTRATOR_MODE: process.env.ORCHESTRATOR_MODE || 'dev'
      });
    }

    return env.data;
  } catch (error) {
    console.error('Failed to parse environment variables:', error);
    process.exit(1);
  }
}

// Export validated environment variables
export const env = validateEnv();
```


### `backend\src\index.ts`

```ts
import { Hono } from 'hono';
import { serve } from '@hono/node-server';
import { cors } from 'hono/cors';
import { serveStatic } from '@hono/node-server/serve-static';
import process from 'node:process';
import { env } from './env.js';
import { config } from './config.js';
import { setupApiRoutes } from './routes/api.js';
import { setupDcrRoutes } from './routes/dcr.js';
import { lifecycleMiddleware } from './lifecycle/index.js';
import { loggerMiddleware, systemLogger, initializeLogging, shutdownLogging } from './logging/index.js';
import { initializeScheduler, shutdownScheduler } from './scheduler/index.js';
import type { Context } from 'hono';

// Initialize Hono app
const app = new Hono();

// Apply global middleware
app.use('*', loggerMiddleware());
app.use('*', cors());
app.use('*', lifecycleMiddleware());
app.use('/static/*', serveStatic({ root: './' }));

// Setup base routes
app.get('/', (c: Context) => {
  return c.json({
    status: 'ok',
    message: 'Digital Cabinet Relay API',
    version: env.APP_VERSION || '1.0.0',
    environment: env.NODE_ENV
  });
});

// Server health check
app.get('/health', (c: Context) => {
  return c.json({ 
    status: 'up',
    timestamp: new Date().toISOString(),
    config: { 
      logLevel: config.logLevel,
      orchestratorMode: env.ORCHESTRATOR_MODE
    }
  });
});

// Setup API routes with /api base path
const api = new Hono();
const apiRouter = setupApiRoutes();
app.route('/api', apiRouter);

// Setup DCR internal routes with /dcr base path
const dcr = new Hono();
setupDcrRoutes(dcr);
app.route('/dcr', dcr);

// Initialize the scheduler for periodic tasks
initializeScheduler().catch(err => {
  systemLogger.error('Error initializing scheduler', { error: err });
});

// Initialize the logging system
initializeLogging().catch(err => {
  console.error('Error initializing logging system:', err);
});

// Start the server
const port = env.PORT ? parseInt(env.PORT, 10) : 3000;

systemLogger.info(`Starting DCR backend server on port ${port.toString()}`, {
  environment: env.NODE_ENV,
  version: env.SERVICE_ID || '1.0.0'
});

// @hono/node-server expects port as a number
serve({
  fetch: app.fetch,
  port
});

// Setup graceful shutdown handlers
process.on('SIGINT', async () => {
  systemLogger.info('Received SIGINT, shutting down gracefully');
  try {
    await shutdownScheduler();
    systemLogger.info('Scheduler shut down successfully');
    
    await shutdownLogging();
    systemLogger.info('Logging system shut down successfully');
  } catch (err) {
    console.error('Error during graceful shutdown:', err);
  }
  process.exit(0);
});

process.on('SIGTERM', async () => {
  systemLogger.info('Received SIGTERM, shutting down gracefully');
  try {
    await shutdownScheduler();
    systemLogger.info('Scheduler shut down successfully');
    
    await shutdownLogging();
    systemLogger.info('Logging system shut down successfully');
  } catch (err) {
    console.error('Error during graceful shutdown:', err);
  }
  process.exit(0);
});

// Global error handlers
process.on('unhandledRejection', (reason: unknown) => {
  systemLogger.error('Unhandled Promise rejection', { reason });
});

process.on('uncaughtException', (error: Error) => {
  systemLogger.error('Uncaught exception', { error });
  // Critical errors should terminate the process for proper restart
  process.exit(1);
});

console.log(`🚀 Server running at http://localhost:${port}`);
console.log(`📋 Environment: ${env.NODE_ENV}`);
console.log(`🔧 Orchestrator mode: ${env.ORCHESTRATOR_MODE}`);
console.log(`🛣️ Routes available:`);

console.log(`   - / (Root)`);
console.log(`   - /health (Health check)`);
console.log(`   - /api/* (API endpoints)`);
console.log(`   - /dcr/* (Internal DCR endpoints)`);
```


### `backend\tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "esModuleInterop": true,
    "strict": true,
    "outDir": "dist",
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

## 6: Backend API Import

### `backend\src\controllers\api-import.controller.ts`

```ts
import { Hono } from "hono";
import path from "path";

// Import services
import { GitService } from "../services/git.service.js";
import { ConfigFileService } from "../services/config-fs.service.js";
import { ImportValidatorService } from "../services/import-validator.service.js";

// Import modular routers
import { createValidateRouter } from "./api-import/validate.js";
import { createImportRouter } from "./api-import/import.js";
import { createShareRouter } from "./api-import/share.js";
import { createActivateRouter } from "./api-import/activate.js";
import { createGitRouter } from "./api-import/git.js";

// Initialize service instances
const gitService = new GitService();
const configFileService = new ConfigFileService();
const importValidatorService = new ImportValidatorService();

// Create main app instance
const app = new Hono();

// Mount modular routers

// Validate router - handles collection validation
const validateRouter = createValidateRouter(importValidatorService);
app.route("/validate", validateRouter);

// Legacy endpoint - redirect upload to import
app.post("/upload", async (c) => {
  console.warn("Legacy /upload endpoint called, redirecting to /import");
  return c.redirect("/api/import");
});

// Git router - handles Git history and diff operations
const gitRouter = createGitRouter(gitService);
app.route("/git", gitRouter);

// Share router - handles collection sharing
const shareRouter = createShareRouter();
app.route("/share", shareRouter);

// Activate router - handles endpoint activation
const activateRouter = createActivateRouter();
app.route("/activate", activateRouter);

// Import router - handles collection import
const importRouter = createImportRouter(importValidatorService, configFileService, gitService);
app.route("/import", importRouter);

export default app;
```


### `backend\src\controllers\api-import\activate.ts`

```ts
import { Context, Hono } from "hono";
import { eq, and, inArray } from "drizzle-orm";
import { db } from "../../db/index.js";
import { activateEndpointsSchema } from "./schemas.js";
import { collections, endpoints, activeEndpoints } from "../../db/schema.js";

// Define types for database entities
type Endpoint = {
  id: number;
  apiId: number;
  path: string;
  method: string;
  description: string | null;
  config: string;
  configHash: string;
  version: string;
};

type Collection = {
  id: number;
  ownerId: number;
  name: string;
  slug: string;
};

export function createActivateRouter(): Hono {
  const router = new Hono();

  // Endpoint to activate specific endpoints from a collection
  router.post("/", async (c: Context) => {
    try {
      const body = await c.req.json();
      const { collectionId, endpointIds, userId } = activateEndpointsSchema.parse(body);
      
      // Check if collection exists
      const collectionResult = await db.select()
        .from(collections)
        .where(eq(collections.id, collectionId))
        .execute();
      
      if (collectionResult.length === 0) {
        return c.json({
          success: false,
          error: "Collection not found",
        }, 404);
      }
      
      // Find endpoints that match the provided IDs
      const existingEndpoints = await db.select()
        .from(endpoints)
        .where(inArray(endpoints.id, endpointIds))
        .execute() as Endpoint[];
      
      if (existingEndpoints.length === 0) {
        return c.json({
          success: false,
          error: "No valid endpoints found to activate",
        }, 400);
      }
      
      // These are all valid endpoints since we filtered by the IDs directly
      const validEndpoints = existingEndpoints;
      
      if (validEndpoints.length === 0) {
        return c.json({
          success: false,
          error: "No valid endpoints found to activate",
        }, 400);
      }
      
      // Create active endpoint records
      const activeEndpointInserts = validEndpoints.map(endpoint => ({
        collectionId,
        endpointId: endpoint.id,
        activatedBy: userId,
        isActive: true,
        activatedAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }));
      
      const activationResults = await db.insert(activeEndpoints)
        .values(activeEndpointInserts as any)
        .returning();
      
      return c.json({
        success: true,
        data: {
          activatedEndpoints: activationResults.length,
          endpoints: validEndpoints
        }
      });
    } catch (error: any) {
      console.error("Activation error:", error);
      return c.json({
        success: false,
        error: error.message || "Failed to activate endpoints",
      }, 400);
    }
  });

  return router;
}
```


### `backend\src\controllers\api-import\git.ts`

```ts
import { Context, Hono } from "hono";
import { GitService } from "../../services/git.service.js";

export function createGitRouter(gitService: GitService) {
  const router = new Hono();

  // Endpoint to get Git history for an API
  router.get("/history/:apiSlug", async (c: Context) => {
    try {
      const { apiSlug } = c.req.param();
      
      // Get Git history for the API
      const history = await gitService.getCommitHistory(apiSlug);
      
      return c.json({
        success: true,
        data: {
          history
        }
      });
    } catch (error: any) {
      console.error("Git history error:", error);
      return c.json({
        success: false,
        error: error.message || "Failed to get Git history",
      }, 400);
    }
  });

  // Endpoint to get Git diff for a commit
  router.get("/diff/:apiSlug/:commitId", async (c: Context) => {
    try {
      const { apiSlug, commitId } = c.req.param();
      
      // Get the diff for the specified commit
      const diff = await gitService.getDiff(apiSlug, commitId);
      
      return c.json({
        success: true,
        data: {
          diff
        }
      });
    } catch (error: any) {
      console.error("Git diff error:", error);
      return c.json({
        success: false,
        error: error.message || "Failed to get Git diff",
      }, 400);
    }
  });

  return router;
}
```


### `backend\src\controllers\api-import\import.ts`

```ts
import { Context, Hono } from "hono";
import { db } from "../../db/index.js";
import { apis, collections, endpoints, activeEndpoints } from "../../db/schema.js";
import { ImportValidatorService } from "../../services/import-validator.service.js";
import { ConfigFileService } from "../../services/config-file.service.js";
import { GitService } from "../../services/git.service.js";
import { extendedImportSchema, apiInsertSchema } from "./schemas.js";

export function createImportRouter(
  importValidatorService: ImportValidatorService,
  configFileService: ConfigFileService,
  gitService: GitService
) {
  const router = new Hono();

  // Endpoint to import a validated Postman collection
  router.post("/", async (c: Context) => {
    try {
      const body = await c.req.json();
      const validatedBody = extendedImportSchema.parse(body);
      
      const { 
        collectionData, 
        name, 
        description, 
        version, 
        basePath, 
        tags = [], 
        selectedEndpoints = [],
        userId = 1 
      } = validatedBody;
      
      // Step 1: Validate the collection
      const { validatedCollection, endpointSelections } = 
        await importValidatorService.validatePostmanCollection(collectionData);
      
      // Step 2: Generate a slug for the API
      const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
      
      // Step 3: Initialize Git repository if needed
      await gitService.ensureGitInitialized();
      
      // Step 4: Filter selected endpoints
      const filteredEndpoints = importValidatorService.filterSelectedEndpoints(
        validatedCollection,
        selectedEndpoints,
        endpointSelections
      ).endpoints;
      
      // Step 5: Insert API record
      // Prepare the API config as JSON
      const apiConfig = JSON.stringify({
        name,
        description: description || validatedCollection.description || '',
        basePath: basePath || validatedCollection.baseUrl || '',
        version,
        type: "http"
      });
      
      // Calculate config hash
      const apiConfigHash = await configFileService.calculateHash(apiConfig);
      
      // Create API insert object with correct schema and properties
      const apiInsert = {
        name,
        slug,
        description: description || validatedCollection.description || '',
        basePath: basePath || validatedCollection.baseUrl || '',
        version,
        tags: tags || [],
        active: true,
        type: "http", // Default to HTTP API type
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        config: apiConfig,
        configHash: apiConfigHash
      };
      
      const apiResult = await db.insert(apis).values(apiInsert as any).returning();
      const apiId = apiResult[0].id;
      
      // Step 6: Save collection data to DB
      const collectionInsert = {
        apiId,
        userId,
        name,
        description: description || validatedCollection.description || '',
        rawData: collectionData,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        metadata: JSON.stringify({
          endpointCount: validatedCollection.endpoints.length || 0,
          selectedCount: selectedEndpoints.length,
          version
        })
      };
      
      const collectionRecord = await db.insert(collections).values(collectionInsert as any).returning();
      const collectionId = collectionRecord[0].id;
      
      // Step 7: Insert endpoints
      const endpointInserts = [];
      
      // Define the filtered endpoints type
      const typedFilteredEndpoints = filteredEndpoints as any[];
      
      for (const endpoint of typedFilteredEndpoints) {
        // Create endpoint config
        const endpointConfig = JSON.stringify({
          headers: endpoint.headers || {},
          body: endpoint.body || {}
        });
        
        // Calculate config hash
        const configHash = await configFileService.calculateHash(endpointConfig);
        
        // Create endpoint insert object
        endpointInserts.push({
          apiId,
          method: endpoint.method,
          path: endpoint.path,
          description: endpoint.description || '',
          requestSchema: JSON.stringify(endpoint.params || {}),
          responseSchema: JSON.stringify({}),
          config: endpointConfig,
          configHash,
          active: true,
          version,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        });
      }
      
      const endpointResults = await db.insert(endpoints).values(endpointInserts as any).returning();
      
      // Step 8: Insert active endpoints
      const activeEndpointInserts = endpointResults.map(endpoint => ({
        endpointId: endpoint.id,
        userId,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }));
      
      await db.insert(activeEndpoints).values(activeEndpointInserts as any);
      
      // Step 9: Save API and endpoint configs to filesystem
      await configFileService.saveApiConfig(
        slug,
        JSON.parse(apiConfig)
      );
      
      for (const endpoint of endpointResults) {
        // For each endpoint, save its config to filesystem
        await configFileService.saveEndpointConfig(
          slug,
          version,
          { 
            method: endpoint.method, 
            path: endpoint.path 
          },
          JSON.parse(endpoint.config)
        );
      }
      
      // Step 10: Commit changes to Git
      await gitService.commitChanges(`Imported API ${name} with ${endpointResults.length} endpoints`);
      
      return c.json({
        success: true,
        data: {
          api: apiResult[0],
          collection: collectionRecord[0],
          endpoints: endpointResults.length,
          activeEndpoints: activeEndpointInserts.length
        },
      });
    } catch (error: any) {
      console.error("Import error:", error);
      return c.json({
        success: false,
        error: error.message || "Failed to import Postman collection",
      }, 400);
    }
  });

  return router;
}
```


### `backend\src\controllers\api-import\schemas.ts`

```ts
import { z } from "zod";

// Base schema for importing Postman collections
export const importPostmanSchema = z.object({
  collectionData: z.string().min(1),
  name: z.string().min(1),
  description: z.string().optional(),
  version: z.string().default("v1"),
  basePath: z.string().optional(),
  tags: z.array(z.string()).optional(),
  selectedEndpoints: z.array(z.string()).optional(),
});

// Extended schema for import with selective endpoints
export const extendedImportSchema = importPostmanSchema.extend({
  selectedEndpoints: z.array(z.string()).default([]),
  userId: z.number().default(1) // Default to user ID 1 if not provided
});

// Define schema for collection sharing
export const shareCollectionSchema = z.object({
  collectionId: z.number(),
  userIds: z.array(z.number())
});

// Define schema for selective endpoint activation
export const activateEndpointsSchema = z.object({
  collectionId: z.number(),
  endpointIds: z.array(z.number()),
  userId: z.number().default(1) // Default to user ID 1 if not provided
});

// Schema for DB inserts - typed according to database requirements
export const apiInsertSchema = z.object({
  name: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  basePath: z.string().nullable(),
  version: z.string(),
  tags: z.array(z.string()),
  active: z.boolean().default(true),
  type: z.enum(["http", "websocket", "rpc"]).default("http"),
  config: z.string(),
  configHash: z.string(),
  createdAt: z.string(),
  updatedAt: z.string()
});

export const endpointInsertSchema = z.object({
  apiId: z.number(),
  method: z.string(),
  path: z.string(),
  description: z.string().nullable(),
  requestSchema: z.string().default("{}"),
  responseSchema: z.string().default("{}"),
  config: z.string(),
  configHash: z.string(),
  active: z.boolean().default(true),
  version: z.string(),
  createdAt: z.string(),
  updatedAt: z.string()
});

export const collectionInsertSchema = z.object({
  apiId: z.number(),
  userId: z.number(),
  name: z.string(),
  description: z.string(),
  rawData: z.string(),
  metadata: z.string(),
  createdAt: z.string(),
  updatedAt: z.string()
});
```


### `backend\src\controllers\api-import\share.ts`

```ts
import { Context, Hono } from "hono";
import { db } from "../../db/index.js";
import { collectionShares } from "../../db/schema.js";
import { shareCollectionSchema } from "./schemas.js";

export function createShareRouter() {
  const router = new Hono();

  // Endpoint to share a collection with other users
  router.post("/", async (c: Context) => {
    try {
      const body = await c.req.json();
      const { collectionId, userIds } = shareCollectionSchema.parse(body);
      
      // Create share records for each user
      const shareInserts = userIds.map(userId => ({
        collectionId,
        userId,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }));
      
      const shareResults = await db.insert(collectionShares).values(shareInserts as any).returning();
      
      return c.json({
        success: true,
        data: {
          shares: shareResults.length
        }
      });
    } catch (error: any) {
      console.error("Share error:", error);
      return c.json({
        success: false,
        error: error.message || "Failed to share collection",
      }, 400);
    }
  });

  return router;
}
```


### `backend\src\controllers\api-import\validate.ts`

```ts
import { Context, Hono } from "hono";
import { ImportValidatorService } from "../../services/import-validator.service.js";
import { importPostmanSchema } from "./schemas.js";

export function createValidateRouter(importValidatorService: ImportValidatorService) {
  const router = new Hono();

  // Endpoint to validate Postman collection
  router.post("/", async (c: Context) => {
    try {
      const body = await c.req.json();
      const { collectionData } = importPostmanSchema.parse(body);
      
      // Use the import validator service to validate the collection
      const { validatedCollection, endpointSelections } = 
        await importValidatorService.validatePostmanCollection(collectionData);
      
      // Return collection overview and endpoint selections
      const overview = importValidatorService.getCollectionOverview(validatedCollection);
      
      return c.json({
        success: true,
        data: {
          ...overview,
          endpointSelections
        },
      });
    } catch (error: any) {
      console.error("Validation error:", error);
      return c.json({
        success: false,
        error: error.message || "Failed to validate Postman collection",
      }, 400);
    }
  });

  return router;
}
```

## 7: Backend Database

### `backend\src\db\index.ts`

```ts
import { drizzle } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';
import * as schema from './schema.js';
import { env } from '../env.js';
// Node.js process import not needed
// import process from 'node:process';
import fs from 'node:fs';
import path from 'node:path';

// Load database path from environment variables
const dbPath = env.DATABASE_URL || 'sqlite:///data/dcr.db';

// Extract file path from connection string
const filePath = dbPath.replace('sqlite:', '');

// Get absolute path resolution
const fullDbPath = path.resolve(process.cwd(), filePath);
const dbDir = path.dirname(fullDbPath);

// Ensure the directory exists
if (!fs.existsSync(dbDir)) {
  fs.mkdirSync(dbDir, { recursive: true });
  console.log(`Created database directory: ${dbDir}`);
}

// Connect to SQLite database
const sqlite = new Database(fullDbPath);
console.log(`Connected to database at: ${fullDbPath}`);

// Create drizzle instance
export const db = drizzle(sqlite, { schema });

// Export schema for migrations and other uses
export { schema };
```


### `backend\src\db\lifecycle.ts`

```ts
import { db } from './index.ts';
import { config } from '../config/index.ts';
import { Context } from 'hono';

// Types
export type DbOperation = 'select' | 'insert' | 'update' | 'delete';

export interface DbContext {
  table: string;
  operation: DbOperation;
  query: unknown;
  params?: unknown[];
  result?: unknown;
  startTime?: number;
  endTime?: number;
  error?: Error;
}

// Type for DB lifecycle hook handlers
export type DbHookHandler = (
  c: Context | null,
  dbContext: DbContext
) => Promise<void> | void;

// Registry for DB lifecycle hooks
const dbHooks: Record<string, Record<string, DbHookHandler>> = {
  beforeExecute: {},
  execute: {},
  afterExecute: {}
};

// Register a DB hook for a specific lifecycle stage
export function registerDbHook(
  type: string,
  name: string,
  handler: DbHookHandler
): void {
  if (!dbHooks[type]) {
    dbHooks[type] = {};
  }
  
  dbHooks[type][name] = handler;
}

// Execute DB hooks for a specific lifecycle stage
export async function executeDbHooks(
  type: string,
  c: Context | null,
  dbContext: DbContext
): Promise<DbContext> {
  const context = { ...dbContext };
  
  // Get the configured hooks for this stage
  const configuredHooks = config.db.lifecycle[type as keyof typeof config.db.lifecycle] || [];
  
  for (const hookName of configuredHooks) {
    const hook = dbHooks[type][hookName];
    
    if (!hook) {
      console.warn(`DB Hook ${hookName} for ${type} not found`);
      continue;
    }
    
    try {
      await hook(c, context);
    } catch (error) {
      console.error(`Error executing DB ${type} hook ${hookName}:`, error);
      context.error = error as Error;
      
      // For beforeExecute hooks, we might want to abort the chain
      if (type === 'beforeExecute') {
        break;
      }
    }
  }
  
  return context;
}

// Enhanced query executor with lifecycle hooks
export async function executeWithLifecycle<T>(
  c: Context | null,
  table: string,
  operation: DbOperation,
  query: () => Promise<T>
): Promise<T> {
  // Create initial DB context
  const dbContext: DbContext = {
    table,
    operation,
    query,
    startTime: Date.now()
  };
  
  // Execute beforeExecute hooks
  const beforeContext = await executeDbHooks('beforeExecute', c, dbContext);
  
  // If there was an error in beforeExecute, we should abort
  if (beforeContext.error) {
    throw beforeContext.error;
  }
  
  try {
    // Execute the query
    const result = await query();
    
    // Update context with result and end time
    beforeContext.result = result;
    beforeContext.endTime = Date.now();
    
    // Execute afterExecute hooks
    await executeDbHooks('afterExecute', c, beforeContext);
    
    return result;
  } catch (error) {
    // Update context with error and end time
    beforeContext.error = error as Error;
    beforeContext.endTime = Date.now();
    
    // Execute afterExecute hooks even if there was an error
    await executeDbHooks('afterExecute', c, beforeContext);
    
    throw error;
  }
}

// Enhanced DB methods with lifecycle hooks
export const dbWithLifecycle = {
  select: <T>(
    c: Context | null,
    table: string,
    fn: () => Promise<T>
  ): Promise<T> => {
    return executeWithLifecycle(c, table, 'select', fn);
  },
  
  insert: <T>(
    c: Context | null,
    table: string,
    fn: () => Promise<T>
  ): Promise<T> => {
    return executeWithLifecycle(c, table, 'insert', fn);
  },
  
  update: <T>(
    c: Context | null,
    table: string,
    fn: () => Promise<T>
  ): Promise<T> => {
    return executeWithLifecycle(c, table, 'update', fn);
  },
  
  delete: <T>(
    c: Context | null,
    table: string,
    fn: () => Promise<T>
  ): Promise<T> => {
    return executeWithLifecycle(c, table, 'delete', fn);
  }
};

// Example DB hook for validation
registerDbHook('beforeExecute', 'validate', (_c, dbContext) => {
  // Here you would implement validation logic based on operation and table
  console.log(`Validating ${dbContext.operation} on ${dbContext.table}`);
});

// Example DB hook for logging
registerDbHook('afterExecute', 'log', (_c, dbContext) => {
  const duration = (dbContext.endTime || 0) - (dbContext.startTime || 0);
  console.log(`${dbContext.operation.toUpperCase()} on ${dbContext.table} took ${duration}ms`);
  
  // In a real implementation, you would log to your database or external log service
});
```


### `backend\src\db\migrations\0000_initial_schema.sql`

```sql
-- Migration: 0000_initial_schema
-- Created at: 2025-06-02T18:17:00

-- Create users table
CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  email TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  role TEXT CHECK (role IN ('admin', 'user', 'manager')) NOT NULL DEFAULT 'user',
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- Create permissions table
CREATE TABLE IF NOT EXISTS permissions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  resource TEXT NOT NULL,
  action TEXT NOT NULL,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Create apis table
CREATE TABLE IF NOT EXISTS apis (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL UNIQUE,
  description TEXT,
  base_url TEXT,
  type TEXT CHECK (type IN ('http', 'websocket', 'rpc')) NOT NULL DEFAULT 'http',
  config_json TEXT NOT NULL DEFAULT '{}',
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- Create endpoints table
CREATE TABLE IF NOT EXISTS endpoints (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  api_id INTEGER NOT NULL,
  name TEXT NOT NULL,
  path TEXT NOT NULL,
  method TEXT NOT NULL,
  description TEXT,
  config_json TEXT NOT NULL DEFAULT '{}',
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (api_id) REFERENCES apis(id)
);

-- Create logs table
CREATE TABLE IF NOT EXISTS logs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  timestamp TEXT DEFAULT CURRENT_TIMESTAMP,
  endpoint_id INTEGER,
  phase TEXT CHECK (
    phase IN ('beforeRequest', 'request', 'afterRequest', 'beforeExecute', 'execute', 'afterExecute')
  ) NOT NULL,
  success INTEGER NOT NULL DEFAULT 1,
  message TEXT NOT NULL,
  metadata_json TEXT,
  FOREIGN KEY (endpoint_id) REFERENCES endpoints(id)
);

-- Create webhooks table
CREATE TABLE IF NOT EXISTS webhooks (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  endpoint_id INTEGER NOT NULL,
  phase TEXT CHECK (
    phase IN ('beforeRequest', 'request', 'afterRequest', 'beforeExecute', 'execute', 'afterExecute')
  ) NOT NULL,
  status_code INTEGER,
  url TEXT NOT NULL,
  FOREIGN KEY (endpoint_id) REFERENCES endpoints(id)
);

-- Create cache table
CREATE TABLE IF NOT EXISTS cache (
  key TEXT PRIMARY KEY,
  value_json TEXT NOT NULL,
  expires_at INTEGER NOT NULL
);

-- Create retry_schedule table
CREATE TABLE IF NOT EXISTS retry_schedule (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  request_id TEXT NOT NULL UNIQUE,
  endpoint_id INTEGER,
  next_try INTEGER NOT NULL,
  attempts INTEGER NOT NULL DEFAULT 0,
  status TEXT CHECK (status IN ('pending', 'processing', 'completed', 'failed')) NOT NULL DEFAULT 'pending',
  FOREIGN KEY (endpoint_id) REFERENCES endpoints(id)
);
```


### `backend\src\db\schema.ts`

```ts
import { sql } from 'drizzle-orm';
import { integer, sqliteTable, text, primaryKey } from 'drizzle-orm/sqlite-core';

// Users table
export const users = sqliteTable('users', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  email: text('email').notNull().unique(),
  passwordHash: text('password_hash').notNull(),
  role: text('role', { enum: ['admin', 'user'] }).notNull().default('user'),
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at').default(sql`CURRENT_TIMESTAMP`)
});

// Permissions table
export const permissions = sqliteTable('permissions', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: integer('user_id').notNull().references(() => users.id),
  resource: text('resource').notNull(),
  action: text('action').notNull(),
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at').default(sql`CURRENT_TIMESTAMP`)
});

// APIs table
export const apis = sqliteTable('apis', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  name: text('name').notNull().unique(),
  slug: text('slug').notNull().unique(),
  description: text('description'),
  baseUrl: text('base_url'),
  type: text('type', { enum: ['http', 'websocket', 'rpc'] }).notNull().default('http'),
  config: text('config').notNull(),
  configHash: text('config_hash').notNull(),
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at').default(sql`CURRENT_TIMESTAMP`)
});

// Endpoints table
export const endpoints = sqliteTable('endpoints', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  apiId: integer('api_id').notNull().references(() => apis.id),
  path: text('path').notNull(),
  method: text('method').notNull(),
  description: text('description'),
  version: text('version').notNull().default('v1'),
  config: text('config').notNull(),
  configHash: text('config_hash').notNull(),
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at').default(sql`CURRENT_TIMESTAMP`)
});

// Logs table
export const logs = sqliteTable('logs', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  timestamp: text('timestamp').default(sql`CURRENT_TIMESTAMP`),
  endpointId: integer('endpoint_id').references(() => endpoints.id),
  phase: text('phase', {
    enum: ['beforeRequest', 'request', 'afterRequest', 'beforeExecute', 'execute', 'afterExecute']
  }).notNull(),
  success: integer('success', { mode: 'boolean' }).notNull(),
  message: text('message').notNull(),
  metadataJson: text('metadata_json')
});

// Webhooks table
export const webhooks = sqliteTable('webhooks', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  endpointId: integer('endpoint_id').notNull().references(() => endpoints.id),
  phase: text('phase', {
    enum: ['beforeRequest', 'request', 'afterRequest', 'beforeExecute', 'execute', 'afterExecute']
  }).notNull(),
  statusCode: integer('status_code'),
  url: text('url').notNull()
});

// Cache table
export const cache = sqliteTable('cache', {
  key: text('key').primaryKey(),
  valueJson: text('value_json').notNull(),
  expiresAt: integer('expires_at').notNull()
});

// Retry schedule table
export const retrySchedule = sqliteTable('retry_schedule', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  requestId: text('request_id').notNull().unique(),
  endpointId: integer('endpoint_id').references(() => endpoints.id),
  nextTry: integer('next_try').notNull(),
  attempts: integer('attempts').notNull().default(0),
  status: text('status', { enum: ['pending', 'processing', 'completed', 'failed'] }).notNull().default('pending')
});

// Imported collections table (stores raw collections that can be selectively imported)
export const collections = sqliteTable('collections', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  name: text('name').notNull(),
  slug: text('slug').notNull().unique(),
  description: text('description'),
  type: text('type').notNull(), // e.g., "postman", "openapi"
  rawData: text('raw_data').notNull(), // Original raw collection data
  configHash: text('config_hash').notNull(),
  ownerId: integer('owner_id').references(() => users.id).notNull(), // User who imported the collection
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: text('updated_at').default(sql`CURRENT_TIMESTAMP`).notNull(),
});

// Collection shares table (tracks which users have access to which collections)
export const collectionShares = sqliteTable(
  'collection_shares',
  {
    collectionId: integer('collection_id').references(() => collections.id).notNull(),
    userId: integer('user_id').references(() => users.id).notNull(),
    createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`).notNull(),
  },
  (table) => {
    return {
      pk: primaryKey({ columns: [table.collectionId, table.userId] }),
    };
  }
);

// Active endpoints table (tracks which endpoints have been activated from collections)
export const activeEndpoints = sqliteTable('active_endpoints', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  collectionId: integer('collection_id').references(() => collections.id).notNull(),
  endpointId: integer('endpoint_id').references(() => endpoints.id).notNull(),
  activatedBy: integer('activated_by').references(() => users.id).notNull(),
  isActive: integer('is_active', { mode: 'boolean' }).notNull().default(true),
  activatedAt: text('activated_at').default(sql`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: text('updated_at').default(sql`CURRENT_TIMESTAMP`).notNull(),
});
```


### `backend\src\db\transactions.ts`

```ts
import { Context } from 'hono';
import { db } from './index.ts';
import { SQLiteTransaction } from 'drizzle-orm/better-sqlite3';
import { executeDbHooks, DbOperation, DbContext } from './lifecycle.ts';

// Type for transaction callback functions
export type TransactionCallback<T> = (tx: SQLiteTransaction<typeof db>) => Promise<T> | T;

/**
 * Execute a database transaction with lifecycle hooks
 * @param c - Hono context or null
 * @param callback - Function to execute within transaction
 * @returns Result of the transaction
 */
export async function withTransaction<T>(
  c: Context | null,
  callback: TransactionCallback<T>
): Promise<T> {
  // Create transaction context
  const txContext: DbContext = {
    table: 'transaction',
    operation: 'select' as DbOperation, // Using select as the closest operation type
    query: 'Transaction started',
    startTime: Date.now()
  };

  // Execute beforeExecute hooks
  const hookContext = await executeDbHooks('beforeExecute', c, txContext);
  
  // If there was an error in beforeExecute, we should abort
  if (hookContext.error) {
    throw hookContext.error;
  }

  try {
    // Execute the transaction
    const result = await db.transaction(async (tx: SQLiteTransaction<typeof db>) => {
      return await callback(tx);
    });
    
    // Update context with result and end time
    hookContext.result = result;
    hookContext.endTime = Date.now();
    
    // Execute afterExecute hooks
    await executeDbHooks('afterExecute', c, hookContext);
    
    return result;
  } catch (error) {
    // Update context with error and end time
    hookContext.error = error as Error;
    hookContext.endTime = Date.now();
    
    // Execute afterExecute hooks even if there was an error
    await executeDbHooks('afterExecute', c, hookContext);
    
    throw error;
  }
}

/**
 * Execute a read-only database query with lifecycle hooks
 * @param c - Hono context or null
 * @param table - Table being queried
 * @param callback - Function to execute
 * @returns Result of the query
 */
export async function withReadQuery<T>(
  c: Context | null,
  table: string,
  callback: () => Promise<T>
): Promise<T> {
  // Create query context
  const queryContext = {
    table,
    operation: 'select' as const,
    query: 'Read query',
    startTime: Date.now()
  };

  // Execute beforeExecute hooks
  const hookContext = await executeDbHooks('beforeExecute', c, queryContext);
  
  // If there was an error in beforeExecute, we should abort
  if (hookContext.error) {
    throw hookContext.error;
  }

  try {
    // Execute the query
    const result = await callback();
    
    // Update context with result and end time
    hookContext.result = result;
    hookContext.endTime = Date.now();
    
    // Execute afterExecute hooks
    await executeDbHooks('afterExecute', c, hookContext);
    
    return result;
  } catch (error) {
    // Update context with error and end time
    hookContext.error = error as Error;
    hookContext.endTime = Date.now();
    
    // Execute afterExecute hooks even if there was an error
    await executeDbHooks('afterExecute', c, hookContext);
    
    throw error;
  }
}

/**
 * Execute a write database query with lifecycle hooks
 * @param c - Hono context or null 
 * @param table - Table being modified
 * @param operation - Type of write operation
 * @param callback - Function to execute
 * @returns Result of the query
 */
export async function withWriteQuery<T>(
  c: Context | null,
  table: string,
  operation: 'insert' | 'update' | 'delete',
  callback: () => Promise<T>
): Promise<T> {
  // Create query context
  const queryContext = {
    table,
    operation,
    query: `${operation.toUpperCase()} query`,
    startTime: Date.now()
  };

  // Execute beforeExecute hooks
  const hookContext = await executeDbHooks('beforeExecute', c, queryContext);
  
  // If there was an error in beforeExecute, we should abort
  if (hookContext.error) {
    throw hookContext.error;
  }

  try {
    // Execute the query
    const result = await callback();
    
    // Update context with result and end time
    hookContext.result = result;
    hookContext.endTime = Date.now();
    
    // Execute afterExecute hooks
    await executeDbHooks('afterExecute', c, hookContext);
    
    return result;
  } catch (error) {
    // Update context with error and end time
    hookContext.error = error as Error;
    hookContext.endTime = Date.now();
    
    // Execute afterExecute hooks even if there was an error
    await executeDbHooks('afterExecute', c, hookContext);
    
    throw error;
  }
}
```

## 8: Backend Logging

### `backend\src\logging\constants.ts`

```ts
/**
 * Constants for the logging system
 */

// Log levels in order of severity
export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

// Log level to numeric value for comparison
export const LOG_LEVELS: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3
};

// ANSI color codes for console output
export const COLORS = {
  reset: '\x1b[0m',
  debug: '\x1b[36m', // Cyan
  info: '\x1b[32m',  // Green
  warn: '\x1b[33m',  // Yellow
  error: '\x1b[31m', // Red
  timestamp: '\x1b[90m' // Grey
};
```


### `backend\src\logging\core.ts`

```ts
/**
 * Core Logger implementation
 */
import { Context } from 'hono';
import { LogLevel, LOG_LEVELS, COLORS } from './constants.js';

// Configuration for the logger
export interface LoggerConfig {
  minLevel: LogLevel;
  enableConsole: boolean;
  enableDatabase: boolean;
  serviceId: string;
  formatOptions?: {
    colors: boolean;
    timestamp: boolean;
  };
}

// Import from env to avoid circular dependency
import { env } from '../env.js';

// Default configuration
const defaultConfig: LoggerConfig = {
  minLevel: (env.LOG_LEVEL as LogLevel) || 'info',
  enableConsole: true,
  enableDatabase: true,
  serviceId: env.SERVICE_ID || 'dcr-backend',
  formatOptions: {
    colors: true,
    timestamp: true
  }
};

/**
 * Main logger class for the DCR application
 */
export class Logger {
  private config: LoggerConfig;
  private source: string;

  /**
   * Create a new logger instance
   * @param source - Component or module name for this logger
   * @param config - Optional custom configuration
   */
  constructor(source: string, config?: Partial<LoggerConfig>) {
    this.source = source;
    this.config = { ...defaultConfig, ...config };
  }

  /**
   * Log a debug message
   * @param message - Message to log
   * @param metadata - Optional additional context information
   * @param context - Optional Hono context for request information
   */
  debug(message: string, metadata?: Record<string, unknown>, context?: Context): void {
    this.log('debug', message, metadata, context);
  }

  /**
   * Log an info message
   * @param message - Message to log
   * @param metadata - Optional additional context information
   * @param context - Optional Hono context for request information
   */
  info(message: string, metadata?: Record<string, unknown>, context?: Context): void {
    this.log('info', message, metadata, context);
  }

  /**
   * Log a warning message
   * @param message - Message to log
   * @param metadata - Optional additional context information
   * @param context - Optional Hono context for request information
   */
  warn(message: string, metadata?: Record<string, unknown>, context?: Context): void {
    this.log('warn', message, metadata, context);
  }

  /**
   * Log an error message
   * @param message - Message to log
   * @param metadata - Optional additional context information
   * @param context - Optional Hono context for request information
   */
  error(message: string, metadata?: Record<string, unknown>, context?: Context): void {
    this.log('error', message, metadata, context);
  }

  /**
   * Internal method to handle log entries
   * @param level - Log level
   * @param message - Message to log
   * @param metadata - Optional additional context information
   * @param context - Optional Hono context for request information
   */
  private log(level: LogLevel, message: string, metadata?: Record<string, unknown>, context?: Context): void {
    // Check if this log level should be processed
    if (LOG_LEVELS[level] < LOG_LEVELS[this.config.minLevel]) {
      return;
    }

    const timestamp = new Date();
    const entry = {
      level,
      message,
      source: this.source,
      timestamp,
      metadata
    };

    // Log to console if enabled
    if (this.config.enableConsole) {
      this.logToConsole(entry);
    }

    // Log to database if enabled
    if (this.config.enableDatabase) {
      // Handle database logging asynchronously to avoid circular dependencies
      // Using a separate function allows TypeScript to better handle the dynamic import
      this.logToDatabase(entry).catch(error => {
        console.error('Database logging failed:', error);
      });
    }
  }

  /**
   * Send log entry to database asynchronously
   * @param entry - Log entry to send to database
   * @returns Promise that resolves when the log is written or rejects on error
   */
  private async logToDatabase(entry: { level: LogLevel; message: string; source: string; timestamp: Date; metadata?: Record<string, unknown> }): Promise<void> {
    try {
      // Dynamically import the database module to avoid circular dependencies
      const { logToDB } = await import('./database.js');
      await logToDB({
        message: entry.message,
        source: entry.source,
        level: entry.level,
        timestamp: entry.timestamp,
        metadata: entry.metadata
      });
    } catch (error: unknown) {
      // Convert to Error type or string for consistent error handling
      throw error instanceof Error ? error : new Error(String(error));
    }
  }
  
  /**
   * Format and output log entry to console
   * @param entry - Log entry to output
   */
  private logToConsole(entry: { level: LogLevel; message: string; source: string; timestamp: Date; metadata?: Record<string, unknown> }): void {
    const { level, message, source, timestamp, metadata } = entry;
    const { colors, timestamp: showTimestamp } = this.config.formatOptions || {};

    // Format the log message
    let formattedMessage = '';

    // Add timestamp if enabled
    if (showTimestamp) {
      const timeStr = timestamp.toISOString();
      formattedMessage += colors ? `${COLORS.timestamp}${timeStr}${COLORS.reset} ` : `${timeStr} `;
    }

    // Add log level with appropriate color
    const levelUpper = level.toUpperCase();
    formattedMessage += colors
      ? `${COLORS[level]}[${levelUpper}]${COLORS.reset}`
      : `[${levelUpper}]`;

    // Add source
    formattedMessage += ` [${source}]`;

    // Add message
    formattedMessage += ` ${message}`;

    // Output to console
    console[level](formattedMessage);

    // Output metadata as a separate JSON line if present
    if (metadata && Object.keys(metadata).length > 0) {
      console[level](
        colors ? `${COLORS[level]}[${levelUpper}] Metadata:${COLORS.reset}` : `[${levelUpper}] Metadata:`,
        metadata
      );
    }
  }
}

/**
 * Create a new logger for a specific component
 * @param source - Component or module name for the logger
 * @param config - Optional custom configuration
 * @returns A configured logger instance
 */
export function createLogger(source: string, config?: Partial<LoggerConfig>): Logger {
  return new Logger(source, config);
}

// Create a system-wide logger for application-level messages
export const systemLogger = createLogger('system');

// Create pre-configured loggers for common components
export const apiLogger = createLogger('api');
export const dbLogger = createLogger('database');
export const authLogger = createLogger('auth');
```


### `backend\src\logging\database.ts`

```ts
/**
 * Database logging functionality
 */
import { db } from '../db/index.js';
import { logs } from '../db/schema.js';
import { LogPhase } from './types.js';
import { eq, lt, sql } from 'drizzle-orm';

/**
 * Map from LogPhase enum to database schema phase strings
 */
function mapPhaseToDbPhase(phase: string | undefined): 'beforeRequest' | 'request' | 'afterRequest' | 'beforeExecute' | 'execute' | 'afterExecute' | null {
  if (!phase) return null;
  
  // Convert enum value to database-compatible string
  switch (phase) {
    case LogPhase.BEFORE_REQUEST:
      return 'beforeRequest';
    case LogPhase.REQUEST:
      return 'request';
    case LogPhase.AFTER_REQUEST:
      return 'afterRequest';
    case LogPhase.RESPONSE:
      // Map response to afterRequest as it's closest in the schema
      return 'afterRequest';
    case LogPhase.BEFORE_EXECUTE:
      return 'beforeExecute';
    case LogPhase.EXECUTE:
      return 'execute';
    case LogPhase.AFTER_EXECUTE:
      return 'afterExecute';
    default:
      // For other values, check if they match a DB value directly
      if (['beforeRequest', 'request', 'afterRequest', 'beforeExecute', 'execute', 'afterExecute'].includes(phase)) {
        return phase as any;
      }
      return null;
  }
}

/**
 * Write a log entry to the database
 * @param options - Log entry options
 * @returns Promise resolving when the log is written
 */
export async function logToDB(options: {
  message: string;
  source: string;
  level: string;
  timestamp?: Date;
  metadata?: Record<string, unknown>;
  phase?: string;
  type?: string;
  endpointId?: number;
}) {
  try {
    // Convert the LogPhase enum value to a database-compatible string
    const dbPhase = mapPhaseToDbPhase(options.phase);
    
    // Success default to true unless specified in metadata
    const success = options.metadata?.success !== undefined 
      ? Boolean(options.metadata.success) 
      : true;
    
    // Store log source, level, and type in the metadata for future reference
    const enhancedMetadata = {
      ...options.metadata || {},
      _source: options.source,
      _level: options.level,
      _type: options.type
    };
    
    await db.insert(logs).values({
      message: options.message,
      phase: dbPhase || 'request', // Default to 'request' if no valid phase
      success: success,
      endpointId: options.endpointId || null,
      metadataJson: JSON.stringify(enhancedMetadata),
      // timestamp is handled by the database default if not specified
      ...(options.timestamp && { timestamp: options.timestamp.toISOString() })
    });
  } catch (error) {
    console.error('❌ Failed to write log to database:', error);
    // Depending on requirements, you might want to re-throw or handle this error differently
    // For now, logging to console to prevent application crash if DB logging fails.
  }
}

/**
 * Find logs older than a specified date
 * @param options - Query options
 * @returns Array of old log entries
 */
export async function findOldLogs(options: {
  olderThan: Date;
  limit?: number;
}) {
  const { olderThan, limit = 1000 } = options;
  
  try {
    // Use proper SQL comparison for timestamps in string format
    const oldLogs = await db.select()
      .from(logs)
      .where(sql`${logs.timestamp} < ${olderThan.toISOString()}`)
      .limit(limit);
    
    // Map the database records to a more usable format
    return oldLogs.map(log => {
      // Extract the source, level, and type from metadata if available
      let metadata = null;
      let source = 'system';
      let level = 'info';
      let type = null;
      
      if (log.metadataJson) {
        try {
          metadata = JSON.parse(log.metadataJson);
          source = metadata._source || source;
          level = metadata._level || level;
          type = metadata._type || type;
          
          // Remove our internal fields from the returned metadata
          if (metadata._source) delete metadata._source;
          if (metadata._level) delete metadata._level;
          if (metadata._type) delete metadata._type;
        } catch (e) {
          console.error('Error parsing log metadata:', e);
        }
      }
      
      return {
        id: log.id,
        message: log.message,
        timestamp: log.timestamp,
        phase: log.phase,
        success: log.success,
        endpointId: log.endpointId,
        metadata,
        source,
        level,
        type
      };
    });
  } catch (error) {
    console.error('Error finding old logs:', error);
    return [];
  }
}
```


### `backend\src\logging\drivers\base-driver.ts`

```ts
/**
 * Base implementation for all log drivers
 */
import { LogDriver, LogDriverConfig, LogEntry } from '../types.js';

export abstract class BaseLogDriver implements LogDriver {
  protected config: LogDriverConfig;
  protected initialized = false;

  constructor(config: LogDriverConfig = {}) {
    this.config = config;
  }

  /**
   * Write a log entry to the destination
   * @param entry The log entry to write
   */
  abstract write(entry: LogEntry): Promise<void>;

  /**
   * Initialize the driver
   */
  async initialize(): Promise<void> {
    // Base implementation just marks as initialized
    // Specific drivers should override and call super.initialize()
    this.initialized = true;
  }

  /**
   * Shutdown the driver, closing connections etc.
   */
  async shutdown(): Promise<void> {
    // Base implementation just marks as not initialized
    // Specific drivers should override and call super.shutdown()
    this.initialized = false;
  }

  /**
   * Archive logs older than specified days
   * @param olderThanDays Archive logs older than this many days
   * @returns Array of archived log identifiers
   */
  async archiveLogs(olderThanDays: number): Promise<string[]> {
    // Base implementation does nothing
    // Specific drivers should override this
    return [];
  }

  /**
   * Check if the driver is initialized
   */
  isInitialized(): boolean {
    return this.initialized;
  }

  /**
   * Format a log entry as a string
   * @param entry The log entry to format
   * @returns Formatted log string
   */
  protected formatLogEntry(entry: LogEntry): string {
    const { timestamp, level, source, message, metadata, type, phase } = entry;
    
    // Create a basic formatted string
    let formattedLog = `[${timestamp.toISOString()}] [${level.toUpperCase()}]`;
    
    if (type) {
      formattedLog += ` [${type}]`;
    }
    
    if (phase) {
      formattedLog += ` [${phase}]`;
    }
    
    formattedLog += ` [${source}] ${message}`;
    
    if (metadata) {
      formattedLog += ` ${JSON.stringify(metadata)}`;
    }
    
    return formattedLog;
  }
}
```


### `backend\src\logging\drivers\file-driver.ts`

```ts
/**
 * File-based log driver implementation
 */
import { BaseLogDriver } from './base-driver.js';
import { LogDriverConfig, LogEntry, LogType } from '../types.js';
import { mkdir, writeFile, readdir, readFile, stat, unlink } from 'fs/promises';
import { join, dirname } from 'path';
import { exists } from '../../utils/fs.js';

export class FileLogDriver extends BaseLogDriver {
  private basePath: string;
  private maxSizeMB: number;
  private maxFiles: number;
  private currentLogFile: string | null = null;
  private currentLogSize = 0;

  constructor(config: LogDriverConfig = {}) {
    super(config);
    this.basePath = config.basePath || './logs';
    this.maxSizeMB = config.maxSizeMB || 10; // Default 10MB
    this.maxFiles = config.maxFiles || 7; // Default 7 files (1 week with daily rotation)
  }

  /**
   * Initialize the file driver
   * Creates log directory if it doesn't exist
   */
  async initialize(): Promise<void> {
    // Create base directory if it doesn't exist
    await mkdir(this.basePath, { recursive: true });
    
    // Determine current log file
    this.currentLogFile = this.generateLogFileName();
    
    // Check if current log file exists and get its size
    if (await exists(this.currentLogFile)) {
      const stats = await stat(this.currentLogFile);
      this.currentLogSize = stats.size;
    }
    
    // Clean up old log files if we exceed maxFiles
    await this.cleanupOldLogs();
    
    await super.initialize();
  }

  /**
   * Write a log entry to a file
   * @param entry The log entry to write
   */
  async write(entry: LogEntry): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }

    const formattedLog = this.formatLogEntry(entry) + '\n';
    
    // Check if we need to rotate the log file
    const logSizeInMB = this.currentLogSize / (1024 * 1024);
    if (logSizeInMB >= this.maxSizeMB) {
      // Rotate the log file
      this.currentLogFile = this.generateLogFileName();
      this.currentLogSize = 0;
      await this.cleanupOldLogs();
    }

    // Append to the current log file
    if (this.currentLogFile) {
      await writeFile(this.currentLogFile, formattedLog, { flag: 'a' });
      this.currentLogSize += Buffer.byteLength(formattedLog);
    }
  }

  /**
   * Generate a log filename based on current date
   * @returns Path to the log file
   */
  private generateLogFileName(): string {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const dateStr = `${year}-${month}-${day}`;
    
    // Include log type in filename if specified in config
    const typeSegment = this.config.options?.logType 
      ? `-${this.config.options.logType}` 
      : '';
    
    return join(this.basePath, `dcr${typeSegment}-${dateStr}.log`);
  }

  /**
   * Clean up old log files if we exceed maxFiles
   */
  private async cleanupOldLogs(): Promise<void> {
    try {
      // Get all log files in the directory
      const files = await readdir(this.basePath);
      const logFiles = files.filter(file => file.endsWith('.log'));
      
      // Sort by modification time (oldest first)
      const fileStats = await Promise.all(
        logFiles.map(async file => {
          const filePath = join(this.basePath, file);
          const fileStat = await stat(filePath);
          return { file: filePath, mtime: fileStat.mtime };
        })
      );
      
      fileStats.sort((a, b) => a.mtime.getTime() - b.mtime.getTime());
      
      // Delete oldest files if we have more than maxFiles
      const filesToDelete = fileStats.slice(0, Math.max(0, fileStats.length - this.maxFiles));
      await Promise.all(filesToDelete.map(file => unlink(file.file)));
    } catch (error) {
      console.error('Error cleaning up old log files:', error);
    }
  }

  /**
   * Archive logs older than specified days
   * @param olderThanDays Archive logs older than this many days
   * @returns Array of archived log file paths
   */
  async archiveLogs(olderThanDays: number): Promise<string[]> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);
    
    try {
      // Get all log files in the directory
      const files = await readdir(this.basePath);
      const logFiles = files.filter(file => file.endsWith('.log'));
      
      // Find files older than cutoff date
      const oldFiles: string[] = [];
      
      for (const file of logFiles) {
        const filePath = join(this.basePath, file);
        const fileStat = await stat(filePath);
        
        if (fileStat.mtime < cutoffDate) {
          oldFiles.push(filePath);
        }
      }
      
      return oldFiles;
    } catch (error) {
      console.error('Error finding old log files:', error);
      return [];
    }
  }
}
```


### `backend\src\logging\drivers\sqlite-driver.ts`

```ts
/**
 * SQLite log driver implementation
 */
import { BaseLogDriver } from './base-driver.js';
import { LogDriver, LogEntry, LogDriverConfig, LogPhase, LogLevel } from '../types.js';
import { db } from '../../db/index.js';
import * as schema from '../../db/schema.js';
import { withReadQuery, withTransaction, withWriteQuery } from '../../db/transactions.js';
import { eq, lt, sql } from 'drizzle-orm';
import { dirname } from 'path';
import { mkdir } from 'fs/promises';

export class SQLiteLogDriver extends BaseLogDriver {
  constructor(config: LogDriverConfig = {}) {
    super(config);
  }
  
  /**
   * Initialize the SQLite driver
   * Makes sure the database directory exists
   */
  async initialize(): Promise<void> {
    // If we have a custom connection string, we would connect to it here
    // For now, we use the main application database
    
    // If a custom db path is specified, ensure its directory exists
    if (this.config.connectionString?.startsWith('sqlite:///')) {
      const dbPath = this.config.connectionString.replace('sqlite:///', '');
      const dbDir = dirname(dbPath);
      await mkdir(dbDir, { recursive: true });
    }
    
    await super.initialize();
  }
  
  /**
   * Write a log entry to the SQLite database
   * @param entry The log entry to write
   */
  async write(entry: LogEntry): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    // Map the log entry to our logs table structure
    // For now, we'll map application/general logs to phase-specific logs
    // In a future implementation, we might create a separate table
    const { message, timestamp, source, metadata, phase, level } = entry;
    
    // Default phase to a level-based value if not provided
    // Get appropriate phase, then map it to a database-compatible value
    const initialPhase = phase || this.mapLevelToPhase(entry.level);
    const dbCompatiblePhase = this.mapPhaseToDbPhase(initialPhase);
    
    await withWriteQuery(null, 'logs', 'insert', async () => {
      await db.insert(schema.logs).values({
        message: message.substring(0, 1000), // Limit message length
        timestamp: timestamp.toISOString(),
        // Use a type assertion to handle the phase enum restriction
        phase: dbCompatiblePhase as 'beforeRequest' | 'request' | 'afterRequest' | 'beforeExecute' | 'execute' | 'afterExecute',
        success: true, // Default to success for general logs
        metadataJson: metadata ? JSON.stringify(metadata) : null,
      });
    });
  }
  
  /**
   * Map log level to a phase for database storage
   * @param level LogLevel
   * @returns string representing a phase
   */
  private mapLevelToPhase(level: LogLevel): string {
    switch (level) {
      case LogLevel.DEBUG:
        return 'beforeRequest'; // Use as a placeholder for debug
      case LogLevel.INFO:
        return 'request'; // Use as a placeholder for info
      case LogLevel.WARN:
        return 'afterRequest'; // Use as a placeholder for warn
      case LogLevel.ERROR:
      case LogLevel.FATAL:
        return 'execute'; // Use as a placeholder for errors
      default:
        return 'request';
    }
  }

  /**
   * Map LogPhase enum to a database-compatible phase string
   * @param phase LogPhase enum value
   * @returns Database-compatible phase string
   */
  private mapPhaseToDbPhase(phase: LogPhase | string): string {
    // Direct mapping for phases that already match the database schema
    if (['beforeRequest', 'request', 'afterRequest', 'beforeExecute', 'execute', 'afterExecute'].includes(phase)) {
      return phase;
    }
    
    // Map other phases to their closest equivalents
    switch (phase) {
      case LogPhase.INIT:
      case LogPhase.CONFIGURE:
      case LogPhase.EXPORT:
        return 'beforeExecute'; // System initialization activities
      
      case LogPhase.WEBHOOK:
        return 'afterRequest'; // Webhook is a post-request activity
      
      case LogPhase.ARCHIVE:
        return 'afterExecute'; // Archiving is a post-execution activity
      
      case LogPhase.SHUTDOWN:
        return 'afterExecute'; // Shutdown is a concluding activity
      
      default:
        return 'request'; // Default fallback
    }
  }
  
  /**
   * Archive logs older than specified days
   * @param olderThanDays Archive logs older than this many days
   * @returns Array of archived log record IDs
   */
  async archiveLogs(olderThanDays: number): Promise<string[]> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);
    const cutoffDateStr = cutoffDate.toISOString();
    
    // Use a query to find logs older than the cutoff date
    const oldLogs = await withReadQuery(null, 'logs', async () => {
      return await db.select().from(schema.logs)
        .where(lt(schema.logs.timestamp, cutoffDateStr));
    });
    
    // Type assertion for oldLogs and add type for log parameter
    return (oldLogs as { id: number }[]).map((log: { id: number }) => log.id.toString());
  }
}
```


### `backend\src\logging\index.ts`

```ts
/**
 * Main logging system entry point
 * Re-exports all logging functionality from modular files
 */

// Re-export core types and constants
export { LogLevel, LOG_LEVELS, COLORS } from './constants.js';
export { LogType, LogPhase, LogPhaseEnum, LogEntry, LogDriverConfig, LogDriver } from './types.js';

// Re-export core logger implementation
export { Logger, createLogger, systemLogger } from './core.js';

// Re-export middleware
export { loggerMiddleware, LoggerMiddlewareOptions } from './middleware.js';

// Re-export database functionality
export { logToDB, findOldLogs } from './database.js';

// Re-export lifecycle management
export { initializeLogging, shutdownLogging } from './lifecycle.js';

// Re-export manager
export { LogManager } from './manager.js';

// Re-export drivers
export { SQLiteLogDriver } from './drivers/sqlite-driver.js';
export { FileLogDriver } from './drivers/file-driver.js';

// Export common pre-configured loggers
export { apiLogger, dbLogger, authLogger } from './core.js';
```


### `backend\src\logging\lifecycle.ts`

```ts
/**
 * Logging system lifecycle management
 */
import { LogManager } from './manager.js';
import { systemLogger } from './core.js';
import { config } from '../config.js';
import { env } from '../env.js';
import fs from 'node:fs/promises';
import path from 'node:path';

/**
 * Initialize the logging system
 * Sets up all configured log drivers based on environment configuration
 */
export async function initializeLogging(): Promise<void> {
  try {
    systemLogger.info('Initializing logging system', {
      logLevel: config.logLevel,
      logDrivers: config.logDrivers
    });

    // Get a reference to the LogManager singleton
    const logManager = LogManager.getInstance();
    
    // Ensure log directories exist
    if (config.logDrivers.includes('file')) {
      const logDir = path.resolve(process.cwd(), config.logPath || 'logs');
      systemLogger.info(`Ensuring log directory exists: ${logDir}`);
      
      try {
        await fs.mkdir(logDir, { recursive: true });
      } catch (err) {
        systemLogger.error(`Failed to create log directory: ${logDir}`, { error: err });
        throw err;
      }
    }

    // Initialize each enabled driver
    for (const driverType of config.logDrivers) {
      try {
        systemLogger.info(`Initializing log driver: ${driverType}`);
        
        switch (driverType) {
          case 'sqlite':
            const { SqliteLogDriver } = await import('./drivers/sqlite-driver.js');
            logManager.registerDriver(new SqliteLogDriver());
            break;
          
          case 'file':
            const { FileLogDriver } = await import('./drivers/file-driver.js');
            logManager.registerDriver(new FileLogDriver({
              logPath: config.logPath || 'logs',
              logLevel: config.logLevel || 'info'
            }));
            break;
          
          // Additional drivers can be added here
          default:
            systemLogger.warn(`Unknown log driver type: ${driverType}`);
            break;
        }
      } catch (err) {
        systemLogger.error(`Failed to initialize log driver: ${driverType}`, { error: err });
        // Continue with other drivers if one fails
      }
    }
    
    systemLogger.info('Logging system initialization complete', {
      activeDrivers: logManager.getDriverCount()
    });
  } catch (error) {
    systemLogger.error('Failed to initialize logging system', { error });
    throw error;
  }
}

/**
 * Shut down the logging system gracefully
 * Closes all log drivers and performs any necessary cleanup
 */
export async function shutdownLogging(): Promise<void> {
  try {
    systemLogger.info('Shutting down logging system');
    
    // Get a reference to the LogManager singleton
    const logManager = LogManager.getInstance();
    
    // Close all drivers
    await logManager.closeAll();
    
    systemLogger.info('Logging system successfully shut down');
  } catch (error) {
    console.error('Error shutting down logging system:', error);
    throw error;
  }
}
```


### `backend\src\logging\manager.ts`

```ts
/**
 * Logging system manager
 * Handles driver initialization, routing log entries to the right driver,
 * and coordinating log archiving
 */
import { LogDriver, LogDriverConfig, LogEntry, LogLevel, LogType, LoggingConfig, LogStorageDriver, LogStorageZipOption } from './types.js';
import { SQLiteLogDriver } from './drivers/sqlite-driver.js';
import { FileLogDriver } from './drivers/file-driver.js';
import { config } from '../config.js';
import { env } from '../env.js';
import { join } from 'path';
import { mkdir, writeFile } from 'fs/promises';
import { createReadStream, createWriteStream } from 'fs';
import { createGzip } from 'zlib';
import { pipeline } from 'stream/promises';

export class LogManager {
  private static instance: LogManager;
  private drivers: Map<string, LogDriver> = new Map();
  private typeToDriverMap: Map<string, string> = new Map();
  private defaultDriverName: string = 'sqlite';
  private defaultLogLevel: LogLevel = LogLevel.INFO;
  private initialized = false;
  private config: LoggingConfig;

  private constructor() {
    // Default minimal config - will be overridden in initialize()
    this.config = {
      defaultDriver: 'sqlite',
      logTypes: {
        [LogType.APPLICATION]: { driver: 'sqlite', level: LogLevel.INFO },
      },
      drivers: {
        sqlite: {},
      }
    };
  }

  /**
   * Get the singleton instance
   */
  public static getInstance(): LogManager {
    if (!LogManager.instance) {
      LogManager.instance = new LogManager();
    }
    return LogManager.instance;
  }

  /**
   * Initialize the log manager with configuration
   * @param config Optional config override (otherwise uses orchestrator config)
   */
  public async initialize(configOverride?: LoggingConfig): Promise<void> {
    if (this.initialized) {
      return;
    }

    // Use provided config or try to load from orchestrator config
    try {
      if (configOverride) {
        this.config = configOverride;
      } else if (config?.logging) {
        this.config = config.logging as LoggingConfig;
      }

      // Set defaults from config
      this.defaultDriverName = this.config.defaultDriver || 'sqlite';
      
      // Set up driver for each log type
      for (const [type, typeConfig] of Object.entries(this.config.logTypes)) {
        this.typeToDriverMap.set(type, typeConfig.driver);
      }

      // Initialize each configured driver
      for (const [driverName, driverConfig] of Object.entries(this.config.drivers)) {
        await this.initializeDriver(driverName, driverConfig);
      }

      this.initialized = true;
    } catch (error) {
      console.error('Error initializing LogManager:', error);
      // Fallback to a basic SQLite driver if initialization fails
      if (!this.drivers.has('sqlite')) {
        await this.initializeDriver('sqlite', {});
      }
      this.defaultDriverName = 'sqlite';
      this.initialized = true;
    }
  }

  /**
   * Initialize a specific driver
   * @param driverName Name of the driver
   * @param config Driver configuration
   */
  private async initializeDriver(driverName: string, config: LogDriverConfig): Promise<void> {
    let driver: LogDriver;

    switch (driverName) {
      case 'sqlite':
        driver = new SQLiteLogDriver(config);
        break;
      case 'file':
        driver = new FileLogDriver(config);
        break;
      // Add cases for MySQL and PostgreSQL drivers when implemented
      default:
        console.warn(`Unknown driver type: ${driverName}, falling back to SQLite`);
        driver = new SQLiteLogDriver(config);
    }

    await driver.initialize();
    this.drivers.set(driverName, driver);
  }

  /**
   * Log a message with the appropriate driver based on log type
   * @param entry Log entry to write
   */
  public async log(entry: LogEntry): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }

    const logType = entry.type || LogType.APPLICATION;
    const driverName = this.typeToDriverMap.get(logType.toString()) || this.defaultDriverName;
    const driver = this.drivers.get(driverName);

    if (driver) {
      await driver.write(entry);
    } else {
      console.error(`No driver found for log type: ${logType}`);
      // Fallback to default driver
      const defaultDriver = this.drivers.get(this.defaultDriverName);
      if (defaultDriver) {
        await defaultDriver.write(entry);
      } else {
        console.error('No default driver available, log message lost:', entry.message);
      }
    }
  }

  /**
   * Archive logs from all drivers that are older than the specified interval
   */
  public async archiveLogs(): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }

    const interval = env.LOG_STORAGE_INTERVAL;
    const storageDriver = env.LOG_STORAGE_DRIVER;
    const zipOption = env.LOG_STORAGE_ZIP_OPTION;

    // Collect logs to archive from all drivers
    const logsToArchive = new Map<string, string[]>();
    
    for (const [driverName, driver] of this.drivers.entries()) {
      const archivedLogs = await driver.archiveLogs(interval);
      if (archivedLogs.length > 0) {
        logsToArchive.set(driverName, archivedLogs);
      }
    }

    if (logsToArchive.size === 0) {
      console.log('No logs found to archive');
      return;
    }

    // Archive based on the configured storage driver
    switch (storageDriver) {
      case 's3':
        await this.archiveToS3(logsToArchive, zipOption);
        break;
      case 'ftp':
        await this.archiveToFTP(logsToArchive, zipOption);
        break;
      case 'archive':
      default:
        await this.archiveToLocalFilesystem(logsToArchive, zipOption);
        break;
    }
  }

  /**
   * Archive logs to S3
   * This is a placeholder implementation - you'll need to add the actual S3 upload code
   */
  private async archiveToS3(
    logsToArchive: Map<string, string[]>, 
    zipOption: string
  ): Promise<void> {
    console.log(`Would archive ${countLogs(logsToArchive)} logs to S3 bucket: ${env.S3_BUCKET_NAME}`);
    console.log('ZIP option:', zipOption);
    console.log('This is a placeholder. Implement S3 upload logic as needed.');
    
    // In a real implementation, you would:
    // 1. Prepare the logs (possibly compress)
    // 2. Use AWS SDK to upload to S3
    // 3. Delete the local copies if appropriate
  }

  /**
   * Archive logs to FTP
   * This is a placeholder implementation - you'll need to add the actual FTP upload code
   */
  private async archiveToFTP(
    logsToArchive: Map<string, string[]>, 
    zipOption: string
  ): Promise<void> {
    console.log(`Would archive ${countLogs(logsToArchive)} logs to FTP: ${env.FTP_HOST}:${env.FTP_PORT}`);
    console.log('ZIP option:', zipOption);
    console.log('This is a placeholder. Implement FTP upload logic as needed.');
    
    // In a real implementation, you would:
    // 1. Prepare the logs (possibly compress)
    // 2. Use an FTP client to upload
    // 3. Delete the local copies if appropriate
  }

  /**
   * Archive logs to local filesystem
   */
  private async archiveToLocalFilesystem(
    logsToArchive: Map<string, string[]>, 
    zipOption: string
  ): Promise<void> {
    const archivePath = env.LOG_STORAGE_ARCHIVE_PATH || './archived_logs';
    
    // Create the archive directory if it doesn't exist
    await mkdir(archivePath, { recursive: true });
    
    // Create a timestamp for this archive run
    const timestamp = new Date().toISOString().replace(/:/g, '-').replace(/\./g, '-');
    
    switch (zipOption) {
      case 'zipPerLog':
        await this.archiveEachLogSeparately(logsToArchive, archivePath, timestamp);
        break;
      case 'zipAllTogether':
        await this.archiveAllLogsTogether(logsToArchive, archivePath, timestamp);
        break;
      case 'none':
      default:
        await this.archiveWithoutCompression(logsToArchive, archivePath, timestamp);
        break;
    }
  }

  /**
   * Archive each log file separately with compression
   */
  private async archiveEachLogSeparately(
    logsToArchive: Map<string, string[]>,
    archivePath: string,
    timestamp: string
  ): Promise<void> {
    // This is a placeholder for file-based log archives
    // For database logs, you'd need to export them to files first
    console.log(`Would archive each log separately to ${archivePath}`);
    
    // In a real implementation:
    // For each log file, you would create a separate .gz file
    // For database logs, export to files and then compress
  }

  /**
   * Archive all logs together with compression
   */
  private async archiveAllLogsTogether(
    logsToArchive: Map<string, string[]>,
    archivePath: string,
    timestamp: string
  ): Promise<void> {
    // This is a placeholder for file-based log archives
    // For database logs, you'd need to export them to files first
    console.log(`Would archive all logs together to ${archivePath}`);
    
    // In a real implementation:
    // Create a single archive containing all logs
    // For database logs, export to files first
  }

  /**
   * Archive logs without compression
   */
  private async archiveWithoutCompression(
    logsToArchive: Map<string, string[]>,
    archivePath: string,
    timestamp: string
  ): Promise<void> {
    // This is a placeholder for file-based log archives
    // For database logs, you'd need to export them to files first
    console.log(`Would archive logs without compression to ${archivePath}`);
    
    // In a real implementation:
    // Copy or move log files to the archive location
    // For database logs, export to files
  }

  /**
   * Shutdown all drivers
   */
  public async shutdown(): Promise<void> {
    for (const driver of this.drivers.values()) {
      await driver.shutdown();
    }
    this.drivers.clear();
    this.initialized = false;
  }
}

/**
 * Helper function to count total logs in the map
 */
function countLogs(logsToArchive: Map<string, string[]>): number {
  let count = 0;
  for (const logs of logsToArchive.values()) {
    count += logs.length;
  }
  return count;
}
```


### `backend\src\logging\middleware.ts`

```ts
/**
 * Hono middleware for request logging
 */
import { Context, MiddlewareHandler } from 'hono';
import { Logger, createLogger } from './core.js';
import { LogPhase } from './types.js';

// Logger for the middleware
const middlewareLogger = createLogger('middleware');

/**
 * Configuration options for the logger middleware
 */
export interface LoggerMiddlewareOptions {
  logRequest?: boolean;
  logResponse?: boolean;
  logHeaders?: boolean;
  logBody?: boolean;
  excludePaths?: string[];
}

/**
 * Create a Hono middleware for automatic request/response logging
 * @param options - Configuration options
 * @returns Hono middleware handler
 */
export function loggerMiddleware(
  options: LoggerMiddlewareOptions = {}
): MiddlewareHandler {
  const {
    logRequest = true,
    logResponse = true,
    logHeaders = false,
    logBody = false,
    excludePaths = []
  } = options;

  return async function loggingMiddleware(c: Context, next: () => Promise<void>) {
    const path = c.req.path;
    const method = c.req.method;

    // Skip excluded paths
    if (excludePaths.some(p => path.startsWith(p))) {
      return next();
    }

    const start = Date.now();
    const requestId = c.req.header('x-request-id') || crypto.randomUUID();

    // Add request ID to context for other middleware
    c.set('requestId', requestId);

    // Log request
    if (logRequest) {
      const metadata: Record<string, unknown> = {
        requestId,
        method,
        path,
        query: c.req.query(),
      };

      if (logHeaders) {
        const headers: Record<string, string> = {};
        c.req.raw.headers.forEach((value, key) => {
          headers[key] = value;
        });
        metadata.headers = headers;
      }

      if (logBody && ['POST', 'PUT', 'PATCH'].includes(method)) {
        try {
          const contentType = c.req.header('content-type');
          if (contentType && contentType.includes('application/json')) {
            const body = await c.req.json().catch(() => ({}));
            metadata.body = body;
          }
        } catch (e) {
          // Skip body logging if it fails
        }
      }

      middlewareLogger.info(`${method} ${path}`, metadata, c);
    }

    try {
      // Process request
      await next();

      // Log response
      if (logResponse) {
        const duration = Date.now() - start;
        const status = c.res.status || 200;

        const metadata: Record<string, unknown> = {
          requestId,
          method,
          path,
          status,
          duration: `${duration}ms`,
        };

        if (status >= 500) {
          middlewareLogger.error(
            `${method} ${path} - ${status} in ${duration}ms`,
            metadata,
            c
          );
        } else if (status >= 400) {
          middlewareLogger.warn(
            `${method} ${path} - ${status} in ${duration}ms`,
            metadata,
            c
          );
        } else {
          middlewareLogger.info(
            `${method} ${path} - ${status} in ${duration}ms`,
            metadata,
            c
          );
        }
      }
    } catch (error) {
      // Log errors
      const duration = Date.now() - start;
      middlewareLogger.error(
        `${method} ${path} - Error after ${duration}ms`,
        {
          requestId,
          error: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined,
        },
        c
      );
      throw error;
    }
  };
}
```


### `backend\src\logging\types.ts`

```ts
/**
 * Logging system types and interfaces
 */

// Types of logs in the system
export enum LogType {
  APPLICATION = 'application',
  SECURITY = 'security',
  REQUEST_LIFECYCLE = 'request_lifecycle',
  DATABASE_QUERY = 'database_query',
  EXTERNAL_API_CALL = 'external_api_call',
}

// Log levels - standard severity levels
export enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error',
  FATAL = 'fatal',
}

// Existing LogPhase enum from previous implementation
export enum LogPhase {
  INIT = 'init',
  CONFIGURE = 'configure',
  BEFORE_REQUEST = 'beforeRequest',
  REQUEST = 'request',
  AFTER_REQUEST = 'afterRequest',
  RESPONSE = 'response',
  BEFORE_EXECUTE = 'beforeExecute',
  EXECUTE = 'execute',
  AFTER_EXECUTE = 'afterExecute',
  WEBHOOK = 'webhook',
  EXPORT = 'export',
  ARCHIVE = 'archive',
  SHUTDOWN = 'shutdown',
}

// Re-export LogPhase as LogPhaseEnum for backwards compatibility
export const LogPhaseEnum = LogPhase;

// Core log entry structure
export interface LogEntry {
  message: string;
  timestamp: Date;
  source: string;
  metadata?: Record<string, unknown> | string;
  type?: LogType;
  level?: LogLevel;
  phase?: LogPhase | string;
}

// Configuration for a log driver
export interface LogDriverConfig {
  // Connection string or path for the driver
  connectionString?: string;
  
  // For file drivers - path configuration
  basePath?: string;
  maxSizeMB?: number;
  maxFiles?: number;
  
  // Driver-specific additional config
  options?: Record<string, unknown>;
}

// Storage options for log archiving
export enum LogStorageDriver {
  S3 = 's3',
  FTP = 'ftp',
  ARCHIVE = 'archive',
}

export enum LogStorageZipOption {
  ZIP_PER_LOG = 'zipPerLog',
  ZIP_ALL_TOGETHER = 'zipAllTogether',
  NONE = 'none',
}

// Configuration for the main logging system
export interface LoggingConfig {
  // Default driver to use if not specified for a log type
  defaultDriver: string;
  
  // Configuration for each log type
  logTypes: Record<string, {
    driver: string;
    level: LogLevel;
  }>;
  
  // Configuration for each driver
  drivers: Record<string, LogDriverConfig>;
  
  // Archival configuration
  archival?: {
    driver: LogStorageDriver;
    interval: number; // in days
    zipOption: LogStorageZipOption;
    // Driver-specific config will come from env variables
  };
}

// Interface that all log drivers must implement
export interface LogDriver {
  // Write a log entry to the driver's destination
  write(entry: LogEntry): Promise<void>;
  
  // Initialize the driver (create files, connect to DB, etc.)
  initialize(): Promise<void>;
  
  // Close connections, file handles, etc.
  shutdown(): Promise<void>;
  
  // Archive logs older than specified days
  archiveLogs(olderThanDays: number): Promise<string[]>;
}
```

## 9: Backend Services

### `backend\src\services\api-import.service.ts`

```ts
import * as z from 'zod';

// Define types for Postman Collection v2.1
interface PostmanCollection {
  info: {
    name: string;
    description?: string;
    schema: string; // Should be "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  };
  item: PostmanItem[];
}

interface PostmanItem {
  name: string;
  description?: string;
  request?: PostmanRequest;
  response?: PostmanResponse[];
  item?: PostmanItem[]; // For nested folders
}

interface PostmanRequest {
  method: string;
  url: PostmanUrl;
  header?: PostmanHeader[];
  body?: any;
  description?: string;
}

interface PostmanUrl {
  raw: string;
  protocol?: string;
  host?: string[];
  path?: string[];
  query?: PostmanQueryParam[];
  variable?: PostmanVariable[];
}

interface PostmanHeader {
  key: string;
  value: string;
  disabled?: boolean;
  description?: string;
}

interface PostmanQueryParam {
  key: string;
  value: string;
  disabled?: boolean;
  description?: string;
}

interface PostmanVariable {
  key: string;
  value: string;
  description?: string;
}

interface PostmanResponse {
  name: string;
  code: number;
  status: string;
  _postman_previewlanguage?: string;
  header?: PostmanHeader[];
  body?: any;
}

// Define our parsed format
export interface ParsedEndpoint {
  method: string;
  path: string;
  url: string;
  description?: string;
  headers?: Record<string, string>;
  queryParams?: Record<string, string>;
  body?: any;
  valid: boolean;
  validationMessage?: string;
}

export interface ParsedCollection {
  name: string;
  description?: string;
  baseUrl?: string;
  endpoints: ParsedEndpoint[];
}

/**
 * Parse a Postman collection v2.1 JSON string into our internal format
 */
export async function parsePostmanCollection(collectionData: string): Promise<ParsedCollection> {
  try {
    // Parse the JSON string
    const collection: PostmanCollection = JSON.parse(collectionData);
    
    // Validate schema version
    if (!collection.info?.schema?.includes('v2.1.0')) {
      throw new Error('Only Postman Collection v2.1.0 format is supported');
    }
    
    const parsedCollection: ParsedCollection = {
      name: collection.info.name,
      description: collection.info.description,
      endpoints: [],
    };
    
    // Process all items recursively
    processItems(collection.item, parsedCollection.endpoints);
    
    return parsedCollection;
  } catch (error: any) {
    if (error.message === 'Unexpected end of JSON input' || error.message.includes('JSON')) {
      throw new Error('Invalid JSON format in Postman collection');
    }
    throw error;
  }
}

/**
 * Recursively process Postman items (which can be nested folders)
 */
function processItems(items: PostmanItem[], endpoints: ParsedEndpoint[], parentPath: string = '') {
  for (const item of items) {
    if (item.request) {
      // This is an endpoint
      const endpoint = processEndpoint(item, parentPath);
      endpoints.push(endpoint);
    }
    
    if (item.item && item.item.length > 0) {
      // This is a folder, recurse
      const newParentPath = parentPath ? `${parentPath}/${item.name}` : item.name;
      processItems(item.item, endpoints, newParentPath);
    }
  }
}

/**
 * Process a single Postman endpoint
 */
function processEndpoint(item: PostmanItem, folderPath: string): ParsedEndpoint {
  if (!item.request) {
    return {
      method: 'GET',
      path: '',
      url: '',
      valid: false,
      validationMessage: 'Missing request definition',
    };
  }
  
  const request = item.request;
  const method = request.method?.toUpperCase() || 'GET';
  
  // Process URL
  let path = '';
  let url = '';
  const headers: Record<string, string> = {};
  const queryParams: Record<string, string> = {};
  
  try {
    // Extract path from URL
    if (request.url) {
      url = request.url.raw || '';
      
      // Extract path segments
      if (request.url.path && request.url.path.length > 0) {
        path = '/' + request.url.path.join('/');
      }
      
      // Process query parameters
      if (request.url.query && request.url.query.length > 0) {
        for (const param of request.url.query) {
          if (!param.disabled) {
            queryParams[param.key] = param.value;
          }
        }
      }
    }
    
    // Process headers
    if (request.header && request.header.length > 0) {
      for (const header of request.header) {
        if (!header.disabled) {
          headers[header.key] = header.value;
        }
      }
    }
    
    // Validate the endpoint
    let valid = true;
    let validationMessage = '';
    
    if (!method) {
      valid = false;
      validationMessage = 'Missing HTTP method';
    } else if (!path) {
      valid = false;
      validationMessage = 'Missing path';
    }
    
    return {
      method,
      path,
      url,
      description: item.description || request.description,
      headers,
      queryParams,
      body: request.body,
      valid,
      validationMessage,
    };
  } catch (error: any) {
    return {
      method,
      path: path || '',
      url: url || '',
      valid: false,
      validationMessage: `Error parsing endpoint: ${error.message}`,
    };
  }
}
```


### `backend\src\services\config-file.service.d.ts`

```ts
/**
 * Type declarations for ConfigFileService
 */
export class ConfigFileService {
  /**
   * Calculates a hash for the given content
   */
  calculateHash(content: string): Promise<string>;
  
  /**
   * Saves API configuration to the filesystem
   */
  saveApiConfig(apiSlug: string, config: any): Promise<void>;
  
  /**
   * Saves endpoint configuration to the filesystem
   */
  saveEndpointConfig(
    apiSlug: string, 
    version: string, 
    endpoint: { method: string; path: string }, 
    config: any
  ): Promise<void>;
}
```


### `backend\src\services\config-fs.service.ts`

```ts
import fs from 'node:fs/promises';
import path from 'node:path';
import { getConfigBasePath } from '../config.js';
import { ensureDirectoryExists } from '../utils/fs-utils.js';
import crypto from 'node:crypto';

/**
 * Service for handling configuration file operations
 */
export class ConfigFileService {
  /**
   * Calculate SHA-256 hash for content
   */
  calculateHash(content: string): string {
    return crypto.createHash("sha256").update(content).digest("hex");
  }
  
  /**
   * Ensure API directory structure exists
   */
  async ensureApiDirectoryStructure(apiSlug: string, version: string = 'v1'): Promise<{
    apiDir: string;
    versionDir: string;
  }> {
    const apiDir = path.join(getConfigBasePath(), "apis", apiSlug);
    const versionDir = path.join(apiDir, version);
    
    await ensureDirectoryExists(versionDir);
    
    return { apiDir, versionDir };
  }
  
  /**
   * Save API configuration file
   */
  async saveApiConfig(
    apiSlug: string, 
    config: any
  ): Promise<{ filePath: string; configHash: string }> {
    const apiDir = path.join(getConfigBasePath(), "apis", apiSlug);
    await ensureDirectoryExists(apiDir);
    
    const filePath = path.join(apiDir, "api.json");
    const configStr = JSON.stringify(config, null, 2);
    const configHash = this.calculateHash(configStr);
    
    await fs.writeFile(filePath, configStr);
    
    return { filePath, configHash };
  }
  
  /**
   * Save endpoint configuration file
   */
  async saveEndpointConfig(
    apiSlug: string, 
    version: string,
    endpoint: { method: string; path: string },
    config: any
  ): Promise<{ filePath: string; configHash: string }> {
    const versionDir = path.join(getConfigBasePath(), "apis", apiSlug, version);
    await ensureDirectoryExists(versionDir);
    
    const endpointFileName = `${endpoint.method.toLowerCase()}-${endpoint.path.replace(/[^a-zA-Z0-9]/g, "-")}.json`;
    const filePath = path.join(versionDir, endpointFileName);
    const configStr = JSON.stringify(config, null, 2);
    const configHash = this.calculateHash(configStr);
    
    await fs.writeFile(filePath, configStr);
    
    return { filePath, configHash };
  }
  
  /**
   * Read API configuration file
   */
  async readApiConfig(apiSlug: string): Promise<{ config: any; configHash: string }> {
    const configPath = path.join(getConfigBasePath(), "apis", apiSlug, "api.json");
    try {
      const configStr = await fs.readFile(configPath, "utf-8");
      return {
        config: JSON.parse(configStr),
        configHash: this.calculateHash(configStr)
      };
    } catch (error) {
      throw new Error(`Failed to read API config: ${(error as Error).message}`);
    }
  }
  
  /**
   * Read endpoint configuration file
   */
  async readEndpointConfig(
    apiSlug: string,
    version: string,
    endpoint: { method: string; path: string }
  ): Promise<{ config: any; configHash: string }> {
    const endpointFileName = `${endpoint.method.toLowerCase()}-${endpoint.path.replace(/[^a-zA-Z0-9]/g, "-")}.json`;
    const configPath = path.join(getConfigBasePath(), "apis", apiSlug, version, endpointFileName);
    
    try {
      const configStr = await fs.readFile(configPath, "utf-8");
      return {
        config: JSON.parse(configStr),
        configHash: this.calculateHash(configStr)
      };
    } catch (error) {
      throw new Error(`Failed to read endpoint config: ${(error as Error).message}`);
    }
  }
}

// Export singleton instance
export const configFileService = new ConfigFileService();
```


### `backend\src\services\git.service.ts`

```ts
// Using dynamic import for simple-git to avoid type issues
import type { SimpleGit } from 'simple-git';
import { getConfigBasePath } from '../config.js';
import fs from 'node:fs/promises';
import path from 'node:path';

/**
 * Service for handling Git operations for configuration management
 */
export class GitService {
  private git!: SimpleGit;
  
  constructor() {
    this.initGit();
  }
  
  private async initGit() {
    // Dynamically import simple-git
    const { default: simpleGit } = await import('simple-git');
    
    this.git = simpleGit({
      baseDir: getConfigBasePath(),
      binary: 'git',
      maxConcurrentProcesses: 1,
    });
  }

  /**
   * Initialize Git repository if it doesn't exist
   */
  async ensureGitInitialized(): Promise<void> {
    const isGitInitialized = await this.git.checkIsRepo();
    
    if (!isGitInitialized) {
      await this.git.init();
      
      // Create a .gitignore file to exclude sensitive files
      const gitignorePath = path.join(getConfigBasePath(), ".gitignore");
      await fs.writeFile(gitignorePath, "*.env\n*.key\n*.pem\n");
      
      // Initial commit
      await this.git.add(".gitignore");
      await this.git.commit("Initial commit: Setup configuration repository");
    }
  }

  /**
   * Add and commit changes to the Git repository
   */
  async commitChanges(message: string, pathSpec: string | string[] = '.'): Promise<void> {
    await this.ensureGitInitialized();
    await this.git.add(pathSpec);
    await this.git.commit(message);
  }

  /**
   * Get commit history for a specific path
   */
  async getCommitHistory(apiSlug: string): Promise<Array<{
    hash: string;
    shortHash: string;
    message: string;
    author: string;
    date: string;
  }>> {
    const apiDir = path.join('apis', apiSlug);
    const log = await this.git.log({ file: apiDir });
    
    return log.all.map((commit: {
      hash: string;
      message: string;
      author_email: string;
      date: string;
    }) => ({
      hash: commit.hash,
      shortHash: commit.hash.substring(0, 7),
      message: commit.message,
      author: commit.author_email,
      date: commit.date,
    }));
  }

  /**
   * Get diff for a specific commit
   */
  async getDiff(apiSlug: string, commitHash: string): Promise<string> {
    const apiDir = path.join('apis', apiSlug);
    return await this.git.show([commitHash, '--', apiDir]);
  }
}

// Export singleton instance
export const gitService = new GitService();
```


### `backend\src\services\import-validator.service.ts`

```ts
import { z } from 'zod';
import { parsedCollectionSchema } from '../schemas/api.schema.js';
import { parsePostmanCollection } from './api-import.service.js';
import type { ParsedCollection, ParsedEndpoint } from './api-import.service.js';

/**
 * Service for validating and preparing API imports with endpoint selection support
 */
export class ImportValidatorService {
  /**
   * Validate a Postman collection and prepare it for import
   * Returns the validated collection with endpoint selection metadata
   */
  async validatePostmanCollection(collectionData: string): Promise<{
    validatedCollection: z.infer<typeof parsedCollectionSchema>;
    endpointSelections: Array<{
      id: string;
      method: string;
      path: string;
      description: string | undefined;
      selected: boolean;
    }>;
  }> {
    try {
      // Parse the collection
      const parsedCollection = await parsePostmanCollection(collectionData);
      
      // Validate with Zod schema
      const validatedCollection = parsedCollectionSchema.parse(parsedCollection);
      
      // Generate selection metadata for each endpoint
      const endpointSelections = validatedCollection.endpoints.map((endpoint, index) => ({
        id: `endpoint-${index}`,
        method: endpoint.method,
        path: endpoint.path || '',
        description: endpoint.description || undefined,
        selected: true, // Default to selected
      }));
      
      return {
        validatedCollection,
        endpointSelections,
      };
    } catch (error: any) {
      throw new Error(`Collection validation failed: ${error.message}`);
    }
  }
  
  /**
   * Filter endpoints based on user selection
   */
  filterSelectedEndpoints(
    collection: z.infer<typeof parsedCollectionSchema>,
    selectedEndpointIds: string[],
    endpointSelections: Array<{ id: string; method: string; path: string; selected: boolean }>
  ): z.infer<typeof parsedCollectionSchema> {
    // Map selection IDs to a lookup table
    const selectedMap = new Map<string, boolean>();
    selectedEndpointIds.forEach(id => selectedMap.set(id, true));
    
    // Get the indices of selected endpoints
    const selectedIndices = endpointSelections
      .filter(endpoint => selectedMap.has(endpoint.id))
      .map(endpoint => {
        // Find the index of this endpoint in the original collection
        return endpointSelections.findIndex(e => e.id === endpoint.id);
      })
      .filter(index => index !== -1);
    
    // Filter the endpoints array
    const selectedEndpoints = selectedIndices.map(index => collection.endpoints[index]);
    
    // Return a new collection with only the selected endpoints
    return {
      ...collection,
      endpoints: selectedEndpoints
    };
  }
  
  /**
   * Get collection overview with endpoint count
   */
  getCollectionOverview(collection: z.infer<typeof parsedCollectionSchema>): {
    name: string;
    description: string | undefined;
    endpointCount: number;
    endpoints: Array<{
      method: string;
      path: string;
      description: string | undefined;
    }>;
  } {
    return {
      name: collection.name,
      description: collection.description,
      endpointCount: collection.endpoints.length,
      endpoints: collection.endpoints.map(endpoint => ({
        method: endpoint.method,
        path: endpoint.path,
        description: endpoint.description || undefined,
      }))
    };
  }

  /**
   * Share collection with other users (stub for now)
   */
  async shareCollection(
    collectionId: string, 
    userId: string, 
    targetUserIds: string[]
  ): Promise<boolean> {
    // This would connect to a user/permissions service in a full implementation
    console.log(`Sharing collection ${collectionId} from user ${userId} with users: ${targetUserIds.join(', ')}`);
    return true;
  }
}

// Export singleton instance
export const importValidatorService = new ImportValidatorService();

// Define import schema for frontend
export const importPostmanSchema = z.object({
  collectionData: z.string().min(1),
  name: z.string().min(1),
  description: z.string().optional(),
  version: z.string().default("v1"),
  basePath: z.string().optional(),
  tags: z.array(z.string()).optional(),
  selectedEndpoints: z.array(z.string()).optional(), // IDs of endpoints to import
});
```

## Ungrouped Files

### `backend\config\orchestrator.json`

```json
{
  "logLevel": "debug",
  "defaultRetries": 3,
  "defaultCacheTtl": 300,
  "lifecycle": {
    "beforeRequest": ["auth", "cache", "log"],
    "request": ["fetch"],
    "afterRequest": ["log", "webhook"]
  },
  "db": {
    "lifecycle": {
      "beforeExecute": ["validate"],
      "execute": ["query"],
      "afterExecute": ["log"]
    }
  },
  "webhooks": {
    "defaultTimeoutMs": 5000,
    "retryCount": 3
  },
  "security": {
    "jwtSecret": "CHANGE_THIS_IN_PRODUCTION",
    "jwtExpiresIn": "1d",
    "apiKeys": {
      "enabled": true,
      "headerName": "X-API-Key"
    }
  }
}
```


### `backend\src\api\client.ts`

```ts
import { db } from '../db/index.ts';
import * as schema from '../db/schema.ts';
import { createLogger } from '../logging/index.ts';
import { sendWebhook } from '../webhooks/index.ts';
import { eq, and, gt } from 'drizzle-orm';
import { env } from '../env.ts';
import process from 'node:process';

// Create logger for API client
const logger = createLogger('api:client');

// Type definitions
export interface ApiRequestOptions {
  method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  headers?: Record<string, string>;
  body?: unknown;
  timeout?: number;
  retries?: number;
  useCache?: boolean;
  cacheTtl?: number; // in seconds
  tags?: string[];
}

export interface ApiResponse<T = unknown> {
  success: boolean;
  status: number;
  data: T;
  headers: Record<string, string>;
  cached?: boolean;
  retryCount?: number;
}

export interface ApiError {
  message: string;
  status?: number;
  response?: unknown;
  retryable: boolean;
}

/**
 * Make an API request with caching, retries, and error handling
 */
export async function apiRequest<T = unknown>(
  apiId: number,
  endpoint: string,
  options: ApiRequestOptions = {}
): Promise<ApiResponse<T>> {
  const startTime = Date.now();
  let retryCount = 0;
  let cachedResponse = null;
  const requestId = crypto.randomUUID();
  
  // Set default options
  const requestOptions: Required<ApiRequestOptions> = {
    method: options.method || 'GET',
    headers: options.headers || {},
    body: options.body,
    timeout: options.timeout || 30000, // 30 seconds default
    retries: options.retries ?? 3,
    useCache: options.useCache ?? true,
    cacheTtl: options.cacheTtl || 300, // 5 minutes default
    tags: options.tags || []
  };
  
  try {
    // Get API details
    const api = await db.query.apis.findFirst({
      where: eq(schema.apis.id, apiId)
    });
    
    if (!api) {
      throw new Error(`API with ID ${apiId} not found`);
    }
    
    const url = new URL(endpoint, api.baseUrl).toString();
    logger.debug(`Initiating ${requestOptions.method} request to ${url}`, {
      apiId,
      requestId,
      method: requestOptions.method
    });
    
    // Try to get from cache for GET requests if caching is enabled
    if (requestOptions.useCache && requestOptions.method === 'GET') {
      cachedResponse = await getCachedResponse(url, requestOptions);
      
      if (cachedResponse) {
        logger.debug(`Cache hit for ${url}`, { requestId });
        
        // Send webhook for cache hit
        await sendWebhook('cache.hit', 'api.client', {
          apiId,
          url,
          requestId,
          ttl: cachedResponse.ttl
        }).catch(err => {
          logger.error('Failed to send cache.hit webhook', { error: err });
        });
        
        return {
          success: true,
          status: cachedResponse.status,
          data: cachedResponse.data as T,
          headers: cachedResponse.headers,
          cached: true
        };
      } else {
        logger.debug(`Cache miss for ${url}`, { requestId });
        
        // Send webhook for cache miss
        await sendWebhook('cache.miss', 'api.client', {
          apiId,
          url,
          requestId
        }).catch(err => {
          logger.error('Failed to send cache.miss webhook', { error: err });
        });
      }
    }
    
    // Add authorization header if API has auth configured
    if (api.authType && api.authToken) {
      if (api.authType === 'bearer') {
        requestOptions.headers['Authorization'] = `Bearer ${api.authToken}`;
      } else if (api.authType === 'apikey') {
        const headerName = api.authHeader || 'X-API-Key';
        requestOptions.headers[headerName] = api.authToken;
      }
    }
    
    // Add common headers
    requestOptions.headers['User-Agent'] = `DCR/${env.APP_VERSION || '1.0.0'}`;
    requestOptions.headers['X-Request-ID'] = requestId;
    
    // Convert body to JSON string if it's an object
    let bodyContent: string | undefined;
    if (requestOptions.body && typeof requestOptions.body === 'object') {
      bodyContent = JSON.stringify(requestOptions.body);
      // Set content-type if not already set
      if (!requestOptions.headers['Content-Type']) {
        requestOptions.headers['Content-Type'] = 'application/json';
      }
    }
    
    // Execute request with retry logic
    return await executeWithRetry<T>(
      url,
      {
        method: requestOptions.method,
        headers: requestOptions.headers,
        body: bodyContent,
        signal: AbortSignal.timeout(requestOptions.timeout)
      },
      requestOptions,
      apiId,
      requestId,
      () => { retryCount++; }
    );
  } catch (error) {
    const elapsed = Date.now() - startTime;
    const apiError = normalizeError(error);
    
    logger.error(`API request failed after ${elapsed}ms`, {
      error: apiError.message,
      status: apiError.status,
      retryCount,
      requestId
    });
    
    // Send error webhook
    await sendWebhook('error', 'api.client', {
      requestId,
      apiId,
      error: apiError.message,
      status: apiError.status,
      retryCount,
      elapsed
    }).catch(err => {
      logger.error('Failed to send error webhook', { error: err });
    });
    
    // Return error response
    return {
      success: false,
      status: apiError.status || 500,
      data: { error: apiError.message } as unknown as T,
      headers: {},
      retryCount
    };
  }
}

/**
 * Execute a fetch request with retry logic
 */
async function executeWithRetry<T>(
  url: string,
  fetchOptions: RequestInit,
  requestOptions: Required<ApiRequestOptions>,
  apiId: number,
  requestId: string,
  onRetry: () => void
): Promise<ApiResponse<T>> {
  let lastError: ApiError | null = null;
  const startTime = Date.now();
  
  // Try initial request plus retries
  for (let attempt = 0; attempt <= requestOptions.retries; attempt++) {
    try {
      // If not the first attempt, we're retrying
      if (attempt > 0) {
        onRetry();
        
        const backoffMs = calculateBackoff(attempt);
        logger.info(`Retrying request to ${url} (attempt ${attempt}/${requestOptions.retries}) after ${backoffMs}ms backoff`, {
          requestId,
          attempt
        });
        
        // Wait for backoff period
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        
        // Send webhook for retry
        await sendWebhook('retry', 'api.client', {
          apiId,
          url,
          requestId,
          attempt,
          previousError: lastError?.message
        }).catch(err => {
          logger.error('Failed to send retry webhook', { error: err });
        });
      }
      
      // Make the request
      const response = await fetch(url, fetchOptions);
      const responseHeaders: Record<string, string> = {};
      
      // Convert headers to object
      response.headers.forEach((value, key) => {
        responseHeaders[key] = value;
      });
      
      // Get response data
      let responseData: T;
      const contentType = response.headers.get('Content-Type') || '';
      
      if (contentType.includes('application/json')) {
        responseData = await response.json() as T;
      } else {
        // For non-JSON responses, create a simple object with the text
        const text = await response.text();
        responseData = { content: text } as unknown as T;
      }
      
      const success = response.ok;
      const elapsed = Date.now() - startTime;
      
      // Log response
      if (success) {
        logger.info(`API request to ${url} completed successfully in ${elapsed}ms`, {
          status: response.status,
          requestId,
          retryCount: attempt
        });
      } else {
        logger.warn(`API request to ${url} failed with status ${response.status} in ${elapsed}ms`, {
          status: response.status,
          requestId,
          retryCount: attempt
        });
      }
      
      // Cache successful GET responses if caching is enabled
      if (success && requestOptions.useCache && fetchOptions.method === 'GET') {
        await cacheResponse(
          url, 
          response.status, 
          responseData, 
          responseHeaders, 
          requestOptions.cacheTtl,
          requestOptions.tags
        ).catch(err => {
          logger.error('Failed to cache response', { error: err });
        });
      }
      
      // Send webhook for API response
      await sendWebhook('api.response', 'api.client', {
        apiId,
        url,
        requestId,
        status: response.status,
        success,
        elapsed,
        retryCount: attempt
      }).catch(err => {
        logger.error('Failed to send api.response webhook', { error: err });
      });
      
      // Return response
      return {
        success,
        status: response.status,
        data: responseData,
        headers: responseHeaders,
        retryCount: attempt > 0 ? attempt : undefined
      };
    } catch (error) {
      lastError = normalizeError(error);
      
      // If this is the last attempt or error is not retryable, throw it
      if (attempt === requestOptions.retries || !lastError.retryable) {
        throw error;
      }
    }
  }
  
  // This should never be reached due to the throw in the loop
  throw lastError || new Error('Unknown error occurred');
}

/**
 * Calculate exponential backoff with jitter
 */
function calculateBackoff(attempt: number): number {
  const baseBackoff = 1000; // 1 second
  const maxBackoff = 30000; // 30 seconds
  
  // Exponential backoff: 2^attempt * baseBackoff
  const exponentialBackoff = Math.min(
    maxBackoff,
    Math.pow(2, attempt) * baseBackoff
  );
  
  // Add jitter (0-20% random variation)
  const jitter = exponentialBackoff * 0.2 * Math.random();
  return exponentialBackoff + jitter;
}

/**
 * Normalize various error types to a standard format
 */
function normalizeError(error: unknown): ApiError {
  if (error instanceof TypeError && error.message.includes('fetch')) {
    return {
      message: `Network error: ${error.message}`,
      retryable: true
    };
  }
  
  if (error instanceof DOMException && error.name === 'AbortError') {
    return {
      message: 'Request timed out',
      retryable: true
    };
  }
  
  if (error instanceof Error) {
    return {
      message: error.message,
      retryable: true // Default to retryable
    };
  }
  
  return {
    message: String(error),
    retryable: true
  };
}

/**
 * Get cached response if available and not expired
 */
async function getCachedResponse(
  url: string,
  options: Required<ApiRequestOptions>
): Promise<{
  data: unknown;
  status: number;
  headers: Record<string, string>;
  ttl: number;
} | null> {
  try {
    // Create cache key from URL and relevant headers
    const key = createCacheKey(url, options);
    
    // Check if cache entry exists and is not expired
    const cacheEntry = await db.query.cache.findFirst({
      where: and(
        eq(schema.cache.key, key),
        gt(schema.cache.expiresAt, new Date())
      )
    });
    
    if (!cacheEntry) {
      return null;
    }
    
    // Calculate TTL in seconds
    const ttl = Math.floor(
      (cacheEntry.expiresAt.getTime() - Date.now()) / 1000
    );
    
    // Parse data from cache
    return {
      data: JSON.parse(cacheEntry.value),
      status: cacheEntry.status,
      headers: JSON.parse(cacheEntry.headers || '{}'),
      ttl
    };
  } catch (error) {
    logger.error('Error retrieving from cache', { error, url });
    return null;
  }
}

/**
 * Cache response data
 */
async function cacheResponse(
  url: string,
  status: number,
  data: unknown,
  headers: Record<string, string>,
  ttlSeconds: number,
  tags: string[]
): Promise<void> {
  try {
    // Create cache key
    const key = createCacheKey(url, { headers });
    
    // Calculate expiration
    const expiresAt = new Date(Date.now() + ttlSeconds * 1000);
    
    // Serialize data and headers
    const value = JSON.stringify(data);
    const serializedHeaders = JSON.stringify(headers);
    
    // Upsert cache entry
    await db.insert(schema.cache)
      .values({
        key,
        value,
        status,
        headers: serializedHeaders,
        tags: tags.join(','),
        createdAt: new Date(),
        updatedAt: new Date(),
        expiresAt
      })
      .onConflictDoUpdate({
        target: schema.cache.key,
        set: {
          value,
          status,
          headers: serializedHeaders,
          tags: tags.join(','),
          updatedAt: new Date(),
          expiresAt
        }
      });
  } catch (error) {
    logger.error('Error caching response', { error, url });
    // Non-critical error, don't throw
  }
}

/**
 * Create a cache key from URL and headers
 */
function createCacheKey(url: string, options: { headers?: Record<string, string> }): string {
  // Include only cache-relevant headers
  const relevantHeaders: Record<string, string> = {};
  const cacheRelevantHeaders = [
    'accept',
    'accept-language',
    'cache-control',
    'x-api-version'
  ];
  
  if (options.headers) {
    for (const header of cacheRelevantHeaders) {
      if (options.headers[header]) {
        relevantHeaders[header] = options.headers[header];
      }
    }
  }
  
  // Create a hash of the URL and relevant headers
  const dataToHash = JSON.stringify({
    url,
    headers: relevantHeaders
  });
  
  // Convert to a SHA-256 hash
  const encoder = new TextEncoder();
  const data = encoder.encode(dataToHash);
  const hashBuffer = crypto.subtle.digestSync('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  
  return hashHex;
}

/**
 * Manually invalidate cache entries by tags or URLs
 */
export async function invalidateCache(options: {
  tags?: string[];
  urls?: string[];
}): Promise<number> {
  try {
    const { tags, urls } = options;
    
    if (!tags?.length && !urls?.length) {
      throw new Error('Must provide either tags or urls to invalidate');
    }
    
    let invalidated = 0;
    
    // Invalidate by tags
    if (tags?.length) {
      for (const tag of tags) {
        const likeTag = `%${tag}%`;
        
        const result = await db.delete(schema.cache)
          .where(db.sql`${schema.cache.tags} LIKE ${likeTag}`)
          .returning();
        
        invalidated += result.length;
      }
    }
    
    // Invalidate by URLs
    if (urls?.length) {
      for (const url of urls) {
        const key = createCacheKey(url, {});
        
        const result = await db.delete(schema.cache)
          .where(eq(schema.cache.key, key))
          .returning();
        
        invalidated += result.length;
      }
    }
    
    logger.info(`Invalidated ${invalidated} cache entries`, { 
      tagsCount: tags?.length || 0,
      urlsCount: urls?.length || 0
    });
    
    return invalidated;
  } catch (error) {
    logger.error('Error invalidating cache', { error });
    throw error;
  }
}

/**
 * Schedule a retry for a failed API request
 */
export async function scheduleRetry(
  apiId: number,
  endpoint: string,
  options: ApiRequestOptions,
  error: string,
  retryAfter: Date = new Date(Date.now() + 300000) // Default: retry after 5 minutes
): Promise<void> {
  try {
    await db.insert(schema.retrySchedule)
      .values({
        apiId,
        endpoint,
        options: JSON.stringify(options),
        error,
        retryAfter,
        retryCount: 0,
        maxRetries: 5,
        status: 'pending',
        createdAt: new Date(),
        updatedAt: new Date()
      });
    
    logger.info(`Scheduled retry for API ${apiId} endpoint ${endpoint}`, {
      retryAfter: retryAfter.toISOString()
    });
  } catch (error) {
    logger.error('Failed to schedule retry', { error, apiId, endpoint });
  }
}
```


### `backend\src\config\index.ts`

```ts
import fs from 'node:fs';
import path from 'node:path';
import process from 'node:process';
import { z } from 'zod';

// Type for lifecycle hooks
const LifecycleSchema = z.object({
  beforeRequest: z.array(z.string()).optional(),
  request: z.array(z.string()).optional(),
  afterRequest: z.array(z.string()).optional(),
});

// DB lifecycle hooks
const DbLifecycleSchema = z.object({
  beforeExecute: z.array(z.string()).optional(),
  execute: z.array(z.string()).optional(),
  afterExecute: z.array(z.string()).optional(),
});

// Config schema with Zod
export const ConfigSchema = z.object({
  logLevel: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
  defaultRetries: z.number().int().positive().default(3),
  defaultCacheTtl: z.number().int().positive().default(300),
  lifecycle: LifecycleSchema.default({}),
  db: z.object({
    lifecycle: DbLifecycleSchema.default({}),
  }).default({}),
  webhooks: z.object({
    defaultTimeoutMs: z.number().int().positive().default(5000),
    retryCount: z.number().int().nonnegative().default(3),
  }).default({}),
  security: z.object({
    jwtSecret: z.string().default('CHANGE_THIS_IN_PRODUCTION'),
    jwtExpiresIn: z.string().default('1d'),
    apiKeys: z.object({
      enabled: z.boolean().default(true),
      headerName: z.string().default('X-API-Key'),
    }).default({}),
  }).default({}),
});

// API config schema
export const ApiConfigSchema = z.object({
  name: z.string().optional(),
  baseUrl: z.string().optional(),
  auth: z.object({
    type: z.enum(['none', 'basic', 'bearer', 'oauth2']).default('none'),
    tokenUrl: z.string().optional(),
    clientId: z.string().optional(),
    clientSecret: z.string().optional(),
  }).default({}),
  headers: z.record(z.string()).default({}),
  lifecycle: LifecycleSchema.default({}),
});

// Endpoint config schema
export const EndpointConfigSchema = z.object({
  method: z.string().default('GET'),
  path: z.string(),
  authOverride: z.enum(['none', 'basic', 'bearer', 'oauth2']).optional(),
  cacheTtl: z.number().int().nonnegative().optional(),
  lifecycle: LifecycleSchema.default({}),
  webhooks: z.object({
    onSuccess: z.string().url().optional(),
    onError: z.string().url().optional(),
  }).default({}),
  retry: z.object({
    count: z.number().int().nonnegative().default(3),
    backoff: z.enum(['linear', 'exponential', 'fixed']).default('exponential'),
    initialDelay: z.number().int().positive().default(1000),
  }).default({}),
});

// Export config types
export type Config = z.infer<typeof ConfigSchema>;
export type ApiConfig = z.infer<typeof ApiConfigSchema>;
export type EndpointConfig = z.infer<typeof EndpointConfigSchema>;

// Deep merge utility for configs
export function deepMerge<T extends Record<string, unknown>>(
  target: T, 
  source: Record<string, unknown>
): T {
  const output = { ...target };

  for (const key in source) {
    if (source[key] === undefined || source[key] === null) {
      continue;
    }

    if (
      typeof source[key] === 'object' && 
      !Array.isArray(source[key]) &&
      target[key] && 
      typeof target[key] === 'object'
    ) {
      output[key] = deepMerge(target[key], source[key]);
    } else {
      output[key] = source[key];
    }
  }

  return output;
}

// Load JSON config from file
function loadJsonConfig(filePath: string): Record<string, unknown> {
  try {
    if (fs.existsSync(filePath)) {
      const content = fs.readFileSync(filePath, 'utf-8');
      return JSON.parse(content);
    }
  } catch (error) {
    console.warn(`Failed to load config from ${filePath}:`, error);
  }
  return {};
}

// Load orchestrator config
function loadOrchestratorConfig(): Config {
  const configPath = path.resolve(process.cwd(), 'config', 'orchestrator.json');
  const rawConfig = loadJsonConfig(configPath);
  
  try {
    return ConfigSchema.parse(rawConfig);
  } catch (error) {
    console.error('Invalid orchestrator config:', error);
    return ConfigSchema.parse({});
  }
}

// Load API config
export function loadApiConfig(apiName: string): ApiConfig {
  const configPath = path.resolve(process.cwd(), 'apis', apiName, 'config.json');
  const rawConfig = loadJsonConfig(configPath);

  try {
    return ApiConfigSchema.parse(rawConfig);
  } catch (error) {
    console.error(`Invalid API config for ${apiName}:`, error);
    return ApiConfigSchema.parse({});
  }
}

// Load endpoint config
export function loadEndpointConfig(apiName: string, endpointName: string): EndpointConfig {
  const configPath = path.resolve(process.cwd(), 'apis', apiName, 'endpoints', `${endpointName}.json`);
  const rawConfig = loadJsonConfig(configPath);

  try {
    return EndpointConfigSchema.parse(rawConfig);
  } catch (error) {
    console.error(`Invalid endpoint config for ${apiName}/${endpointName}:`, error);
    return EndpointConfigSchema.parse({ path: '/' });
  }
}

// Merge configs: orchestrator > API > endpoint
export function mergeConfigs(
  baseConfig: Config = loadOrchestratorConfig(),
  apiConfig: Partial<ApiConfig> = {},
  endpointConfig: Partial<EndpointConfig> = {}
): Record<string, unknown> {
  // First merge API config over orchestrator
  const baseWithApi = deepMerge({ ...baseConfig }, apiConfig);
  
  // Then merge endpoint config
  return deepMerge(baseWithApi, endpointConfig);
}

// Export orchestrator config
export const config = loadOrchestratorConfig();
```


### `backend\src\lifecycle\index.ts`

```ts
import { Context } from 'hono';
import { config } from '../config/index';

// Lifecycle hook types
export type LifecycleHookType = 'beforeRequest' | 'request' | 'afterRequest';
export type DbLifecycleHookType = 'beforeExecute' | 'execute' | 'afterExecute';

// Hook context containing data that can be modified by hooks
export interface HookContext {
  request?: Request;
  response?: Response;
  error?: Error;
  data?: Record<string, unknown>;
  metadata?: Record<string, unknown>;
  startTime?: number;
  endTime?: number;
}

// Hook handler function type
export type HookHandler = (
  c: Context,
  hookContext: HookContext
) => Promise<void> | void;

// Registry for lifecycle hooks
const hooks: Record<string, Record<string, HookHandler>> = {
  beforeRequest: {},
  request: {},
  afterRequest: {},
};

// Register a hook for a specific lifecycle stage
export function registerHook(
  type: LifecycleHookType,
  name: string,
  handler: HookHandler
): void {
  if (!hooks[type]) {
    hooks[type] = {};
  }
  
  hooks[type][name] = handler;
}

// Execute hooks for a specific lifecycle stage
export async function executeHooks(
  type: LifecycleHookType,
  c: Context,
  hookContext: HookContext = {}
): Promise<HookContext> {
  const context = { ...hookContext };
  
  // Get the configured hooks for this stage
  const configuredHooks = config.lifecycle[type] || [];
  
  for (const hookName of configuredHooks) {
    const hook = hooks[type][hookName];
    
    if (!hook) {
      console.warn(`Hook ${hookName} for ${type} not found`);
      continue;
    }
    
    try {
      await hook(c, context);
    } catch (error) {
      console.error(`Error executing ${type} hook ${hookName}:`, error);
      context.error = error as Error;
      
      // For beforeRequest hooks, we might want to abort the chain
      if (type === 'beforeRequest') {
        break;
      }
    }
  }
  
  return context;
}

// Middleware to run beforeRequest and afterRequest hooks
export function lifecycleMiddleware() {
  return async (c: Context, next: () => Promise<void>): Promise<void> => {
    const hookContext: HookContext = {
      request: c.req.raw,
      startTime: Date.now(),
      data: {},
      metadata: {},
    };
    
    // Execute beforeRequest hooks
    const beforeContext = await executeHooks('beforeRequest', c, hookContext);
    
    // If there was an error in beforeRequest, we might want to skip the request
    if (beforeContext.error) {
      c.status(500);
      c.header('Content-Type', 'application/json');
      return c.body(JSON.stringify({ error: 'Internal Server Error' }));
    }
    
    // Continue with the request
    await next();
    
    // Set the end time and response
    beforeContext.endTime = Date.now();
    beforeContext.response = c.res;
    
    // Execute afterRequest hooks
    await executeHooks('afterRequest', c, beforeContext);
  };
}

// Helper to run request hooks
export function runRequestHooks(
  c: Context, 
  hookContext: HookContext = {}
): Promise<HookContext> {
  return executeHooks('request', c, hookContext);
}
```


### `backend\src\routes\api.ts`

```ts
import { Hono } from 'hono';
import { Context } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { withReadQuery, withWriteQuery, withTransaction } from '../db/transactions.ts';
import { db } from '../db/index.ts';
import * as schema from '../db/schema.ts';
import { eq } from 'drizzle-orm';
import { createLogger } from '../logging/index.ts';
import { setupWebhookRoutes } from './webhooks.ts';
import { setupApiRoutes } from './apis.ts';

// Create logger for API routes
const logger = createLogger('routes:api');

// Setup API router
const api = new Hono();

// Register sub-routers
api.route('/webhooks', setupWebhookRoutes());
api.route('/apis', setupApiRoutes());

// Root endpoint
api.get('/', (c: Context) => {
  return c.json({ 
    status: 'ok', 
    message: 'Digital Cabinet Relay API',
    version: '1.0.0',
    timestamp: new Date().toISOString() 
  });
});

// Health check endpoint
api.get('/health', async (c: Context) => {
  try {
    // Check database connection
    await db.select({ count: db.fn.count() }).from(schema.users);
    
    return c.json({ 
      success: true, 
      status: 'healthy',
      version: '1.0.0',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Health check failed', { error });
    return c.json({ 
      success: false, 
      status: 'unhealthy',
      error: 'Database connection failed',
      timestamp: new Date().toISOString()
    }, 500);
  }
});

// User endpoints
api.get('/users', async (c: Context) => {
  try {
    const users = await withReadQuery(c, 'list users', async () => {
      return await db.select().from(schema.users);
    });

    logger.info('Retrieved users list', { count: users.length });
    return c.json({ success: true, data: users });
  } catch (error) {
    logger.error('Error fetching users', { error });
    return c.json({ success: false, error: 'Failed to fetch users' }, 500);
  }
});

api.get('/users/:id', async (c: Context) => {
  try {
    const id = Number(c.req.param('id'));
    
    if (isNaN(id)) {
      return c.json({ success: false, error: 'Invalid user ID' }, 400);
    }
    
    const user = await withReadQuery(c, 'get user', async () => {
      return await db.query.users.findFirst({
        where: eq(schema.users.id, id)
      });
    });

    if (!user) {
      return c.json({ success: false, error: 'User not found' }, 404);
    }

    logger.debug('Retrieved user details', { id });
    return c.json({ success: true, data: user });
  } catch (error) {
    logger.error(`Error fetching user ${c.req.param('id')}`, { error });
    return c.json({ success: false, error: 'Failed to fetch user' }, 500);
  }
});

api.post('/users', zValidator('json', z.object({
  name: z.string().min(1).max(100),
  email: z.string().email().max(255),
  role: z.enum(['admin', 'user']).optional().default('user')
})), async (c: Context) => {
  try {
    const data = c.req.valid('json');
    
    const result = await withWriteQuery(c, 'create user', async () => {
      const [user] = await db.insert(schema.users).values({
        name: data.name,
        email: data.email,
        role: data.role,
        createdAt: new Date(),
        updatedAt: new Date()
      }).returning();
      return user;
    });

    logger.info('Created new user', { id: result.id, email: result.email });
    return c.json({ success: true, data: result }, 201);
  } catch (error) {
    logger.error('Error creating user', { error });
    return c.json({ success: false, error: 'Failed to create user' }, 500);
  }
});

api.patch('/users/:id', zValidator('json', z.object({
  name: z.string().min(1).max(100).optional(),
  email: z.string().email().max(255).optional(),
  role: z.enum(['admin', 'user']).optional()
})), async (c: Context) => {
  try {
    const id = Number(c.req.param('id'));
    const data = c.req.valid('json');
    
    if (isNaN(id)) {
      return c.json({ success: false, error: 'Invalid user ID' }, 400);
    }
    
    if (Object.keys(data).length === 0) {
      return c.json({ success: false, error: 'No fields to update' }, 400);
    }

    const result = await withWriteQuery(c, 'update user', async () => {
      const [user] = await db.update(schema.users)
        .set({
          ...(data.name !== undefined && { name: data.name }),
          ...(data.email !== undefined && { email: data.email }),
          ...(data.role !== undefined && { role: data.role }),
          updatedAt: new Date()
        })
        .where(eq(schema.users.id, id))
        .returning();
      return user;
    });

    if (!result) {
      return c.json({ success: false, error: 'User not found' }, 404);
    }

    logger.info('Updated user', { id });
    return c.json({ success: true, data: result });
  } catch (error) {
    logger.error(`Error updating user ${c.req.param('id')}`, { error });
    return c.json({ success: false, error: 'Failed to update user' }, 500);
  }
});

api.delete('/users/:id', async (c: Context) => {
  try {
    const id = Number(c.req.param('id'));
    
    if (isNaN(id)) {
      return c.json({ success: false, error: 'Invalid user ID' }, 400);
    }
    
    await withTransaction(c, 'delete user', async (tx) => {
      // First check if user exists
      const user = await tx.query.users.findFirst({
        where: eq(schema.users.id, id)
      });
      
      if (!user) {
        throw new Error('User not found');
      }
      
      // Delete the user
      await tx.delete(schema.users)
        .where(eq(schema.users.id, id));
    });
    
    logger.info('Deleted user', { id });
    return c.json({ success: true, message: 'User deleted successfully' });
  } catch (error) {
    if (error instanceof Error && error.message === 'User not found') {
      return c.json({ success: false, error: 'User not found' }, 404);
    }
    
    logger.error(`Error deleting user ${c.req.param('id')}`, { error });
    return c.json({ success: false, error: 'Failed to delete user' }, 500);
  }
});

export function setupApiRoutes() {
  return api;
}
```


### `backend\src\routes\apis.ts`

```ts
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { db } from '../db/index.ts';
import * as schema from '../db/schema.ts';
import { eq } from 'drizzle-orm';
import { createLogger } from '../logging/index.ts';
import { withReadQuery, withTransaction, withWriteQuery } from '../db/transactions.ts';
import { apiRequest, invalidateCache } from '../api/client.ts';

// Logger for API routes
const logger = createLogger('routes:apis');

// API router
const app = new Hono();

// Schema for API creation
const createApiSchema = z.object({
  name: z.string().min(1).max(100),
  baseUrl: z.string().url().max(255),
  description: z.string().max(500).optional(),
  authType: z.enum(['none', 'bearer', 'apikey', 'basic']).optional(),
  authToken: z.string().max(500).optional(),
  authHeader: z.string().max(100).optional(),
  headers: z.record(z.string()).optional(),
  timeout: z.number().int().min(1000).max(60000).optional(), // 1s to 60s
  retries: z.number().int().min(0).max(10).optional(),
  active: z.boolean().optional().default(true)
});

// Schema for API updates
const updateApiSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  baseUrl: z.string().url().max(255).optional(),
  description: z.string().max(500).optional().nullable(),
  authType: z.enum(['none', 'bearer', 'apikey', 'basic']).optional(),
  authToken: z.string().max(500).optional().nullable(),
  authHeader: z.string().max(100).optional().nullable(),
  headers: z.record(z.string()).optional().nullable(),
  timeout: z.number().int().min(1000).max(60000).optional(), // 1s to 60s
  retries: z.number().int().min(0).max(10).optional(),
  active: z.boolean().optional()
});

// Schema for testing an API endpoint
const testApiSchema = z.object({
  endpoint: z.string().max(255),
  method: z.enum(['GET', 'POST', 'PUT', 'PATCH', 'DELETE']).default('GET'),
  headers: z.record(z.string()).optional(),
  body: z.any().optional(),
  timeout: z.number().int().min(1000).max(60000).optional()
});

// Schema for cache invalidation
const invalidateCacheSchema = z.object({
  tags: z.array(z.string()).optional(),
  urls: z.array(z.string()).optional()
});

// List all APIs
app.get('/', async (c) => {
  try {
    const apis = await withReadQuery(c, 'list apis', async () => {
      return await db.select().from(schema.apis).orderBy(schema.apis.name);
    });

    return c.json({
      success: true,
      data: apis.map(api => ({
        ...api,
        authToken: api.authToken ? '••••••••' : null // Mask auth token in response
      }))
    });
  } catch (error) {
    logger.error('Failed to list APIs', { error });
    return c.json({
      success: false,
      error: 'Failed to list APIs'
    }, 500);
  }
});

// Create a new API
app.post('/', zValidator('json', createApiSchema), async (c) => {
  try {
    const body = c.req.valid('json');
    
    const [api] = await withWriteQuery(c, 'create api', async () => {
      return await db.insert(schema.apis)
        .values({
          name: body.name,
          baseUrl: body.baseUrl,
          description: body.description || null,
          authType: body.authType || 'none',
          authToken: body.authToken || null,
          authHeader: body.authHeader || null,
          headers: body.headers ? JSON.stringify(body.headers) : null,
          timeout: body.timeout || 30000,
          retries: body.retries ?? 3,
          active: body.active ?? true,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();
    });
    
    logger.info('Created new API', { id: api.id, name: api.name });
    
    return c.json({
      success: true,
      data: {
        ...api,
        authToken: api.authToken ? '••••••••' : null // Mask auth token in response
      }
    }, 201);
  } catch (error) {
    logger.error('Failed to create API', { error });
    return c.json({
      success: false,
      error: 'Failed to create API'
    }, 500);
  }
});

// Get a single API by ID
app.get('/:id', async (c) => {
  try {
    const id = Number(c.req.param('id'));
    
    if (isNaN(id)) {
      return c.json({
        success: false,
        error: 'Invalid API ID'
      }, 400);
    }
    
    const api = await withReadQuery(c, 'get api', async () => {
      return await db.query.apis.findFirst({
        where: eq(schema.apis.id, id)
      });
    });
    
    if (!api) {
      return c.json({
        success: false,
        error: 'API not found'
      }, 404);
    }
    
    return c.json({
      success: true,
      data: {
        ...api,
        authToken: api.authToken ? '••••••••' : null // Mask auth token in response
      }
    });
  } catch (error) {
    logger.error('Failed to get API', { error });
    return c.json({
      success: false,
      error: 'Failed to get API'
    }, 500);
  }
});

// Update an API
app.patch('/:id', zValidator('json', updateApiSchema), async (c) => {
  try {
    const id = Number(c.req.param('id'));
    const body = c.req.valid('json');
    
    if (isNaN(id)) {
      return c.json({
        success: false,
        error: 'Invalid API ID'
      }, 400);
    }
    
    // Ensure API exists
    const exists = await withReadQuery(c, 'check api exists', async () => {
      return await db.query.apis.findFirst({
        where: eq(schema.apis.id, id)
      });
    });
    
    if (!exists) {
      return c.json({
        success: false,
        error: 'API not found'
      }, 404);
    }
    
    // Process headers if provided
    let headers = undefined;
    if (body.headers !== undefined) {
      headers = body.headers ? JSON.stringify(body.headers) : null;
    }
    
    // Update API
    const [updatedApi] = await withWriteQuery(c, 'update api', async () => {
      return await db.update(schema.apis)
        .set({
          ...(body.name !== undefined && { name: body.name }),
          ...(body.baseUrl !== undefined && { baseUrl: body.baseUrl }),
          ...(body.description !== undefined && { description: body.description }),
          ...(body.authType !== undefined && { authType: body.authType }),
          ...(body.authToken !== undefined && { authToken: body.authToken }),
          ...(body.authHeader !== undefined && { authHeader: body.authHeader }),
          ...(headers !== undefined && { headers }),
          ...(body.timeout !== undefined && { timeout: body.timeout }),
          ...(body.retries !== undefined && { retries: body.retries }),
          ...(body.active !== undefined && { active: body.active }),
          updatedAt: new Date()
        })
        .where(eq(schema.apis.id, id))
        .returning();
    });
    
    logger.info('Updated API', { id });
    
    return c.json({
      success: true,
      data: {
        ...updatedApi,
        authToken: updatedApi.authToken ? '••••••••' : null
      }
    });
  } catch (error) {
    logger.error('Failed to update API', { error });
    return c.json({
      success: false,
      error: 'Failed to update API'
    }, 500);
  }
});

// Delete an API
app.delete('/:id', async (c) => {
  try {
    const id = Number(c.req.param('id'));
    
    if (isNaN(id)) {
      return c.json({
        success: false,
        error: 'Invalid API ID'
      }, 400);
    }
    
    // Delete API with transaction to handle related data
    await withTransaction(c, 'delete api', async (tx) => {
      // First check if API exists
      const api = await tx.query.apis.findFirst({
        where: eq(schema.apis.id, id)
      });
      
      if (!api) {
        throw new Error('API not found');
      }
      
      // Delete endpoints related to this API
      await tx.delete(schema.endpoints)
        .where(eq(schema.endpoints.apiId, id));
      
      // Delete retry schedule entries for this API
      await tx.delete(schema.retrySchedule)
        .where(eq(schema.retrySchedule.apiId, id));
      
      // Then delete the API
      await tx.delete(schema.apis)
        .where(eq(schema.apis.id, id));
    });
    
    logger.info('Deleted API', { id });
    
    return c.json({
      success: true,
      message: 'API deleted successfully'
    });
  } catch (error) {
    if (error instanceof Error && error.message === 'API not found') {
      return c.json({
        success: false,
        error: 'API not found'
      }, 404);
    }
    
    logger.error('Failed to delete API', { error });
    return c.json({
      success: false,
      error: 'Failed to delete API'
    }, 500);
  }
});

// Test an API endpoint
app.post('/:id/test', zValidator('json', testApiSchema), async (c) => {
  try {
    const id = Number(c.req.param('id'));
    const body = c.req.valid('json');
    
    if (isNaN(id)) {
      return c.json({
        success: false,
        error: 'Invalid API ID'
      }, 400);
    }
    
    // Check if API exists
    const api = await withReadQuery(c, 'check api exists for test', async () => {
      return await db.query.apis.findFirst({
        where: eq(schema.apis.id, id)
      });
    });
    
    if (!api) {
      return c.json({
        success: false,
        error: 'API not found'
      }, 404);
    }
    
    if (!api.active) {
      return c.json({
        success: false,
        error: 'Cannot test inactive API'
      }, 400);
    }
    
    // Make the API request
    const response = await apiRequest(
      id,
      body.endpoint,
      {
        method: body.method,
        headers: body.headers,
        body: body.body,
        timeout: body.timeout,
        useCache: false // Don't use cache for test requests
      }
    );
    
    logger.info('Tested API endpoint', { 
      id, 
      endpoint: body.endpoint, 
      status: response.status,
      success: response.success
    });
    
    return c.json({
      success: true,
      data: response
    });
  } catch (error) {
    logger.error('Failed to test API endpoint', { error });
    return c.json({
      success: false,
      error: 'Failed to test API endpoint'
    }, 500);
  }
});

// List all endpoints for an API
app.get('/:id/endpoints', async (c) => {
  try {
    const id = Number(c.req.param('id'));
    
    if (isNaN(id)) {
      return c.json({
        success: false,
        error: 'Invalid API ID'
      }, 400);
    }
    
    // Check if API exists
    const api = await withReadQuery(c, 'check api exists', async () => {
      return await db.query.apis.findFirst({
        where: eq(schema.apis.id, id)
      });
    });
    
    if (!api) {
      return c.json({
        success: false,
        error: 'API not found'
      }, 404);
    }
    
    // Get endpoints
    const endpoints = await withReadQuery(c, 'list api endpoints', async () => {
      return await db.select()
        .from(schema.endpoints)
        .where(eq(schema.endpoints.apiId, id))
        .orderBy(schema.endpoints.path);
    });
    
    return c.json({
      success: true,
      data: endpoints
    });
  } catch (error) {
    logger.error('Failed to list API endpoints', { error });
    return c.json({
      success: false,
      error: 'Failed to list API endpoints'
    }, 500);
  }
});

// Create a new endpoint for an API
app.post('/:id/endpoints', async (c) => {
  try {
    const id = Number(c.req.param('id'));
    const body = await c.req.json();
    
    if (isNaN(id)) {
      return c.json({
        success: false,
        error: 'Invalid API ID'
      }, 400);
    }
    
    // Validate required fields
    if (!body.path || !body.method) {
      return c.json({
        success: false,
        error: 'Path and method are required'
      }, 400);
    }
    
    // Ensure API exists
    const api = await withReadQuery(c, 'check api exists', async () => {
      return await db.query.apis.findFirst({
        where: eq(schema.apis.id, id)
      });
    });
    
    if (!api) {
      return c.json({
        success: false,
        error: 'API not found'
      }, 404);
    }
    
    // Create endpoint
    const [endpoint] = await withWriteQuery(c, 'create endpoint', async () => {
      return await db.insert(schema.endpoints)
        .values({
          apiId: id,
          path: body.path,
          method: body.method,
          description: body.description || null,
          parameters: body.parameters ? JSON.stringify(body.parameters) : null,
          headers: body.headers ? JSON.stringify(body.headers) : null,
          body: body.body ? JSON.stringify(body.body) : null,
          cacheTtl: body.cacheTtl || 300,
          timeout: body.timeout || api.timeout || 30000,
          retries: body.retries ?? api.retries ?? 3,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();
    });
    
    logger.info('Created new endpoint', { 
      apiId: id, 
      path: endpoint.path, 
      method: endpoint.method 
    });
    
    return c.json({
      success: true,
      data: endpoint
    }, 201);
  } catch (error) {
    logger.error('Failed to create endpoint', { error });
    return c.json({
      success: false,
      error: 'Failed to create endpoint'
    }, 500);
  }
});

// Invalidate cache
app.post('/cache/invalidate', zValidator('json', invalidateCacheSchema), async (c) => {
  try {
    const body = c.req.valid('json');
    
    if ((!body.tags || body.tags.length === 0) && (!body.urls || body.urls.length === 0)) {
      return c.json({
        success: false,
        error: 'Either tags or urls must be provided'
      }, 400);
    }
    
    const invalidated = await invalidateCache({
      tags: body.tags,
      urls: body.urls
    });
    
    logger.info('Invalidated cache entries', { 
      count: invalidated,
      tags: body.tags,
      urls: body.urls 
    });
    
    return c.json({
      success: true,
      data: {
        invalidated
      }
    });
  } catch (error) {
    logger.error('Failed to invalidate cache', { error });
    return c.json({
      success: false,
      error: 'Failed to invalidate cache'
    }, 500);
  }
});

export function setupApiRoutes() {
  return app;
}
```


### `backend\src\routes\dcr.ts`

```ts
import { Hono } from 'hono';
import { Context } from 'hono';
import process from 'node:process';
import { db } from '../db/index.ts';
import * as schema from '../db/schema.ts';
import { desc, eq, sql } from 'drizzle-orm';

// Setup DCR internal routes
export function setupDcrRoutes(app: Hono): void {
  // Logs endpoints
  app.get('/logs', async (c: Context) => {
    try {
      const limit = Number(c.req.query('limit') || '50');
      const offset = Number(c.req.query('offset') || '0');
      
      const items = await db
        .select()
        .from(schema.logs)
        .orderBy(desc(schema.logs.timestamp))
        .limit(limit)
        .offset(offset);
      
      const total = await db
        .select({ count: sql<number>`count(*)` })
        .from(schema.logs);
      
      return c.json({
        success: true,
        logs: items,
        pagination: {
          total: total[0].count,
          limit,
          offset,
          hasMore: offset + limit < total[0].count
        }
      });
    } catch (error) {
      console.error('Error fetching logs:', error);
      return c.json({
        success: false,
        error: (error as Error).message
      }, 500);
    }
  });

  // System status and metrics
  app.get('/status', async (c: Context) => {
    try {
      const dbStatus = await checkDbConnectivity();
      
      return c.json({
        success: true,
        status: {
          system: 'operational',
          database: dbStatus ? 'connected' : 'disconnected',
          uptime: process.uptime(),
          memory: process.memoryUsage(),
          timestamp: new Date().toISOString()
        }
      });
    } catch (error) {
      return c.json({
        success: false,
        error: (error as Error).message
      }, 500);
    }
  });

  // Webhook registration and management
  app.post('/webhooks', async (c: Context) => {
    try {
      const body = await c.req.json();
      
      // Store webhook registration in database...
      // For now, just echo back the request
      return c.json({
        success: true,
        message: 'Webhook registered',
        webhook: body
      });
    } catch (error) {
      return c.json({
        success: false,
        error: (error as Error).message
      }, 500);
    }
  });

  // Flush cache
  app.post('/cache/flush', async (c: Context) => {
    try {
      const body = await c.req.json();
      const key = body.key as string | undefined;
      
      if (key) {
        // Flush specific cache key
        return c.json({
          success: true,
          message: `Cache key ${key} flushed`
        });
      } else {
        // Flush all cache
        return c.json({
          success: true,
          message: 'All cache flushed'
        });
      }
    } catch (error) {
      return c.json({
        success: false,
        error: (error as Error).message
      }, 500);
    }
  });
}

// Helper to check DB connectivity
async function checkDbConnectivity(): Promise<boolean> {
  try {
    // Run a simple query to verify the database is responsive
    const result = await db.select({ value: sql`1` }).get();
    return result?.value === 1;
  } catch (error) {
    console.error('Database connectivity check failed:', error);
    return false;
  }
}
```


### `backend\src\routes\webhooks.ts`

```ts
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { db } from '../db/index.ts';
import * as schema from '../db/schema.ts';
import { eq } from 'drizzle-orm';
import { createLogger } from '../logging/index.ts';
import { withReadQuery, withTransaction, withWriteQuery } from '../db/transactions.ts';
import { registerWebhook, WebhookEvent } from '../webhooks/index.ts';

// Logger for webhook routes
const logger = createLogger('routes:webhooks');

// Webhook API router
const app = new Hono();

// Schema for webhook creation
const createWebhookSchema = z.object({
  url: z.string().url().max(255),
  event: z.enum([
    'api.request', 
    'api.response', 
    'cache.hit', 
    'cache.miss', 
    'error', 
    'retry', 
    'system'
  ]),
  secret: z.string().max(255).optional(),
  description: z.string().max(500).optional()
});

// Schema for webhook updates
const updateWebhookSchema = z.object({
  url: z.string().url().max(255).optional(),
  active: z.boolean().optional(),
  secret: z.string().max(255).optional().nullable(),
  description: z.string().max(500).optional().nullable()
});

// List all webhooks
app.get('/', async (c) => {
  try {
    const webhooks = await withReadQuery(c, 'list webhooks', async () => {
      return await db.select().from(schema.webhooks).orderBy(schema.webhooks.createdAt);
    });

    return c.json({
      success: true,
      data: webhooks.map(webhook => ({
        ...webhook,
        secret: webhook.secret ? '••••••••' : null // Mask secret in response
      }))
    });
  } catch (error) {
    logger.error('Failed to list webhooks', { error });
    return c.json({
      success: false,
      error: 'Failed to list webhooks'
    }, 500);
  }
});

// Create a new webhook subscription
app.post('/', zValidator('json', createWebhookSchema), async (c) => {
  try {
    const body = c.req.valid('json');
    
    // Register webhook using the webhook service
    const webhook = await registerWebhook(
      body.url, 
      body.event as WebhookEvent, 
      body.secret
    );
    
    // If description provided, update it
    if (body.description) {
      await withWriteQuery(c, 'update webhook description', async () => {
        await db.update(schema.webhooks)
          .set({ description: body.description })
          .where(eq(schema.webhooks.id, webhook.id));
      });
      
      webhook.description = body.description;
    }
    
    logger.info('Created new webhook subscription', { 
      id: webhook.id, 
      url: webhook.url, 
      event: webhook.event 
    });
    
    return c.json({
      success: true,
      data: {
        ...webhook,
        secret: webhook.secret ? '••••••••' : null // Mask secret in response
      }
    }, 201);
  } catch (error) {
    logger.error('Failed to create webhook', { error });
    return c.json({
      success: false,
      error: 'Failed to create webhook'
    }, 500);
  }
});

// Get a single webhook by ID
app.get('/:id', async (c) => {
  try {
    const id = Number(c.req.param('id'));
    
    if (isNaN(id)) {
      return c.json({
        success: false,
        error: 'Invalid webhook ID'
      }, 400);
    }
    
    const webhook = await withReadQuery(c, 'get webhook', async () => {
      return await db.query.webhooks.findFirst({
        where: eq(schema.webhooks.id, id)
      });
    });
    
    if (!webhook) {
      return c.json({
        success: false,
        error: 'Webhook not found'
      }, 404);
    }
    
    return c.json({
      success: true,
      data: {
        ...webhook,
        secret: webhook.secret ? '••••••••' : null // Mask secret in response
      }
    });
  } catch (error) {
    logger.error('Failed to get webhook', { error });
    return c.json({
      success: false,
      error: 'Failed to get webhook'
    }, 500);
  }
});

// Update a webhook
app.patch('/:id', zValidator('json', updateWebhookSchema), async (c) => {
  try {
    const id = Number(c.req.param('id'));
    const body = c.req.valid('json');
    
    if (isNaN(id)) {
      return c.json({
        success: false,
        error: 'Invalid webhook ID'
      }, 400);
    }
    
    // Ensure webhook exists
    const exists = await withReadQuery(c, 'check webhook exists', async () => {
      return await db.query.webhooks.findFirst({
        where: eq(schema.webhooks.id, id)
      });
    });
    
    if (!exists) {
      return c.json({
        success: false,
        error: 'Webhook not found'
      }, 404);
    }
    
    // Update webhook
    const [updatedWebhook] = await withWriteQuery(c, 'update webhook', async () => {
      return await db.update(schema.webhooks)
        .set({
          ...(body.url && { url: body.url }),
          ...(body.active !== undefined && { active: body.active }),
          ...(body.secret !== undefined && { secret: body.secret }),
          ...(body.description !== undefined && { description: body.description }),
          updatedAt: new Date()
        })
        .where(eq(schema.webhooks.id, id))
        .returning();
    });
    
    logger.info('Updated webhook', { id });
    
    return c.json({
      success: true,
      data: {
        ...updatedWebhook,
        secret: updatedWebhook.secret ? '••••••••' : null
      }
    });
  } catch (error) {
    logger.error('Failed to update webhook', { error });
    return c.json({
      success: false,
      error: 'Failed to update webhook'
    }, 500);
  }
});

// Delete a webhook
app.delete('/:id', async (c) => {
  try {
    const id = Number(c.req.param('id'));
    
    if (isNaN(id)) {
      return c.json({
        success: false,
        error: 'Invalid webhook ID'
      }, 400);
    }
    
    // Delete webhook with transaction to handle related logs
    await withTransaction(c, 'delete webhook', async (tx) => {
      // First delete related logs
      await tx.delete(schema.webhookLogs)
        .where(eq(schema.webhookLogs.webhookId, id));
      
      // Then delete the webhook
      const deleted = await tx.delete(schema.webhooks)
        .where(eq(schema.webhooks.id, id))
        .returning();
      
      if (deleted.length === 0) {
        throw new Error('Webhook not found');
      }
    });
    
    logger.info('Deleted webhook', { id });
    
    return c.json({
      success: true,
      message: 'Webhook deleted successfully'
    });
  } catch (error) {
    if (error instanceof Error && error.message === 'Webhook not found') {
      return c.json({
        success: false,
        error: 'Webhook not found'
      }, 404);
    }
    
    logger.error('Failed to delete webhook', { error });
    return c.json({
      success: false,
      error: 'Failed to delete webhook'
    }, 500);
  }
});

// Get webhook delivery logs
app.get('/:id/logs', async (c) => {
  try {
    const id = Number(c.req.param('id'));
    
    if (isNaN(id)) {
      return c.json({
        success: false,
        error: 'Invalid webhook ID'
      }, 400);
    }
    
    // Check if webhook exists
    const webhook = await withReadQuery(c, 'check webhook exists', async () => {
      return await db.query.webhooks.findFirst({
        where: eq(schema.webhooks.id, id)
      });
    });
    
    if (!webhook) {
      return c.json({
        success: false,
        error: 'Webhook not found'
      }, 404);
    }
    
    // Get logs with pagination
    const limit = Number(c.req.query('limit') || '20');
    const offset = Number(c.req.query('offset') || '0');
    
    const logs = await withReadQuery(c, 'get webhook logs', async () => {
      return await db.select()
        .from(schema.webhookLogs)
        .where(eq(schema.webhookLogs.webhookId, id))
        .orderBy(schema.webhookLogs.timestamp, 'desc')
        .limit(limit)
        .offset(offset);
    });
    
    // Get total count
    const [{ count }] = await withReadQuery(c, 'count webhook logs', async () => {
      return await db.select({
        count: db.fn.count()
      })
      .from(schema.webhookLogs)
      .where(eq(schema.webhookLogs.webhookId, id));
    });
    
    return c.json({
      success: true,
      data: logs,
      pagination: {
        total: Number(count),
        limit,
        offset,
        hasMore: Number(count) > offset + logs.length
      }
    });
  } catch (error) {
    logger.error('Failed to get webhook logs', { error });
    return c.json({
      success: false,
      error: 'Failed to get webhook logs'
    }, 500);
  }
});

// Trigger a test webhook
app.post('/:id/test', async (c) => {
  try {
    const id = Number(c.req.param('id'));
    
    if (isNaN(id)) {
      return c.json({
        success: false,
        error: 'Invalid webhook ID'
      }, 400);
    }
    
    // Get webhook details
    const webhook = await withReadQuery(c, 'get webhook for test', async () => {
      return await db.query.webhooks.findFirst({
        where: eq(schema.webhooks.id, id)
      });
    });
    
    if (!webhook) {
      return c.json({
        success: false,
        error: 'Webhook not found'
      }, 404);
    }
    
    if (!webhook.active) {
      return c.json({
        success: false,
        error: 'Cannot test inactive webhook'
      }, 400);
    }
    
    // Import webhook handler directly to avoid circular dependency
    const { deliverWebhook } = await import('../webhooks/index.ts');
    
    // Create test payload
    const payload = {
      event: webhook.event as WebhookEvent,
      timestamp: new Date().toISOString(),
      source: 'webhook.test',
      data: {
        test: true,
        message: 'This is a test webhook',
        id: webhook.id
      }
    };
    
    // Deliver test webhook
    const result = await deliverWebhook(webhook.url, payload, webhook.secret);
    
    // Record test attempt
    await db.insert(schema.webhookLogs).values({
      webhookId: webhook.id,
      event: webhook.event,
      success: result.success,
      statusCode: result.statusCode || null,
      responseData: result.response 
        ? JSON.stringify(result.response).substring(0, 1000) 
        : null,
      errorMessage: result.error || null,
      timestamp: new Date()
    });
    
    logger.info('Sent test webhook', { 
      id: webhook.id, 
      success: result.success,
      statusCode: result.statusCode
    });
    
    return c.json({
      success: true,
      data: {
        result,
        webhook: {
          ...webhook,
          secret: webhook.secret ? '••••••••' : null
        }
      }
    });
  } catch (error) {
    logger.error('Failed to test webhook', { error });
    return c.json({
      success: false,
      error: 'Failed to test webhook'
    }, 500);
  }
});

export function setupWebhookRoutes() {
  return app;
}
```


### `backend\src\scheduler\index.ts`

```ts
/**
 * Scheduler for background tasks
 * 
 * This module handles scheduling of periodic tasks such as log archiving,
 * cache cleanup, etc. using node-cron.
 */
import cron from 'node-cron';
import { archiveLogs } from '../scripts/archive-logs.js';
import { LogPhase, logToDb } from '../logging/index.js';
import { env } from '../env.js';

// Task registry to keep track of all scheduled tasks
const scheduledTasks: Map<string, cron.ScheduledTask> = new Map();

/**
 * Schedule log archiving to run daily
 * @param cronExpression Optional cron expression override (default: midnight every day)
 */
export function scheduleLogArchiving(cronExpression = '0 0 * * *'): void {
  // Validate cron expression
  if (!cron.validate(cronExpression)) {
    throw new Error(`Invalid cron expression: ${cronExpression}`);
  }
  
  // Schedule task
  const task = cron.schedule(cronExpression, async () => {
    try {
      await logToDb({
        phase: LogPhase.ARCHIVE,
        message: 'Scheduled log archiving task started',
        success: true,
        metadata: {
          service: env.SERVICE_ID || 'dcr-backend',
          cronExpression
        }
      });
      
      await archiveLogs();
    } catch (error) {
      console.error('Error in scheduled log archiving task:', error);
      
      await logToDb({
        phase: LogPhase.ARCHIVE,
        message: 'Scheduled log archiving task failed',
        success: false,
        metadata: {
          error: error instanceof Error ? error.message : String(error),
          service: env.SERVICE_ID || 'dcr-backend'
        }
      });
    }
  });
  
  // Store reference to task
  scheduledTasks.set('logArchiving', task);
  
  console.log(`Log archiving scheduled with cron expression: ${cronExpression}`);
}

/**
 * Initialize all scheduled tasks
 */
export async function initializeScheduler(): Promise<void> {
  await logToDb({
    phase: LogPhase.INIT,
    message: 'Initializing task scheduler',
    success: true,
    metadata: {
      service: env.SERVICE_ID || 'dcr-backend'
    }
  });
  
  // Schedule log archiving
  scheduleLogArchiving();
  
  // Add more scheduled tasks here as needed
  
  await logToDb({
    phase: LogPhase.INIT,
    message: 'Task scheduler initialized',
    success: true,
    metadata: {
      taskCount: scheduledTasks.size,
      service: env.SERVICE_ID || 'dcr-backend'
    }
  });
}

/**
 * Stop all scheduled tasks
 */
export async function shutdownScheduler(): Promise<void> {
  await logToDb({
    phase: LogPhase.SHUTDOWN,
    message: 'Shutting down task scheduler',
    success: true,
    metadata: {
      taskCount: scheduledTasks.size,
      service: env.SERVICE_ID || 'dcr-backend'
    }
  });
  
  // Stop all scheduled tasks
  for (const [name, task] of scheduledTasks.entries()) {
    task.stop();
    console.log(`Stopped scheduled task: ${name}`);
  }
  
  // Clear the registry
  scheduledTasks.clear();
}
```


### `backend\src\schemas\api.schema.ts`

```ts
import { z } from 'zod';

// Base schema for API data
export const apiSchema = z.object({
  name: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  type: z.string(),
  baseUrl: z.string().nullable(),
  config: z.string(), // JSON string
  configHash: z.string(),
  createdAt: z.date(),
  updatedAt: z.date()
});

// Schema for inserting API data
export const apiInsertSchema = apiSchema;

// Type for API data
export type ApiData = z.infer<typeof apiSchema>;

// Base schema for endpoint data
export const endpointSchema = z.object({
  apiId: z.number(),
  path: z.string(),
  method: z.string(),
  description: z.string().nullable(),
  version: z.string(),
  config: z.string(), // JSON string
  configHash: z.string(),
  createdAt: z.date(),
  updatedAt: z.date()
});

// Schema for inserting endpoint data
export const endpointInsertSchema = endpointSchema;

// Type for endpoint data
export type EndpointData = z.infer<typeof endpointSchema>;

// Parsed collection schema
export const parsedCollectionSchema = z.object({
  name: z.string(),
  description: z.string().nullable().optional(),
  baseUrl: z.string().nullable().optional(),
  endpoints: z.array(
    z.object({
      path: z.string(),
      method: z.string(),
      description: z.string().nullable().optional(),
      headers: z.record(z.string()).optional(),
      params: z.record(z.string()).optional(),
      body: z.any().optional()
    })
  )
});

export type ParsedCollection = z.infer<typeof parsedCollectionSchema>;
```


### `backend\src\scripts\archive-logs.ts`

```ts
/**
 * Log archiving script
 * 
 * This script is meant to be run on a schedule (e.g. daily via cron)
 * to archive logs older than the configured interval (default: 7 days).
 * Logs will be archived to the configured storage location (S3, FTP, or local filesystem).
 */
import { LogManager, logToDB } from '../logging/index.js';
import { env } from '../env.js';
import { LogPhase } from '../logging/types.js';

/**
 * Main function to archive logs
 */
async function archiveLogs() {
  // Log the start of the archiving process
  await logToDB({
    message: 'Starting log archiving process',
    source: 'archive-script',
    level: 'info',
    phase: LogPhase.ARCHIVE,
    metadata: {
      interval: env.LOG_STORAGE_INTERVAL,
      driver: env.LOG_STORAGE_DRIVER,
      zipOption: env.LOG_STORAGE_ZIP_OPTION,
      service: env.SERVICE_ID || 'dcr-backend',
      success: true
    }
  });

  try {
    // Get the log manager instance
    const logManager = LogManager.getInstance();
    
    // Initialize the log manager if not already initialized
    await logManager.initialize();
    
    console.log(`Archiving logs older than ${env.LOG_STORAGE_INTERVAL} days...`);
    
    // Run the archival process
    await logManager.archiveLogs();
    
    // Log successful completion
    await logToDB({
      message: 'Log archiving process completed successfully',
      source: 'archive-script',
      level: 'info',
      phase: LogPhase.ARCHIVE,
      metadata: {
        interval: env.LOG_STORAGE_INTERVAL,
        driver: env.LOG_STORAGE_DRIVER,
        service: env.SERVICE_ID || 'dcr-backend',
        success: true
      }
    });
  } catch (error) {
    console.error('Error archiving logs:', error);
    
    // Log the error
    await logToDB({
      message: 'Error during log archiving process',
      source: 'archive-script',
      level: 'error',
      phase: LogPhase.ARCHIVE,
      metadata: {
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
        service: env.SERVICE_ID || 'dcr-backend',
        success: false
      }
    });
    
    // Exit with error code
    process.exit(1);
  }
}

// Run the archival process if this script is executed directly
if (require.main === module) {
  archiveLogs().then(() => process.exit(0));
}

// Export for testing or programmatic usage
export { archiveLogs };
```


### `backend\src\scripts\check-db.ts`

```ts
// Simple database check script
import { db } from '../db/index.js';
import { sql } from 'drizzle-orm';

async function checkDatabase() {
  try {
    console.log('🔍 Checking database tables and data...');
    
    // List all tables
    const tables = await db.select({ name: sql`name` })
      .from(sql`sqlite_master`)
      .where(sql`type = 'table' AND name NOT LIKE 'sqlite_%'`);
    
    console.log(`\n📋 Found ${tables.length} tables: ${tables.map(t => t.name).join(', ')}`);
    
    // Check users
    const users = await db.select({ id: sql`id`, email: sql`email`, role: sql`role` }).from(sql`users`);
    console.log(`\n👥 Users (${users.length}):`);
    users.forEach(user => console.log(`  - ID ${user.id}: ${user.email} (${user.role})`));
    
    // Check permissions
    const permissions = await db.select({
      id: sql`id`, 
      userId: sql`user_id`, 
      resource: sql`resource`,
      action: sql`action`
    }).from(sql`permissions`);
    console.log(`\n🔑 Permissions (${permissions.length}):`);
    permissions.forEach(perm => console.log(`  - ID ${perm.id}: User ${perm.userId} can ${perm.action} ${perm.resource}`));
    
    // Check APIs
    const apis = await db.select({ id: sql`id`, name: sql`name`, type: sql`type` }).from(sql`apis`);
    console.log(`\n🔌 APIs (${apis.length}):`);
    apis.forEach(api => console.log(`  - ID ${api.id}: ${api.name} (${api.type})`));
    
    // Check endpoints
    const endpoints = await db.select({ 
      id: sql`id`, 
      apiId: sql`api_id`, 
      path: sql`path`,
      method: sql`method`
    }).from(sql`endpoints`);
    console.log(`\n🔗 Endpoints (${endpoints.length}):`);
    endpoints.forEach(endpoint => console.log(`  - ID ${endpoint.id}: ${endpoint.method} ${endpoint.path} (API: ${endpoint.apiId})`));
    
    console.log('\n✅ Database check complete!');
  } catch (error) {
    console.error('❌ Error checking database:', error);
  }
}

// Run the check
checkDatabase().catch(console.error);
```


### `backend\src\scripts\generate-migration.ts`

```ts
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { migrate } from 'drizzle-orm/better-sqlite3/migrator';
import Database from 'better-sqlite3';
import { sql } from 'drizzle-orm';
import * as schema from '../db/schema.ts';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import process from 'node:process';
import { env } from '../env.ts';

// Get the current file's directory path
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Generate a migration file for database schema changes
 * @param migrationName - Name for the migration file
 */
async function generateMigration(migrationName: string): Promise<void> {
  console.log('🔧 Generating database migration...');

  if (!migrationName) {
    console.error('❌ Migration name is required');
    console.log('Usage: node generate-migration.ts <migration-name>');
    process.exit(1);
  }

  // Parse the DATABASE_URL for SQLite
  const dbPath = env.DATABASE_URL.replace('sqlite:///', '');
  console.log(`📁 Database path: ${dbPath}`);

  // Create a timestamp for migration file name
  const timestamp = new Date().toISOString().replace(/[-:T.]/g, '').slice(0, 14);
  const fileName = `${timestamp}_${migrationName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.sql`;

  // Define paths
  const migrationsFolder = path.resolve(__dirname, '../../drizzle');
  const migrationPath = path.join(migrationsFolder, fileName);

  // Ensure the migrations folder exists
  if (!fs.existsSync(migrationsFolder)) {
    console.log(`Creating migrations directory: ${migrationsFolder}`);
    fs.mkdirSync(migrationsFolder, { recursive: true });
  }

  try {
    // Copy the current schema to a temporary database
    const tempDbPath = ':memory:';
    const tempDb = new Database(tempDbPath);
    const db = drizzle(tempDb);

    // Create all tables in the temporary database
    for (const tableName in schema) {
      if (Object.prototype.hasOwnProperty.call(schema, tableName)) {
        const tableSchema = (schema as Record<string, any>)[tableName];
        
        if (tableSchema && typeof tableSchema === 'object' && tableSchema._.name) {
          const createTableSQL = sql.raw(
            `CREATE TABLE IF NOT EXISTS ${tableSchema._.name} (${
              Object.entries(tableSchema)
                .filter(([key]) => key !== '_')
                .map(([key, column]: [string, any]) => {
                  let definition = `${column.name} ${column.dataType}`;
                  if (column.primaryKey) definition += ' PRIMARY KEY';
                  if (column.notNull) definition += ' NOT NULL';
                  if (column.default !== undefined) definition += ` DEFAULT ${column.default}`;
                  if (column.unique) definition += ' UNIQUE';
                  return definition;
                })
                .join(', ')
            })`
          );

          await db.execute(createTableSQL);
        }
      }
    }

    // Generate SQL statements for the migration
    const migrationSQL = `-- Migration: ${migrationName}
-- Generated at: ${new Date().toISOString()}

-- Create tables
${Object.entries(schema)
  .filter(([key]) => key !== '_' && typeof (schema as Record<string, any>)[key] === 'object')
  .map(([tableName, tableSchema]: [string, any]) => {
    if (!tableSchema._.name) return '';
    
    return `-- Table: ${tableSchema._.name}
CREATE TABLE IF NOT EXISTS ${tableSchema._.name} (
  ${Object.entries(tableSchema)
    .filter(([key]) => key !== '_')
    .map(([key, column]: [string, any]) => {
      let definition = `${column.name} ${column.dataType}`;
      if (column.primaryKey) definition += ' PRIMARY KEY';
      if (column.notNull) definition += ' NOT NULL';
      if (column.default !== undefined) {
        if (typeof column.default === 'string' && column.default.includes('CURRENT_TIMESTAMP')) {
          definition += ` DEFAULT CURRENT_TIMESTAMP`;
        } else {
          definition += ` DEFAULT ${column.default}`;
        }
      }
      if (column.unique) definition += ' UNIQUE';
      return definition;
    })
    .join(',\n  ')}
);
`;
  })
  .join('\n')}

-- Add indexes (customize as needed)
-- CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);

-- Add any additional schema changes below

`;

    // Write the migration file
    fs.writeFileSync(migrationPath, migrationSQL, 'utf-8');
    console.log(`✅ Migration generated at: ${migrationPath}`);
    
    // Close the temporary database
    tempDb.close();
  } catch (error) {
    console.error('❌ Migration generation failed:', error);
    process.exit(1);
  }
}

// Get migration name from command line arguments
const migrationName = process.argv[2];

// Run the migration generator if this script is executed directly
if (process.argv[1] === fileURLToPath(import.meta.url)) {
  generateMigration(migrationName).catch(console.error);
}

// Export for programmatic usage
export { generateMigration };
```


### `backend\src\scripts\migrate.ts`

```ts
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { migrate } from 'drizzle-orm/better-sqlite3/migrator';
import Database from 'better-sqlite3';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

import { db } from '../db/index.js';
import { env } from '../env.js';

// Get the current file's directory path
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function runMigrations() {
  console.log('🔄 Running database migrations...');

  // Parse the DATABASE_URL for SQLite
  const dbPath = env.DATABASE_URL.replace('sqlite:', '');
  console.log(`📁 Database path: ${dbPath}`);

  // Ensure the database directory exists
  const dbDir = path.resolve(process.cwd(), path.dirname(dbPath));
  if (!fs.existsSync(dbDir)) {
    console.log(`Creating database directory: ${dbDir}`);
    fs.mkdirSync(dbDir, { recursive: true });
  }
  
  // Get the full database file path
  const fullDbPath = path.resolve(process.cwd(), dbPath);

  try {
    // Connect to SQLite database
    const sqlite = new Database(fullDbPath);
    const db = drizzle(sqlite);

    // Run migrations
    const migrationsFolder = path.resolve(__dirname, '../db/migrations');
    console.log(`👉 Looking for migrations in: ${migrationsFolder}`);
    
    // For SQL file migrations, we need to read and execute them manually
    const migrationFiles = fs.readdirSync(migrationsFolder)
      .filter(file => file.endsWith('.sql'))
      .sort(); // Sort to ensure migrations run in order
      
    console.log(`Found ${migrationFiles.length} migration files to run`);
    
    for (const file of migrationFiles) {
      console.log(`Running migration: ${file}`);
      const filePath = path.join(migrationsFolder, file);
      const sql = fs.readFileSync(filePath, 'utf8');
      
      // Split the SQL into statements and execute each one
      const statements = sql.split(';').filter(stmt => stmt.trim());
      
      for (const statement of statements) {
        try {
          sqlite.exec(statement);
        } catch (error) {
          console.error(`Error executing statement from ${file}:`, error);
          throw error;
        }
      }
      
      console.log(`✅ Successfully ran migration: ${file}`);
    }
    console.log('✅ Migrations completed successfully');
    
    // Close the database connection
    sqlite.close();
    
    console.log('🚀 Database is ready to use');
  } catch (error) {
    console.error('❌ Migration failed:', error);
    process.exit(1);
  }
}

// Call the migration function if this script is executed directly
// Check if this script is being run directly
// Use import.meta.url for ES modules
const isMainModule = import.meta.url.endsWith(process.argv[1].replace(/\\/g, '/'));

if (isMainModule) {
  runMigrations().catch(console.error);
}

// Export for programmatic usage
export { runMigrations };
```


### `backend\src\scripts\run-migrations.ts`

```ts
// Database Migration Runner
import { runMigrations } from './migrate.js';
import process from 'node:process';

// Run migrations when this script is executed directly
console.log('🔄 DCR Database Migration Runner');
console.log('--------------------------------');

runMigrations()
  .then(() => {
    console.log('✅ Migrations completed successfully');
    process.exit(0);
  })
  .catch((error: unknown) => {
    console.error('❌ Migration failed:', error);
    process.exit(1);
  });
```


### `backend\src\scripts\schema-inspector.ts`

```ts
// Schema inspector to check what's actually in the database
import { db } from '../db/index.js';
import { sql } from 'drizzle-orm';

async function inspectDatabaseSchema() {
  try {
    console.log('🔍 Inspecting database schema...');
    
    // Get all tables
    const tables = await db.select({
      name: sql`name`,
      sql: sql`sql`,
    }).from(sql`sqlite_master`)
      .where(sql`type = 'table' AND name NOT LIKE 'sqlite_%'`);
    
    console.log(`📋 Found ${tables.length} tables:`);
    
    // Print each table and its schema
    for (const table of tables) {
      console.log(`\n🔹 TABLE: ${table.name}`);
      console.log('CREATE STATEMENT:');
      console.log(table.sql);
      
      // Get all columns for this table
      const pragma = await db.select({
        name: sql`name`,
        type: sql`type`,
        pk: sql`pk`,
        notnull: sql`notnull`
      }).from(sql`pragma_table_info(${table.name})`);
      
      console.log('\nCOLUMNS:');
      for (const col of pragma) {
        console.log(`  - ${col.name} (${col.type})${col.pk ? ' PRIMARY KEY' : ''}${col.notnull ? ' NOT NULL' : ''}`);
      }
      
      // Check if there's any data in the table
      const countResult = await db.select({
        count: sql`count(*)`
      }).from(sql`${table.name}`);
      
      console.log(`\nROW COUNT: ${countResult[0].count}`);
    }
    
    console.log('\n✅ Schema inspection complete');
    
  } catch (error) {
    console.error('❌ Error inspecting schema:', error);
  }
}

// Run the inspection
inspectDatabaseSchema().catch(console.error);
```


### `backend\src\scripts\seed.ts`

```ts
import { db } from '../db/index.js';
import { users, permissions, apis, endpoints } from '../db/schema.js';
import { eq, sql } from 'drizzle-orm';
import bcrypt from 'bcrypt';
import process from 'node:process';
import { runMigrations } from './migrate.js';
import { env } from '../env.js';
import { apiInsertSchema, endpointInsertSchema } from '../schemas/api.schema.js';
import crypto from 'node:crypto';

// Simple password hashing function (in prod, use a proper library like bcrypt)
function hashPassword(password: string): string {
  return bcrypt.hashSync(password, 10);
}

// Helper function to calculate SHA-256 hash
function calculateHash(content: string): string {
  return crypto.createHash("sha256").update(content).digest("hex");
}

// Main seed function
async function seed() {
  try {
    // First ensure migrations are up to date
    console.log('🔄 Running migrations before seeding...');
    await runMigrations();
    
    console.log('🌱 Starting database seeding process...');
    console.log('🌱 Seeding database...');
    
    console.log('💾 Verifying database connection...');
    try {
      const testQuery = await db.select({ count: sql`count(*)` }).from(users);
      console.log(`✅ Database connection verified, user count: ${testQuery[0]?.count ?? 0}`);
    } catch (dbError) {
      console.error('❌ Database connection test failed:', dbError);
      throw new Error('Database connection failed, cannot proceed with seeding');
    }
    
    // Continue with seeding

  // Insert or update admin user
  const adminEmail = 'admin@example.com';
  const password = 'admin123'; // Default password, would change in production
  
  console.log(`👤 Checking for admin user: ${adminEmail}`);
  const existingAdmin = await db.select().from(users).where(eq(users.email, adminEmail));
  
  if (existingAdmin.length === 0) {
    console.log('👤 Creating admin user...');
    const hashedPassword = await bcrypt.hash(password, 10);
    
    const [adminUser] = await db.insert(users).values({
      email: adminEmail,
      passwordHash: hashedPassword, // Changed from password to passwordHash to match schema
      role: 'admin'
      // Timestamps will be added automatically by SQLite defaults
    }).returning({ id: users.id });
    
    console.log(`✅ Admin user created with ID: ${adminUser.id}`);
  } else {
    console.log('ℹ️ Admin user already exists');
  }

  // Check existing APIs
  const existingApis = await db.select().from(apis);
  let apiId: number;
  
  if (existingApis.length === 0) {
    console.log('🔌 Creating sample API');
    
    try {
      // Create API config object
      const apiConfig = {
        timeout: 5000,
        retryCount: 3,
        headers: {
          'Content-Type': 'application/json'
        }
      };

      const configStr = JSON.stringify(apiConfig);
      
      // Validate with Zod schema before insertion
      const apiValues = apiInsertSchema.parse({
        name: 'example',
        slug: 'example',
        baseUrl: 'https://api.example.com',
        type: 'http',
        config: configStr,
        configHash: calculateHash(configStr),
        createdAt: new Date(),
        updatedAt: new Date()
      });
      
      const insertResult = await db.insert(apis).values(apiValues as any).returning({ id: apis.id });
      const insertedApi = insertResult[0];
      
      apiId = insertedApi.id;
      console.log(`✅ Sample API created with ID: ${apiId}`);
    } catch (error) {
      console.log('⚠️ Error creating API, checking if it already exists');
      const checkAgain = await db.select().from(apis).where(eq(apis.name, 'example'));
      if (checkAgain.length > 0) {
        apiId = checkAgain[0].id;
        console.log(`ℹ️ Found existing API with ID: ${apiId}`);
      } else {
        throw new Error('Failed to create or find API');
      }
    }
  } else {
    apiId = existingApis[0].id;
    console.log(`ℹ️ Sample API already exists with ID: ${apiId}`);
  }
  
  // Check for existing endpoints
  const existingEndpoints = await db.select().from(endpoints).where(eq(endpoints.apiId, apiId));
  
  if (existingEndpoints.length === 0) {
    console.log('🔌 Creating sample endpoint');
    
    try {
      // Create endpoint config object
      const endpointConfig = {
        timeout: 3000,
        retryCount: 1,
        headers: {}
      };
      
      const endpointConfigStr = JSON.stringify(endpointConfig);

      // Validate with Zod schema before insertion
      const endpointValues = endpointInsertSchema.parse({
        apiId,
        path: '/hello',
        method: 'GET',
        description: 'Sample endpoint',
        version: 'v1',
        config: endpointConfigStr,
        configHash: calculateHash(endpointConfigStr),
        createdAt: new Date(),
        updatedAt: new Date()
      });
      
      await db.insert(endpoints).values(endpointValues as any);
      
      console.log('✅ Sample endpoint created');
    } catch (error) {
      console.log('⚠️ Error creating endpoint:', error);
    }
  } else {
    console.log(`ℹ️ Sample endpoint already exists: ${existingEndpoints[0].path}`);
  }

  // Create additional test data if in development mode
  if (process.env.NODE_ENV === 'development') {
    console.log('💻 Creating test users for development...');
    
    // Create test users with different roles
    const testUsers: Array<{email: string, role: 'admin' | 'user'}> = [
      { email: 'user@example.com', role: 'user' },
      { email: 'admin2@example.com', role: 'admin' }
    ];
    
    for (const user of testUsers) {
      try {
        // Check if user already exists
        const existingUser = await db.select().from(users).where(eq(users.email, user.email));
        
        if (existingUser.length === 0) {
          console.log(`👤 Creating test user: ${user.email} with role: ${user.role}`);
          const hashedPassword = await bcrypt.hash('password123', 10);
          
          try {
            const [newUser] = await db.insert(users).values({
              email: user.email,
              passwordHash: hashedPassword,
              role: user.role
              // Timestamps will be added automatically by SQLite defaults
            }).returning({ id: users.id });
            
            console.log(`✅ Test user created with ID: ${newUser.id}`);
            
            // Add permission for user role
            if (user.role === 'user') {
              try {
                await db.insert(permissions).values({
                  userId: newUser.id,
                  resource: 'api:example',
                  action: 'read'
                });
                
                console.log(`✅ Basic API permissions added for user: ${user.email}`);
              } catch (permError) {
                console.log(`⚠️ Error adding permission for user ${user.email}:`, permError);
              }
            }
          } catch (userInsertError) {
            console.log(`⚠️ Error creating user ${user.email}:`, userInsertError);
          }
        } else {
          console.log(`ℹ️ Test user already exists: ${user.email}`);
          
          // Check if user has permissions if it's a regular user
          if (user.role === 'user') {
            const userId = existingUser[0].id;
            const existingPermissions = await db.select().from(permissions)
              .where(eq(permissions.userId, userId));
              
            if (existingPermissions.length === 0) {
              console.log(`ℹ️ Adding missing permissions for existing user: ${user.email}`);
              
              try {
                await db.insert(permissions).values({
                  userId,
                  resource: 'api:example',
                  action: 'read'
                });
                
                console.log(`✅ Read permission for logs added to existing user: ${user.email}`);
              } catch (permError) {
                console.log(`⚠️ Error adding permission for existing user ${user.email}:`, permError);
              }
            } else {
              console.log(`ℹ️ Permissions already exist for user: ${user.email}`);
            }
          }
        }
      } catch (error) {
        console.error(`❌ Error processing test user ${user.email}:`, error);
      }
    }
  }
  
  console.log('🌱 Seed completed successfully');
  } catch (error) {
    console.error('❌ Error during seeding:', error);
    throw error; // Re-throw so the calling function can handle it
  }
}

// Run the seed function if this script is executed directly
// Use import.meta.url for ES modules
const isMainModule = import.meta.url.endsWith(process.argv[1].replace(/\\/g, '/'));

if (isMainModule) {
  seed().catch((error: unknown) => {
    console.error('❌ Seed failed:', error);
    process.exit(1);
  });
}

// Export for programmatic usage
export { seed };
```


### `backend\src\scripts\test-db.ts`

```ts
// Database connection test script
import { db } from '../db/index.js';
import { users, permissions, apis, endpoints } from '../db/schema.js';
import { sql } from 'drizzle-orm';
import fs from 'node:fs';
import path from 'node:path';
import process from 'node:process';

async function testDatabaseConnection() {
  try {
    console.log('🔍 Testing database connection...');
    
    // Test basic query
    const tablesQuery = await db.select({
      name: sql`name`,
    }).from(sql`sqlite_master`)
      .where(sql`type = 'table'`);
    
    console.log('📋 Database tables found:', tablesQuery.map(t => t.name).join(', '));
    
    // Try accessing the users table
    try {
      const usersCount = await db.select({ count: sql`count(*)` }).from(users);
      console.log(`👤 Users table exists with ${usersCount[0]?.count ?? 0} records`);
    } catch (error) {
      console.error('❌ Error accessing users table:', error);
    }
    
    // Check schema tables
    console.log('\n📊 Checking all schema tables:');
    
    const tables = [
      { name: 'users', table: users },
      { name: 'permissions', table: permissions },
      { name: 'apis', table: apis },
      { name: 'endpoints', table: endpoints }
    ];
    
    for (const table of tables) {
      try {
        const count = await db.select({ count: sql`count(*)` }).from(table.table);
        console.log(`✅ ${table.name} table exists with ${count[0]?.count ?? 0} records`);
      } catch (error) {
        console.error(`❌ Error accessing ${table.name} table:`, error);
      }
    }
    
    console.log('\n✅ Database connection test completed');
    
  } catch (error) {
    console.error('❌ Database connection test failed:', error);
  }
}

// Run the test function
testDatabaseConnection().catch(console.error);
```


### `backend\src\utils\fs-utils.ts`

```ts
import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * Ensures that a directory exists, creating it and any parent directories if needed
 */
export async function ensureDirectoryExists(dirPath: string): Promise<void> {
  try {
    await fs.access(dirPath);
  } catch (error) {
    // Directory doesn't exist, create it recursively
    await fs.mkdir(dirPath, { recursive: true });
  }
}

/**
 * Checks if a file exists
 */
export async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Creates a backup of a file before modifying it
 */
export async function createFileBackup(filePath: string): Promise<string> {
  if (!(await fileExists(filePath))) {
    throw new Error(`File not found: ${filePath}`);
  }
  
  const timestamp = new Date().toISOString().replace(/[:\.]/g, '-');
  const backupPath = `${filePath}.${timestamp}.bak`;
  
  await fs.copyFile(filePath, backupPath);
  return backupPath;
}

/**
 * Safely writes content to a file, creating a backup if the file exists
 */
export async function safeWriteFile(filePath: string, content: string): Promise<void> {
  // Ensure the directory exists
  const dirPath = path.dirname(filePath);
  await ensureDirectoryExists(dirPath);
  
  // Create backup if file exists
  if (await fileExists(filePath)) {
    await createFileBackup(filePath);
  }
  
  // Write the file
  await fs.writeFile(filePath, content, 'utf8');
}

/**
 * Deletes a file if it exists
 */
export async function deleteFileIfExists(filePath: string): Promise<boolean> {
  try {
    await fs.unlink(filePath);
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Reads a directory and returns all files with specific extension
 */
export async function findFilesByExtension(dirPath: string, extension: string): Promise<string[]> {
  const files = await fs.readdir(dirPath, { withFileTypes: true });
  
  const result: string[] = [];
  
  for (const file of files) {
    const fullPath = path.join(dirPath, file.name);
    
    if (file.isDirectory()) {
      // Recursively search subdirectories
      const subResults = await findFilesByExtension(fullPath, extension);
      result.push(...subResults);
    } else if (file.isFile() && file.name.endsWith(extension)) {
      result.push(fullPath);
    }
  }
  
  return result;
}

/**
 * Gets the size of a file in bytes
 */
export async function getFileSize(filePath: string): Promise<number> {
  const stats = await fs.stat(filePath);
  return stats.size;
}

/**
 * Gets the last modified time of a file
 */
export async function getFileModifiedTime(filePath: string): Promise<Date> {
  const stats = await fs.stat(filePath);
  return stats.mtime;
}
```


### `backend\src\utils\fs.ts`

```ts
/**
 * Filesystem utility functions
 */
import { access } from 'fs/promises';

/**
 * Check if a file or directory exists
 * @param path Path to check
 * @returns True if exists, false if not
 */
export async function exists(path: string): Promise<boolean> {
  try {
    await access(path);
    return true;
  } catch {
    return false;
  }
}
```


### `backend\src\webhooks\index.ts`

```ts
import { db } from '../db/index.ts';
import * as schema from '../db/schema.ts';
import { withReadQuery } from '../db/transactions.ts';
import { createLogger } from '../logging/index.ts';
import { eq, and } from 'drizzle-orm';
import process from 'node:process';

// Logger for webhook operations
const logger = createLogger('webhook');

// Types
export type WebhookEvent = 'api.request' | 'api.response' | 'cache.hit' | 'cache.miss' | 'error' | 'retry' | 'system';

export interface WebhookPayload {
  event: WebhookEvent;
  timestamp: string;
  source: string;
  data: Record<string, unknown>;
}

export interface WebhookDeliveryResult {
  success: boolean;
  statusCode?: number;
  response?: unknown;
  error?: string;
}

/**
 * Send a webhook notification to registered subscribers
 * @param event - Type of event
 * @param source - Source of the event
 * @param data - Event data
 * @returns Promise resolving to an array of delivery results
 */
export async function sendWebhook(
  event: WebhookEvent, 
  source: string, 
  data: Record<string, unknown>
): Promise<WebhookDeliveryResult[]> {
  try {
    // Create webhook payload
    const payload: WebhookPayload = {
      event,
      timestamp: new Date().toISOString(),
      source,
      data
    };

    // Find webhook subscribers for this event
    const subscribers = await withReadQuery(null, 'webhooks', async () => {
      return await db
        .select()
        .from(schema.webhooks)
        .where(
          and(
            eq(schema.webhooks.event, event),
            eq(schema.webhooks.active, true)
          )
        );
    });

    if (!subscribers || subscribers.length === 0) {
      logger.debug(`No active subscribers for event ${event}`);
      return [];
    }

    logger.info(`Sending ${event} webhook to ${subscribers.length} subscribers`, { source });

    // Send webhook to all subscribers in parallel
    const results = await Promise.all(
      subscribers.map(async (subscriber) => {
        try {
          return await deliverWebhook(subscriber.url, payload, subscriber.secret);
        } catch (error) {
          logger.error(`Failed to deliver webhook to ${subscriber.url}`, { error });
          return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
          };
        }
      })
    );

    // Record delivery attempts
    await recordDeliveryAttempts(event, subscribers, results);
    
    return results;
  } catch (error) {
    logger.error(`Error in webhook processing`, { error, event });
    return [{
      success: false,
      error: error instanceof Error ? error.message : String(error)
    }];
  }
}

/**
 * Register a new webhook subscription
 * @param url - Webhook URL to call
 * @param event - Event to subscribe to
 * @param secret - Optional secret for webhook signing
 * @returns Created webhook subscription
 */
export async function registerWebhook(
  url: string, 
  event: WebhookEvent, 
  secret?: string
): Promise<typeof schema.webhooks.$inferSelect> {
  try {
    logger.info(`Registering webhook for ${event} events to ${url}`);
    
    const [webhook] = await db.insert(schema.webhooks)
      .values({
        url,
        event,
        secret: secret || null,
        active: true,
        createdAt: new Date(),
        updatedAt: new Date()
      })
      .returning();
    
    return webhook;
  } catch (error) {
    logger.error(`Failed to register webhook`, { url, event, error });
    throw error;
  }
}

/**
 * Deliver a webhook payload to a subscriber
 * @param url - Webhook URL
 * @param payload - Webhook payload
 * @param secret - Optional secret for signing the payload
 * @returns Webhook delivery result
 */
async function deliverWebhook(
  url: string, 
  payload: WebhookPayload,
  secret?: string | null
): Promise<WebhookDeliveryResult> {
  const startTime = Date.now();
  
  try {
    // Create headers
    const headers: HeadersInit = {
      'Content-Type': 'application/json',
      'User-Agent': 'DCR-Webhook/1.0',
      'X-DCR-Event': payload.event,
      'X-DCR-Delivery': crypto.randomUUID()
    };
    
    // If secret is provided, sign the payload
    if (secret) {
      const signature = await signPayload(payload, secret);
      headers['X-DCR-Signature'] = signature;
    }
    
    // Send the webhook
    const response = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify(payload),
      // Reasonable timeout for webhook delivery
      signal: AbortSignal.timeout(5000)
    });
    
    // Process response
    const responseData = await response.text();
    const elapsed = Date.now() - startTime;
    
    if (response.ok) {
      logger.debug(`Webhook delivered to ${url} in ${elapsed}ms`, {
        statusCode: response.status
      });
      
      return {
        success: true,
        statusCode: response.status,
        response: responseData
      };
    } else {
      logger.warn(`Webhook to ${url} failed with status ${response.status}`, {
        statusCode: response.status,
        response: responseData
      });
      
      return {
        success: false,
        statusCode: response.status,
        response: responseData,
        error: `HTTP error ${response.status}`
      };
    }
  } catch (error) {
    const elapsed = Date.now() - startTime;
    logger.error(`Webhook delivery to ${url} failed after ${elapsed}ms`, { error });
    
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}

/**
 * Sign webhook payload with a secret
 * @param payload - Webhook payload
 * @param secret - Secret key
 * @returns Signature string
 */
async function signPayload(payload: WebhookPayload, secret: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(JSON.stringify(payload));
  const keyData = encoder.encode(secret);
  
  // Create a key from the secret
  const key = await crypto.subtle.importKey(
    'raw',
    keyData,
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  );
  
  // Sign the payload
  const signature = await crypto.subtle.sign('HMAC', key, data);
  
  // Convert to hex string
  return Array.from(new Uint8Array(signature))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

/**
 * Record webhook delivery attempts in the database
 */
async function recordDeliveryAttempts(
  event: WebhookEvent,
  subscribers: typeof schema.webhooks.$inferSelect[],
  results: WebhookDeliveryResult[]
): Promise<void> {
  try {
    // Skip if no logs to record
    if (subscribers.length === 0) return;
    
    // Bulk insert delivery logs
    await db.insert(schema.webhookLogs).values(
      subscribers.map((subscriber, index) => ({
        webhookId: subscriber.id,
        event,
        success: results[index].success,
        statusCode: results[index].statusCode || null,
        responseData: results[index].response 
          ? JSON.stringify(results[index].response).substring(0, 1000)
          : null,
        errorMessage: results[index].error || null,
        timestamp: new Date()
      }))
    );
  } catch (error) {
    logger.error(`Failed to record webhook delivery attempts`, { error });
    // Non-critical error, don't throw
  }
}
```


### `docs\examples\Ally Code Webally API.postman_collection.json`

```json
{
	"info": {
		"_postman_id": "a6f7fceb-e700-4a89-bd2d-b763b0f35060",
		"name": "Ally Code Webally API",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "9351366"
	},
	"item": [
		{
			"name": "Get Project Info",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/info?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"info"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Get Project Stack",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/stack?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"stack"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Get Project Specification",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/spec?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"spec"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Get Project Tasks",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/tasks?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"tasks"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Get Project Config Files",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/config?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"config"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Get Project Files by Category",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/code?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"code"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "List All Modules",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/code/modules?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"code",
						"modules"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Get Specific Module Files",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/code/module/{{identifier}}?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"code",
						"module",
						"{{identifier}}"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				},
				"description": "Replace {{identifier}} with the module id or slug."
			},
			"response": []
		},
		{
			"name": "List All Components",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/code/components?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"code",
						"components"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Get Specific Component Code",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/code/component/{{identifier}}?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"code",
						"component",
						"{{identifier}}"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				},
				"description": "Replace {{identifier}} with the component identifier."
			},
			"response": []
		},
		{
			"name": "List Documentation",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/docs?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"docs"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Get Specific Documentation",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/docs/{{identifier}}?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"docs",
						"{{identifier}}"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				},
				"description": "Replace {{identifier}} with the documentation identifier."
			},
			"response": []
		},
		{
			"name": "Get Project Styles",
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Authorization",
						"value": "Bearer {{api_key}}"
					}
				],
				"url": {
					"raw": "{{base_url}}/{{project_name}}/code/styles?in=json",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"{{project_name}}",
						"code",
						"styles"
					],
					"query": [
						{
							"key": "in",
							"value": "json"
						}
					]
				}
			},
			"response": []
		}
	],
	"auth": {
		"type": "bearer"
	},
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "base_url",
			"value": "https://ally.code.webally.co.za"
		},
		{
			"key": "api_key",
			"value": "6b49e83f-c2a7-4d1d-9e5d-7f12c3e8567a"
		},
		{
			"key": "project_name",
			"value": "peche"
		}
	]
}
```


### `docs\examples\Document Processing API.postman_collection.json`

```json
{
	"info": {
		"_postman_id": "115a7b80-13bf-4b94-b50d-850523d685fd",
		"name": "Document Processing API",
		"description": "Collection for the Document Processing System API",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "9351366"
	},
	"item": [
		{
			"name": "Authentication",
			"item": [
				{
					"name": "Login",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"username\": \"admin\",\n    \"password\": \"password123\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/auth/login",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"auth",
								"login"
							]
						},
						"description": "Authenticate user and get token"
					},
					"response": []
				},
				{
					"name": "Verify Token",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							}
						],
						"url": {
							"raw": "{{baseUrl}}/auth/verify",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"auth",
								"verify"
							]
						},
						"description": "Verify that the authentication token is valid"
					},
					"response": []
				}
			],
			"description": "Authentication endpoints"
		},
		{
			"name": "Commands",
			"item": [
				{
					"name": "List Commands",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							}
						],
						"url": {
							"raw": "{{baseUrl}}/commands",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"commands"
							]
						},
						"description": "Get a list of all available commands"
					},
					"response": []
				},
				{
					"name": "Get Status",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							}
						],
						"url": {
							"raw": "{{baseUrl}}/status",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"status"
							]
						},
						"description": "Get the current session status"
					},
					"response": []
				}
			],
			"description": "Command-related endpoints"
		},
		{
			"name": "Processing",
			"item": [
				{
					"name": "Import File",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "file_path",
									"value": "/path/to/data.csv",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{baseUrl}}/run/import",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"run",
								"import"
							]
						},
						"description": "Import a file by path on the server"
					},
					"response": []
				},
				{
					"name": "Upload File",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							}
						],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "file",
									"type": "file",
									"src": "/path/to/local/data.csv"
								}
							]
						},
						"url": {
							"raw": "{{baseUrl}}/run/import-upload",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"run",
								"import-upload"
							]
						},
						"description": "Upload and import a file"
					},
					"response": []
				},
				{
					"name": "Validate Data",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{}"
						},
						"url": {
							"raw": "{{baseUrl}}/run/validate",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"run",
								"validate"
							]
						},
						"description": "Validate imported data"
					},
					"response": []
				},
				{
					"name": "Generate Mapping",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{}"
						},
						"url": {
							"raw": "{{baseUrl}}/run/map",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"run",
								"map"
							]
						},
						"description": "Generate field mapping"
					},
					"response": []
				},
				{
					"name": "Generate HTML",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{}"
						},
						"url": {
							"raw": "{{baseUrl}}/run/html",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"run",
								"html"
							]
						},
						"description": "Generate HTML files"
					},
					"response": []
				},
				{
					"name": "Generate PDF",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{}"
						},
						"url": {
							"raw": "{{baseUrl}}/run/pdf",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"run",
								"pdf"
							]
						},
						"description": "Generate PDF files"
					},
					"response": []
				}
			],
			"description": "Document processing endpoints"
		},
		{
			"name": "Logs",
			"item": [
				{
					"name": "Get Logs",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							}
						],
						"url": {
							"raw": "{{baseUrl}}/logs",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"logs"
							]
						},
						"description": "Get a list of all log directories"
					},
					"response": []
				},
				{
					"name": "Get Log Info",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							}
						],
						"url": {
							"raw": "{{baseUrl}}/logs/{{logHash}}",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"logs",
								"{{logHash}}"
							]
						},
						"description": "Get information about a specific log directory"
					},
					"response": []
				},
				{
					"name": "Rename Log",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"name\": \"March Payment Advices\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/logs/{{logHash}}/rename",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"logs",
								"{{logHash}}",
								"rename"
							]
						},
						"description": "Rename a log directory"
					},
					"response": []
				}
			],
			"description": "Log management endpoints"
		},
		{
			"name": "Users",
			"item": [
				{
					"name": "Get Users",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							}
						],
						"url": {
							"raw": "{{baseUrl}}/users",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users"
							]
						},
						"description": "Get a list of all users"
					},
					"response": []
				},
				{
					"name": "Create User",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-API-Key",
								"value": "{{apiKey}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"username\": \"newuser\",\n    \"password\": \"password123\",\n    \"role\": \"user\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users"
							]
						},
						"description": "Create a new user"
					},
					"response": []
				}
			],
			"description": "User management endpoints"
		}
	],
	"auth": {
		"type": "apikey",
		"apikey": [
			{
				"key": "value",
				"value": "{{apiKey}}",
				"type": "string"
			},
			{
				"key": "key",
				"value": "X-API-Key",
				"type": "string"
			}
		]
	},
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "baseUrl",
			"value": "http://localhost:8000",
			"type": "string"
		},
		{
			"key": "apiKey",
			"value": "4334.4334",
			"type": "string"
		},
		{
			"key": "logHash",
			"value": "ce65e00a455ca83cf53c6a687daa45ff52c0cd6732deae7c682beb3e5b60bbb3",
			"type": "string"
		}
	]
}
```


### `frontend\src\hooks\use-mobile.tsx`

```tsx
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
```


### `frontend\src\layouts\DashboardLayout.tsx`

```tsx
import { Link, Outlet } from "react-router-dom";
import { ThemeToggle } from "@/components/theme-toggle";
import { cn } from "@/lib/utils";
import { 
  LayoutDashboard, 
  Settings, 
  Layers, 
  FileText, 
  Calendar, 
  Users, 
  LogOut, 
  PuzzleIcon,
  RefreshCw
} from "lucide-react";
// Button component replaced with regular buttons
import { ScrollArea } from "@/components/ui/scroll-area";

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { useState } from "react";

interface SidebarNavProps extends React.HTMLAttributes<HTMLElement> {
  items: {
    href: string;
    title: string;
    icon: React.ReactNode;
  }[];
}

export function SidebarNav({ className, items, ...props }: SidebarNavProps) {
  return (
    <nav className={cn("flex flex-col", className)} {...props}>
      {items.map((item) => {
        return (
          <Link 
            key={item.href} 
            to={item.href} 
            className="flex h-10 items-center justify-start px-4 py-2 my-1 w-full rounded-md text-sm font-medium transition-colors hover:bg-sidebar-accent/20 hover:text-sidebar-foreground"
          >
            <span className="mr-2">{item.icon}</span>
            {item.title}
          </Link>
        );
      })}
    </nav>
  );
}

export default function DashboardLayout() {
  const [collapsed, setCollapsed] = useState(false);

  const sidebarNavItems = [
    {
      title: "Dashboard",
      href: "/",
      icon: <LayoutDashboard className="h-5 w-5" />,
    },
    {
      title: "Orchestrator",
      href: "/orchestrator",
      icon: <Layers className="h-5 w-5" />,
    },
    {
      title: "Plugins",
      href: "/plugins",
      icon: <PuzzleIcon className="h-5 w-5" />,
    },
    {
      title: "Logs",
      href: "/logs",
      icon: <FileText className="h-5 w-5" />,
    },
    {
      title: "Scheduler",
      href: "/scheduler",
      icon: <Calendar className="h-5 w-5" />,
    },
    {
      title: "Users",
      href: "/users",
      icon: <Users className="h-5 w-5" />,
    },
    {
      title: "Settings",
      href: "/settings",
      icon: <Settings className="h-5 w-5" />,
    },
  ];

  return (
    <div className="min-h-screen flex flex-col md:flex-row bg-background text-foreground">
      {/* Sidebar */}
      <aside
        className={cn(
          "bg-sidebar border-r border-sidebar-border flex flex-col",
          collapsed ? "w-16" : "w-64"
        )}
      >
        {/* Logo */}
        <div className="h-16 flex items-center px-4 border-b border-sidebar-border">
          <h1 className={cn("font-bold text-lg text-sidebar-foreground", 
            collapsed && "sr-only"
          )}>
            DCR Dashboard
          </h1>
          {collapsed && <span className="text-xl font-bold">DCR</span>}
          <button
            className="ml-auto p-2 rounded-md hover:bg-sidebar-accent/20 transition-colors"
            onClick={() => setCollapsed(!collapsed)}
          >
            <svg
              width="15"
              height="15"
              viewBox="0 0 15 15"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
              className="h-4 w-4 rotate-180"
            >
              <path
                d="M8.84182 3.13514C9.04327 3.32401 9.05348 3.64042 8.86462 3.84188L5.43521 7.49991L8.86462 11.1579C9.05348 11.3594 9.04327 11.6758 8.84182 11.8647C8.64036 12.0535 8.32394 12.0433 8.13508 11.8419L4.38508 7.84188C4.20477 7.64955 4.20477 7.35027 4.38508 7.15794L8.13508 3.15794C8.32394 2.95648 8.64036 2.94628 8.84182 3.13514Z"
                fill="currentColor"
                fillRule="evenodd"
                clipRule="evenodd"
              ></path>
            </svg>
          </button>
        </div>

        {/* Navigation */}
        <div className="flex-1 flex flex-col">
          <ScrollArea className="py-4">
            <SidebarNav
              items={sidebarNavItems}
              className={cn("px-2", collapsed && "items-center")}
            />
          </ScrollArea>
        </div>

        {/* User */}
        <div className="mt-auto p-4 border-t border-sidebar-border">
          <div className="flex items-center gap-3">
            <Avatar className="h-9 w-9">
              <AvatarImage src="/avatar.jpg" alt="User" />
              <AvatarFallback>AD</AvatarFallback>
            </Avatar>
            {!collapsed && (
              <div className="space-y-1">
                <p className="text-sm font-medium leading-none text-sidebar-foreground">
                  Admin User
                </p>
                <p className="text-xs leading-none text-sidebar-foreground/70">
                  admin@example.com
                </p>
              </div>
            )}
            {!collapsed && (
              <button className="ml-auto p-2 rounded-md hover:bg-sidebar-accent/20 transition-colors">
                <LogOut className="h-5 w-5" />
              </button>
            )}
          </div>
        </div>
      </aside>

      {/* Main content */}
      <div className="flex-1 flex flex-col">
        {/* Header */}
        <header className="h-16 border-b flex items-center px-6 sticky top-0 z-10 bg-background/95 backdrop-blur">
          <div className="flex-1" />
          <div className="flex items-center gap-4">
            <button 
              className="flex items-center justify-center p-2 rounded-md border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground" 
              title="Refresh"
            >
              <RefreshCw className="h-4 w-4" />
            </button>
            <ThemeToggle />
          </div>
        </header>

        {/* Content */}
        <main className="flex-1 p-6">
          <Outlet />
        </main>
      </div>
    </div>
  );
}
```


### `frontend\src\lib\schemas\api-schema.ts`

```ts
import { z } from "zod";

// Basic schema for API endpoint headers
export const headerSchema = z.object({
  name: z.string().min(1, "Header name is required"),
  value: z.string(),
  description: z.string().optional(),
  enabled: z.boolean().default(true),
});

// Schema for a single endpoint parameter
export const parameterSchema = z.object({
  name: z.string().min(1, "Parameter name is required"),
  type: z.enum(["string", "number", "boolean", "object", "array"]),
  description: z.string().optional(),
  required: z.boolean().default(false),
  default: z.any().optional(),
});

// Schema for endpoint request body
export const requestBodySchema = z.object({
  contentType: z.string().default("application/json"),
  schema: z.record(z.any()).optional(),
  example: z.string().optional(),
});

// Schema for a single lifecycle hook
export const lifecycleHookSchema = z.object({
  phase: z.enum(["beforeRequest", "request", "afterRequest"]),
  pluginId: z.string().min(1, "Plugin ID is required"),
  enabled: z.boolean().default(true),
  config: z.record(z.any()).optional(),
});

// Schema for a response template
export const responseTemplateSchema = z.object({
  name: z.string().min(1, "Template name is required"),
  description: z.string().optional(),
  status: z.number().int().positive(),
  headers: z.array(headerSchema).optional(),
  body: z.string().optional(),
});

// Schema for a single API endpoint
export const endpointSchema = z.object({
  id: z.string().uuid().optional(),
  path: z.string().min(1, "Endpoint path is required"),
  method: z.enum(["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"]),
  description: z.string().optional(),
  enabled: z.boolean().default(true),
  authentication: z.object({
    required: z.boolean().default(false),
    type: z.enum(["none", "basic", "bearer", "apiKey", "oauth2"]).default("none"),
    config: z.record(z.any()).optional(),
  }),
  headers: z.array(headerSchema).default([]),
  parameters: z.array(parameterSchema).default([]),
  requestBody: requestBodySchema.optional(),
  targetUrl: z.string().url("Must be a valid URL"),
  caching: z.object({
    enabled: z.boolean().default(false),
    ttlSeconds: z.number().int().positive().optional(),
    strategy: z.enum(["memory", "redis"]).default("memory"),
    keyPattern: z.string().optional(),
  }),
  rateLimiting: z.object({
    enabled: z.boolean().default(false),
    requestsPerMinute: z.number().int().positive().optional(),
    burstLimit: z.number().int().positive().optional(),
  }),
  lifecycleHooks: z.array(lifecycleHookSchema).default([]),
  responseTemplates: z.array(responseTemplateSchema).default([]),
  mockResponse: z.object({
    enabled: z.boolean().default(false),
    status: z.number().int().positive().default(200),
    delay: z.number().int().nonnegative().default(0),
    headers: z.array(headerSchema).default([]),
    body: z.string().optional(),
  }),
  errorHandling: z.object({
    retryCount: z.number().int().nonnegative().default(0),
    retryDelay: z.number().int().nonnegative().default(1000),
    timeoutMs: z.number().int().positive().default(30000),
    fallbackResponse: z.object({
      status: z.number().int().positive().default(503),
      body: z.string().optional(),
    }).optional(),
  }),
});

// Schema for the entire API configuration
export const apiConfigSchema = z.object({
  id: z.string().uuid().optional(),
  name: z.string().min(1, "API name is required"),
  description: z.string().optional(),
  version: z.string().default("1.0.0"),
  basePath: z.string().startsWith("/").default("/"),
  globalHeaders: z.array(headerSchema).default([]),
  globalAuthentication: z.object({
    required: z.boolean().default(false),
    type: z.enum(["none", "basic", "bearer", "apiKey", "oauth2"]).default("none"),
    config: z.record(z.any()).optional(),
  }),
  endpoints: z.array(endpointSchema).min(1, "At least one endpoint is required"),
  tags: z.array(z.string()).default([]),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
  documentation: z.object({
    enabled: z.boolean().default(true),
    title: z.string().optional(),
    description: z.string().optional(),
    contactEmail: z.string().email().optional(),
    license: z.string().optional(),
  }),
});

// Helper type for TypeScript
export type ApiConfig = z.infer<typeof apiConfigSchema>;
export type Endpoint = z.infer<typeof endpointSchema>;
export type LifecycleHook = z.infer<typeof lifecycleHookSchema>;
```


### `frontend\src\lib\tailwind-plugin.js`

```js
// Import the animation plugin and export it in ESM format
import animate from 'tailwindcss-animate';
export default animate;
```


### `frontend\src\lib\utils.ts`

```ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```


### `frontend\src\pages\auth\ForgotPasswordPage.tsx`

```tsx
import { useState } from "react";
import { Link } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { ThemeToggle } from "@/components/theme-toggle";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { ArrowLeft, CheckCircle } from "lucide-react";

export default function ForgotPasswordPage() {
  const [isLoading, setIsLoading] = useState(false);
  const [isSubmitted, setIsSubmitted] = useState(false);

  async function onSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    setIsLoading(true);

    // This would be replaced with actual password reset logic
    setTimeout(() => {
      setIsLoading(false);
      setIsSubmitted(true);
    }, 1000);
  }

  return (
    <div className="flex min-h-screen flex-col items-center justify-center bg-background">
      <div className="absolute top-4 right-4">
        <ThemeToggle />
      </div>
      <div className="w-full max-w-md p-4 sm:p-8">
        <div className="flex flex-col text-center mb-6">
          <h1 className="text-3xl font-bold tracking-tight">DCR Dashboard</h1>
          <p className="text-sm text-muted-foreground mt-2">
            Dynamic Configuration & Request Orchestrator
          </p>
        </div>
        <Card>
          <CardHeader>
            <CardTitle className="text-2xl text-center">Reset Password</CardTitle>
            <CardDescription className="text-center">
              {!isSubmitted
                ? "Enter your email and we'll send you a link to reset your password"
                : "Check your email for a reset link"}
            </CardDescription>
          </CardHeader>
          {!isSubmitted ? (
            <form onSubmit={onSubmit}>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="email">Email</Label>
                  <Input
                    id="email"
                    type="email"
                    placeholder="example@company.com"
                    required
                    autoComplete="email"
                  />
                </div>
              </CardContent>
              <CardFooter className="flex flex-col space-y-4">
                <Button
                  className="w-full"
                  type="submit"
                  disabled={isLoading}
                >
                  {isLoading ? "Sending..." : "Send Reset Link"}
                </Button>
                <Link
                  to="/auth/login"
                  className="inline-flex items-center justify-center text-sm text-primary underline-offset-4 hover:underline"
                >
                  <ArrowLeft className="mr-2 h-4 w-4" />
                  Back to login
                </Link>
              </CardFooter>
            </form>
          ) : (
            <CardContent className="space-y-4">
              <Alert className="border-green-500/50 bg-green-500/10">
                <CheckCircle className="h-5 w-5 text-green-500" />
                <AlertDescription className="ml-2">
                  If an account exists with that email, we've sent a password reset link.
                </AlertDescription>
              </Alert>
              <Button
                className="w-full"
                variant="outline"
                onClick={() => {
                  setIsSubmitted(false);
                }}
              >
                Try another email
              </Button>
              <div className="text-center">
                <Link
                  to="/auth/login"
                  className="inline-flex items-center justify-center text-sm text-primary underline-offset-4 hover:underline"
                >
                  <ArrowLeft className="mr-2 h-4 w-4" />
                  Back to login
                </Link>
              </div>
            </CardContent>
          )}
        </Card>
      </div>
    </div>
  );
}
```


### `frontend\src\pages\auth\LoginPage.tsx`

```tsx
import { useState } from "react";
import { Link } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { ThemeToggle } from "@/components/theme-toggle";

export default function LoginPage() {
  const [isLoading, setIsLoading] = useState(false);

  async function onSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    setIsLoading(true);

    // This would be replaced with actual authentication logic
    setTimeout(() => {
      setIsLoading(false);
      // For now just redirect to dashboard
      window.location.href = "/";
    }, 1000);
  }

  return (
    <div className="flex min-h-screen flex-col items-center justify-center bg-background">
      <div className="absolute top-4 right-4">
        <ThemeToggle />
      </div>
      <div className="w-full max-w-md p-4 sm:p-8">
        <div className="flex flex-col text-center mb-6">
          <h1 className="text-3xl font-bold tracking-tight">DCR Dashboard</h1>
          <p className="text-sm text-muted-foreground mt-2">
            Dynamic Configuration & Request Orchestrator
          </p>
        </div>
        <Card>
          <CardHeader>
            <CardTitle className="text-2xl text-center">Sign In</CardTitle>
            <CardDescription className="text-center">
              Enter your credentials to access your account
            </CardDescription>
          </CardHeader>
          <form onSubmit={onSubmit}>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="email">Email</Label>
                <Input
                  id="email"
                  type="email"
                  placeholder="example@company.com"
                  required
                  autoComplete="email"
                />
              </div>
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <Label htmlFor="password">Password</Label>
                  <Link
                    to="/auth/forgot-password"
                    className="text-sm text-primary underline-offset-4 hover:underline"
                  >
                    Forgot password?
                  </Link>
                </div>
                <Input
                  id="password"
                  type="password"
                  required
                  autoComplete="current-password"
                />
              </div>
            </CardContent>
            <CardFooter className="flex flex-col">
              <Button
                className="w-full"
                type="submit"
                disabled={isLoading}
              >
                {isLoading ? "Signing in..." : "Sign In"}
              </Button>
            </CardFooter>
          </form>
        </Card>
      </div>
    </div>
  );
}
```


### `frontend\src\pages\auth\ResetPasswordPage.tsx`

```tsx
import { useState } from "react";
import { Link, useSearchParams } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { ThemeToggle } from "@/components/theme-toggle";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { CheckCircle, AlertTriangle } from "lucide-react";

export default function ResetPasswordPage() {
  const [searchParams] = useSearchParams();
  const token = searchParams.get("token");
  
  const [isLoading, setIsLoading] = useState(false);
  const [isSubmitted, setIsSubmitted] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function onSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    setIsLoading(true);
    setError(null);

    const formData = new FormData(event.currentTarget);
    const password = formData.get("password") as string;
    const confirmPassword = formData.get("confirmPassword") as string;

    // Validate passwords match
    if (password !== confirmPassword) {
      setError("Passwords do not match");
      setIsLoading(false);
      return;
    }

    // This would be replaced with actual password reset logic
    setTimeout(() => {
      setIsLoading(false);
      setIsSubmitted(true);
    }, 1000);
  }

  if (!token) {
    return (
      <div className="flex min-h-screen flex-col items-center justify-center bg-background">
        <div className="absolute top-4 right-4">
          <ThemeToggle />
        </div>
        <div className="w-full max-w-md p-4 sm:p-8">
          <Card>
            <CardHeader>
              <CardTitle className="text-2xl text-center">Invalid Link</CardTitle>
            </CardHeader>
            <CardContent>
              <Alert className="border-destructive/50 bg-destructive/10">
                <AlertTriangle className="h-5 w-5 text-destructive" />
                <AlertDescription className="ml-2">
                  This password reset link is invalid or has expired.
                </AlertDescription>
              </Alert>
            </CardContent>
            <CardFooter>
              <Link to="/auth/forgot-password" className="w-full">
                <Button className="w-full">Request New Link</Button>
              </Link>
            </CardFooter>
          </Card>
        </div>
      </div>
    );
  }

  return (
    <div className="flex min-h-screen flex-col items-center justify-center bg-background">
      <div className="absolute top-4 right-4">
        <ThemeToggle />
      </div>
      <div className="w-full max-w-md p-4 sm:p-8">
        <div className="flex flex-col text-center mb-6">
          <h1 className="text-3xl font-bold tracking-tight">DCR Dashboard</h1>
          <p className="text-sm text-muted-foreground mt-2">
            Dynamic Configuration & Request Orchestrator
          </p>
        </div>
        <Card>
          <CardHeader>
            <CardTitle className="text-2xl text-center">
              {!isSubmitted ? "Create New Password" : "Password Reset"}
            </CardTitle>
            <CardDescription className="text-center">
              {!isSubmitted
                ? "Enter your new password below"
                : "Your password has been reset successfully"}
            </CardDescription>
          </CardHeader>
          {!isSubmitted ? (
            <form onSubmit={onSubmit}>
              <CardContent className="space-y-4">
                {error && (
                  <Alert className="border-destructive/50 bg-destructive/10">
                    <AlertTriangle className="h-5 w-5 text-destructive" />
                    <AlertDescription className="ml-2">{error}</AlertDescription>
                  </Alert>
                )}
                <div className="space-y-2">
                  <Label htmlFor="password">New Password</Label>
                  <Input
                    id="password"
                    name="password"
                    type="password"
                    required
                    autoComplete="new-password"
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="confirmPassword">Confirm Password</Label>
                  <Input
                    id="confirmPassword"
                    name="confirmPassword"
                    type="password"
                    required
                    autoComplete="new-password"
                  />
                </div>
              </CardContent>
              <CardFooter className="flex flex-col">
                <Button className="w-full" type="submit" disabled={isLoading}>
                  {isLoading ? "Resetting..." : "Reset Password"}
                </Button>
              </CardFooter>
            </form>
          ) : (
            <CardContent className="space-y-4">
              <Alert className="border-green-500/50 bg-green-500/10">
                <CheckCircle className="h-5 w-5 text-green-500" />
                <AlertDescription className="ml-2">
                  Your password has been reset successfully.
                </AlertDescription>
              </Alert>
              <Link to="/auth/login" className="w-full">
                <Button className="w-full">Back to Login</Button>
              </Link>
            </CardContent>
          )}
        </Card>
      </div>
    </div>
  );
}
```


### `frontend\src\pages\dashboard\DashboardPage.tsx`

```tsx
import { useState } from "react";
import { 
  Card, 
  CardContent, 
  CardDescription, 
  CardHeader, 
  CardTitle 
} from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";

import { 
  ArrowRight, 
  CheckCircle, 
  ExternalLink, 
  RefreshCw, 
  Server, 
  Shield, 
  Database as DbIcon,
  AlertTriangle,
  Clock,
  BarChart3
} from "lucide-react";

interface SystemMetric {
  label: string;
  value: number;
  status: "healthy" | "warning" | "error";
  icon: React.ReactNode;
}

interface RecentActivity {
  id: string;
  type: string;
  description: string;
  timestamp: string;
  status: "success" | "pending" | "error";
}

export default function DashboardPage() {
  const [isRefreshing, setIsRefreshing] = useState(false);
  
  const systemMetrics: SystemMetric[] = [
    {
      label: "API Server",
      value: 98,
      status: "healthy",
      icon: <Server className="h-5 w-5" />,
    },
    {
      label: "Database",
      value: 92,
      status: "healthy",
      icon: <DbIcon className="h-5 w-5" />,
    },
    {
      label: "Cache",
      value: 88,
      status: "healthy",
      icon: <Shield className="h-5 w-5" />,
    },
    {
      label: "Log Service",
      value: 75,
      status: "warning",
      icon: <AlertTriangle className="h-5 w-5" />,
    },
  ];

  const recentActivities: RecentActivity[] = [
    {
      id: "act1",
      type: "CONFIG_UPDATE",
      description: "Payment gateway configuration updated",
      timestamp: "10 mins ago",
      status: "success",
    },
    {
      id: "act2",
      type: "API_CALL",
      description: "API request to /payment-gateway/v1/status",
      timestamp: "15 mins ago",
      status: "success",
    },
    {
      id: "act3",
      type: "PLUGIN_REGISTER",
      description: "New plugin 'Stripe Auth' registered",
      timestamp: "1 hour ago",
      status: "success",
    },
    {
      id: "act4",
      type: "API_VERSION",
      description: "Created version v2 of payment-gateway API",
      timestamp: "2 hours ago",
      status: "success",
    },
    {
      id: "act5",
      type: "API_CALL",
      description: "Failed request to /analytics/v1/reports",
      timestamp: "3 hours ago",
      status: "error",
    },
  ];
  
  function getStatusColor(status: string) {
    switch (status) {
      case "healthy":
      case "success":
        return "text-green-500";
      case "warning":
      case "pending":
        return "text-amber-500";
      case "error":
        return "text-destructive";
      default:
        return "text-muted-foreground";
    }
  }

  function getProgressColor(value: number) {
    if (value >= 90) return "bg-green-500";
    if (value >= 75) return "bg-amber-500";
    return "bg-destructive";
  }

  function refreshData() {
    setIsRefreshing(true);
    // This would be replaced with actual data fetching
    setTimeout(() => {
      setIsRefreshing(false);
    }, 1000);
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold tracking-tight">Dashboard</h1>
        <Button 
          onClick={refreshData}
          disabled={isRefreshing}
          className="bg-background border border-input hover:bg-accent hover:text-accent-foreground h-9 rounded-md px-3 text-xs"
        >
          <RefreshCw className={`h-4 w-4 mr-2 ${isRefreshing ? "animate-spin" : ""}`} />
          Refresh
        </Button>
      </div>

      <Tabs defaultValue="overview" className="space-y-6">
        <TabsList>
          <TabsTrigger value="overview">Overview</TabsTrigger>
          <TabsTrigger value="apis">APIs</TabsTrigger>
          <TabsTrigger value="plugins">Plugins</TabsTrigger>
          <TabsTrigger value="logs">Logs</TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-6">
          {/* System Health */}
          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-xl">System Health</CardTitle>
              <CardDescription>
                Current status of all system components
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
                {systemMetrics.map((metric) => (
                  <Card key={metric.label} className="border-none shadow-none">
                    <CardContent className="p-0">
                      <div className="flex items-center justify-between mb-3">
                        <div className="flex items-center gap-2">
                          <div className={getStatusColor(metric.status)}>
                            {metric.icon}
                          </div>
                          <span className="font-medium">{metric.label}</span>
                        </div>
                        <span className={`inline-flex px-2 py-0.5 rounded-full text-xs font-medium ${metric.status === "healthy" ? "bg-green-500/10 text-green-500" : metric.status === "warning" ? "bg-amber-500/10 text-amber-500" : "bg-destructive/10 text-destructive"}`}>
                          {metric.status}
                        </span>
                      </div>
                      <div className="space-y-2">
                        <div className="flex items-center justify-between">
                          <span className="text-sm text-muted-foreground">Health</span>
                          <span className="font-medium">{metric.value}%</span>
                        </div>
                        <Progress value={metric.value} className={getProgressColor(metric.value)} />
                      </div>
                    </CardContent>
                  </Card>
                ))}
              </div>
            </CardContent>
          </Card>

          {/* Stats Overview */}
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
            <Card>
              <CardHeader className="pb-2 flex flex-row items-center justify-between space-y-0">
                <CardTitle className="text-sm font-medium">Total APIs</CardTitle>
                <BarChart3 className="h-4 w-4 text-muted-foreground" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">12</div>
                <p className="text-xs text-muted-foreground mt-1">
                  +2 from last month
                </p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="pb-2 flex flex-row items-center justify-between space-y-0">
                <CardTitle className="text-sm font-medium">Active Endpoints</CardTitle>
                <CheckCircle className="h-4 w-4 text-muted-foreground" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">48</div>
                <p className="text-xs text-muted-foreground mt-1">
                  +5 from last month
                </p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="pb-2 flex flex-row items-center justify-between space-y-0">
                <CardTitle className="text-sm font-medium">Registered Plugins</CardTitle>
                <Shield className="h-4 w-4 text-muted-foreground" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">7</div>
                <p className="text-xs text-muted-foreground mt-1">
                  +1 from last month
                </p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="pb-2 flex flex-row items-center justify-between space-y-0">
                <CardTitle className="text-sm font-medium">Scheduled Tasks</CardTitle>
                <Clock className="h-4 w-4 text-muted-foreground" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">24</div>
                <p className="text-xs text-muted-foreground mt-1">
                  +3 from last month
                </p>
              </CardContent>
            </Card>
          </div>

          {/* Recent Activity */}
          <Card>
            <CardHeader className="pb-2">
              <div className="flex items-center justify-between">
                <div>
                  <CardTitle className="text-xl">Recent Activity</CardTitle>
                  <CardDescription>Latest system activities and events</CardDescription>
                </div>
                <Button className="hover:bg-accent hover:text-accent-foreground h-9 rounded-md px-3 text-xs gap-1">
                  View all <ArrowRight className="h-4 w-4" />
                </Button>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {recentActivities.map((activity) => (
                  <div key={activity.id} className="flex items-start gap-4">
                    <div className={`mt-1 rounded-full p-1 ${
                      activity.status === "success" 
                        ? "bg-green-500/20" 
                        : activity.status === "error" 
                          ? "bg-destructive/20" 
                          : "bg-amber-500/20"
                    }`}>
                      <div className={`h-2 w-2 rounded-full ${
                        activity.status === "success" 
                          ? "bg-green-500" 
                          : activity.status === "error" 
                            ? "bg-destructive" 
                            : "bg-amber-500"
                      }`} />
                    </div>
                    <div className="flex-1 space-y-1">
                      <div className="flex items-center gap-2">
                        <p className="text-sm font-medium leading-none">
                          {activity.description}
                        </p>
                        <span className="inline-flex px-2 py-0.5 rounded-full text-xs font-medium border bg-background">
                          {activity.type}
                        </span>
                      </div>
                      <p className="text-sm text-muted-foreground">
                        {activity.timestamp}
                      </p>
                    </div>
                    <Button className="hover:bg-accent hover:text-accent-foreground h-8 w-8 p-0 rounded-md">
                      <ExternalLink className="h-4 w-4" />
                    </Button>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="apis" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>API Configuration</CardTitle>
              <CardDescription>Manage your API configurations and versions</CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-muted-foreground">
                This section will show detailed API information and allow you to manage configurations.
              </p>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="plugins" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Plugin Management</CardTitle>
              <CardDescription>View and configure installed plugins</CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-muted-foreground">
                This section will show installed plugins and their status.
              </p>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="logs" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>System Logs</CardTitle>
              <CardDescription>View and search system logs</CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-muted-foreground">
                This section will show system logs with filtering capabilities.
              </p>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}
```


### `frontend\src\pages\orchestrator\ApiEditorPage.tsx`

```tsx
import { useState } from "react";
import { useParams } from "react-router-dom";
import { 
  Save, 
  Play, 
  AlertTriangle, 
  History, 
  ChevronDown,
  FileJson,
  Code
} from "lucide-react";

import JsonEditor from "@/components/editors/JsonEditor";
import { apiConfigSchema } from "@/lib/schemas/api-schema";

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";

// Sample API data (in a real app, this would come from an API)
const sampleApiConfig = {
  id: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  name: "Sample Weather API",
  description: "A sample API configuration for weather data",
  version: "1.0.0",
  basePath: "/api/weather",
  globalHeaders: [
    {
      name: "X-API-Key",
      value: "{{API_KEY}}",
      enabled: true
    }
  ],
  globalAuthentication: {
    required: false,
    type: "none"
  },
  endpoints: [
    {
      id: "6c84fb90-12c4-11e1-840d-7b25c5ee775a",
      path: "/current",
      method: "GET",
      description: "Get current weather data for a location",
      enabled: true,
      authentication: {
        required: false,
        type: "none"
      },
      headers: [],
      parameters: [
        {
          name: "location",
          type: "string",
          description: "City name or location coordinates",
          required: true
        },
        {
          name: "units",
          type: "string",
          description: "Units of measurement (metric, imperial)",
          required: false,
          default: "metric"
        }
      ],
      targetUrl: "https://api.weatherapi.com/v1/current.json",
      caching: {
        enabled: true,
        ttlSeconds: 300,
        strategy: "memory"
      },
      rateLimiting: {
        enabled: true,
        requestsPerMinute: 60
      },
      lifecycleHooks: [
        {
          phase: "beforeRequest",
          pluginId: "transform-params",
          enabled: true,
          config: {
            transforms: [
              {
                param: "location",
                transform: "lowercase"
              }
            ]
          }
        }
      ],
      responseTemplates: [],
      mockResponse: {
        enabled: false,
        status: 200,
        delay: 0,
        headers: []
      },
      errorHandling: {
        retryCount: 2,
        retryDelay: 1000,
        timeoutMs: 5000
      }
    }
  ],
  tags: ["weather", "sample"],
  createdAt: "2023-01-01T00:00:00Z",
  updatedAt: "2023-01-02T00:00:00Z",
  documentation: {
    enabled: true,
    title: "Weather API Documentation",
    description: "API for retrieving weather data",
    contactEmail: "support@example.com"
  }
};

// Sample API versions for history
const apiVersions = [
  { id: "v3", timestamp: "2023-02-15T14:23:10Z", author: "jane.doe@example.com" },
  { id: "v2", timestamp: "2023-02-10T09:45:22Z", author: "john.smith@example.com" },
  { id: "v1", timestamp: "2023-02-05T16:30:05Z", author: "john.smith@example.com" }
];

export default function ApiEditorPage() {
  useParams(); // Keep for future use when we implement real API loading
  const [apiConfig, setApiConfig] = useState(sampleApiConfig);
  const [editorContent, setEditorContent] = useState(JSON.stringify(sampleApiConfig, null, 2));
  const [isValid, setIsValid] = useState(true);
  const [validationErrors, setValidationErrors] = useState<string[]>([]);
  const [isSaving, setIsSaving] = useState(false);
  const [showVersionDialog, setShowVersionDialog] = useState(false);
  const [selectedVersion, setSelectedVersion] = useState<string | null>(null);
  
  const handleEditorChange = (value: string) => {
    setEditorContent(value);
    try {
      const parsed = JSON.parse(value);
      setApiConfig(parsed);
    } catch (e) {
      // Invalid JSON, handled by validation
    }
  };
  
  const handleValidation = (isValid: boolean) => {
    setIsValid(isValid);
    
    if (!isValid) {
      try {
        const parsed = JSON.parse(editorContent);
        const result = apiConfigSchema.safeParse(parsed);
        
        if (!result.success) {
          const errors = result.error.errors.map(err => `${err.path.join('.')}: ${err.message}`);
          setValidationErrors(errors);
        }
      } catch (e) {
        setValidationErrors(["Invalid JSON format"]);
      }
    } else {
      setValidationErrors([]);
    }
  };
  
  const handleSave = async () => {
    if (!isValid) return;
    
    setIsSaving(true);
    
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // In a real app, you would save the apiConfig to the backend
    console.log("Saving API config:", apiConfig);
    
    setIsSaving(false);
  };
  
  const handleTest = () => {
    // In a real app, this would test the API configuration
    console.log("Testing API config");
  };
  
  const handleLoadVersion = (versionId: string) => {
    setSelectedVersion(versionId);
    setShowVersionDialog(true);
  };
  
  const confirmLoadVersion = () => {
    // In a real app, this would load the selected version from the backend
    console.log(`Loading version ${selectedVersion}`);
    setShowVersionDialog(false);
  };
  
  return (
    <div className="container mx-auto py-6 space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold">{apiConfig.name}</h1>
          <p className="text-muted-foreground">
            {apiConfig.description || "No description"} • Version {apiConfig.version}
          </p>
        </div>
        
        <div className="flex space-x-2">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button className="bg-background border border-input hover:bg-accent hover:text-accent-foreground h-9 rounded-md px-3 flex items-center gap-1">
                <History className="h-4 w-4" />
                <span>History</span>
                <ChevronDown className="h-4 w-4 ml-1" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {apiVersions.map(version => (
                <DropdownMenuItem 
                  key={version.id} 
                  onClick={() => handleLoadVersion(version.id)}
                  className="flex flex-col items-start"
                >
                  <span className="font-medium">{version.id}</span>
                  <span className="text-xs text-muted-foreground">
                    {new Date(version.timestamp).toLocaleString()} by {version.author}
                  </span>
                </DropdownMenuItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
          
          <Button 
            className="flex items-center gap-1" 
            onClick={handleTest}
          >
            <Play className="h-4 w-4" />
            <span>Test</span>
          </Button>
          
          <Button 
            className="flex items-center gap-1 bg-primary text-primary-foreground hover:bg-primary/90" 
            onClick={handleSave}
            disabled={!isValid || isSaving}
          >
            <Save className="h-4 w-4" />
            <span>{isSaving ? "Saving..." : "Save"}</span>
          </Button>
        </div>
      </div>
      
      {validationErrors.length > 0 && (
        <Alert variant="destructive">
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>
            <div className="font-medium">Validation errors:</div>
            <ul className="list-disc list-inside pl-2 text-sm">
              {validationErrors.slice(0, 5).map((error, index) => (
                <li key={index}>{error}</li>
              ))}
              {validationErrors.length > 5 && (
                <li>...and {validationErrors.length - 5} more errors</li>
              )}
            </ul>
          </AlertDescription>
        </Alert>
      )}
      
      <Tabs defaultValue="json" className="w-full">
        <TabsList>
          <TabsTrigger value="json" className="flex items-center gap-1">
            <FileJson className="h-4 w-4" />
            <span>JSON Editor</span>
          </TabsTrigger>
          <TabsTrigger value="visual" className="flex items-center gap-1">
            <Code className="h-4 w-4" />
            <span>Visual Editor</span>
          </TabsTrigger>
        </TabsList>
        
        <TabsContent value="json" className="mt-4">
          <Card>
            <CardContent className="pt-6">
              <JsonEditor
                initialValue={editorContent}
                onChange={handleEditorChange}
                onValidate={handleValidation}
                schema={apiConfigSchema}
                height="600px"
              />
            </CardContent>
          </Card>
        </TabsContent>
        
        <TabsContent value="visual" className="mt-4">
          <Card>
            <CardHeader>
              <CardTitle>Visual Editor</CardTitle>
              <CardDescription>
                Edit API configuration using a visual interface
              </CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-muted-foreground italic">
                Visual editor is not implemented yet. Please use the JSON editor for now.
              </p>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
      
      {/* Version Loading Dialog */}
      <Dialog open={showVersionDialog} onOpenChange={setShowVersionDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Load API Version</DialogTitle>
            <DialogDescription>
              Are you sure you want to load version {selectedVersion}? Unsaved changes will be lost.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button 
              className="bg-background border border-input hover:bg-accent hover:text-accent-foreground" 
              onClick={() => setShowVersionDialog(false)}
            >
              Cancel
            </Button>
            <Button onClick={confirmLoadVersion}>
              Load Version
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
```


### `frontend\src\pages\orchestrator\ApiImportPage.tsx`

```tsx
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import {
  ArrowLeft,
  Upload,
  FileJson,
  AlertCircle,
  CheckCircle,
  Loader2,
} from "lucide-react";

import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "@/components/ui/tabs";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Alert,
  AlertDescription,
  AlertTitle,
} from "@/components/ui/alert";
import { Progress } from "@/components/ui/progress";

interface ImportedEndpoint {
  path: string;
  method: string;
  description?: string;
  params?: any[];
  headers?: any[];
  valid: boolean;
}

interface ParsedCollection {
  name: string;
  description?: string;
  baseUrl?: string;
  endpoints: ImportedEndpoint[];
}

export default function ApiImportPage() {
  const navigate = useNavigate();
  const [importMethod, setImportMethod] = useState<"file" | "json">("file");
  const [file, setFile] = useState<File | null>(null);
  const [jsonInput, setJsonInput] = useState("");
  const [isImporting, setIsImporting] = useState(false);
  const [importProgress, setImportProgress] = useState(0);
  const [importError, setImportError] = useState<string | null>(null);
  const [parsedCollection, setParsedCollection] = useState<ParsedCollection | null>(null);
  const [importComplete, setImportComplete] = useState(false);
  
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      setFile(e.target.files[0]);
      setImportError(null);
    }
  };
  
  const handleJsonInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setJsonInput(e.target.value);
    setImportError(null);
  };
  
  const parsePostmanCollection = (json: any): ParsedCollection | null => {
    try {
      // Basic validation
      if (!json.info || !json.info.name || !json.item || !Array.isArray(json.item)) {
        throw new Error("Invalid Postman collection format");
      }
      
      const collection: ParsedCollection = {
        name: json.info.name,
        description: json.info.description?.content || json.info.description,
        baseUrl: json.variable?.find((v: any) => v.key === "baseUrl")?.value || "",
        endpoints: []
      };
      
      // Process all items (folders and requests)
      const processItems = (items: any[], basePath = "") => {
        items.forEach(item => {
          if (item.item && Array.isArray(item.item)) {
            // This is a folder
            const folderPath = basePath + (basePath ? "/" : "") + item.name;
            processItems(item.item, folderPath);
          } else if (item.request) {
            // This is an endpoint
            const request = item.request;
            const method = request.method || "GET";
            
            // Handle path
            let path = "";
            if (typeof request.url === "string") {
              path = request.url;
            } else if (request.url && request.url.path) {
              path = Array.isArray(request.url.path) 
                ? request.url.path.join("/") 
                : request.url.path;
            }
            
            // Format path
            if (path && !path.startsWith("/")) {
              path = "/" + path;
            }
            
            if (basePath) {
              path = "/" + basePath + path;
            }
            
            // Extract headers
            const headers = request.header?.map((h: any) => ({
              key: h.key,
              value: h.value,
              enabled: h.disabled !== true
            })) || [];
            
            // Extract params
            const params = request.url?.query?.map((p: any) => ({
              key: p.key,
              value: p.value,
              enabled: p.disabled !== true
            })) || [];
            
            collection.endpoints.push({
              path,
              method,
              description: item.name || "",
              headers,
              params,
              valid: !!path && !!method
            });
          }
        });
      };
      
      processItems(json.item);
      return collection;
    } catch (err) {
      console.error("Error parsing Postman collection:", err);
      setImportError(err instanceof Error ? err.message : "Failed to parse collection");
      return null;
    }
  };
  
  const handleParseCollection = async () => {
    setImportError(null);
    setIsImporting(true);
    setImportProgress(10);
    
    try {
      let jsonData: any;
      
      // Get JSON content based on import method
      if (importMethod === "file") {
        if (!file) {
          throw new Error("Please select a file to import");
        }
        
        const fileContent = await file.text();
        setImportProgress(30);
        try {
          jsonData = JSON.parse(fileContent);
        } catch (err) {
          throw new Error("Invalid JSON file. Please check the file format.");
        }
      } else {
        if (!jsonInput.trim()) {
          throw new Error("Please enter JSON content to import");
        }
        
        try {
          jsonData = JSON.parse(jsonInput);
        } catch (err) {
          throw new Error("Invalid JSON content. Please check the format.");
        }
      }
      
      setImportProgress(50);
      
      // Parse the collection
      const collection = parsePostmanCollection(jsonData);
      setImportProgress(80);
      
      if (!collection) {
        throw new Error("Failed to parse Postman collection");
      }
      
      if (collection.endpoints.length === 0) {
        throw new Error("No valid endpoints found in the collection");
      }
      
      setParsedCollection(collection);
      setImportProgress(100);
      setImportComplete(true);
    } catch (err) {
      setImportError(err instanceof Error ? err.message : "An unknown error occurred");
    } finally {
      setIsImporting(false);
    }
  };
  
  const handleImport = () => {
    // In a real implementation, this would make an API call to the backend
    // to create the API and endpoints in the database
    console.log("Importing API:", parsedCollection);
    
    // Mock success - in a real app, navigate after successful API response
    setTimeout(() => {
      navigate("/orchestrator/apis");
    }, 1000);
  };
  
  const goBack = () => {
    navigate("/orchestrator/apis");
  };
  
  return (
    <div className="container py-6 max-w-5xl">
      <div className="mb-6">
        <Button 
          variant="ghost" 
          onClick={goBack}
          className="gap-2"
        >
          <ArrowLeft className="h-4 w-4" />
          Back to APIs
        </Button>
      </div>
      
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Import API</CardTitle>
          <CardDescription>
            Import an existing API from a Postman Collection (v2.1)
          </CardDescription>
        </CardHeader>
        <CardContent>
          {!importComplete ? (
            <>
              <Tabs value={importMethod} onValueChange={(v) => setImportMethod(v as "file" | "json")}>
                <TabsList className="mb-4">
                  <TabsTrigger value="file" className="flex items-center gap-2">
                    <Upload className="h-4 w-4" />
                    Upload File
                  </TabsTrigger>
                  <TabsTrigger value="json" className="flex items-center gap-2">
                    <FileJson className="h-4 w-4" />
                    Paste JSON
                  </TabsTrigger>
                </TabsList>
                
                <TabsContent value="file">
                  <div className="grid gap-4">
                    <Label htmlFor="import-file">Postman Collection File</Label>
                    <Input 
                      id="import-file" 
                      type="file" 
                      accept=".json,application/json" 
                      onChange={handleFileChange}
                      disabled={isImporting}
                    />
                    <p className="text-sm text-muted-foreground">
                      Upload a Postman Collection v2.1 JSON file
                    </p>
                  </div>
                </TabsContent>
                
                <TabsContent value="json">
                  <div className="grid gap-4">
                    <Label htmlFor="json-content">Postman Collection JSON</Label>
                    <Textarea 
                      id="json-content" 
                      placeholder='Paste your Postman Collection JSON here...'
                      className="min-h-[200px] font-mono text-sm"
                      onChange={handleJsonInputChange}
                      disabled={isImporting}
                    />
                  </div>
                </TabsContent>
              </Tabs>
              
              {importError && (
                <Alert className="mt-4 border-destructive/50 text-destructive">
                  <AlertCircle className="h-4 w-4" />
                  <AlertTitle>Error</AlertTitle>
                  <AlertDescription>{importError}</AlertDescription>
                </Alert>
              )}
              
              {isImporting && (
                <div className="mt-6">
                  <div className="flex items-center gap-2 mb-2">
                    <Loader2 className="h-4 w-4 animate-spin" />
                    <span>Processing collection...</span>
                  </div>
                  <Progress value={importProgress} className="h-2" />
                </div>
              )}
            </>
          ) : (
            <>
              <Alert className="mb-6">
                <CheckCircle className="h-4 w-4" />
                <AlertTitle>Collection Parsed Successfully</AlertTitle>
                <AlertDescription>
                  Found {parsedCollection?.endpoints.length} endpoints in the collection.
                </AlertDescription>
              </Alert>
              
              <div className="grid gap-4 mb-6">
                <div>
                  <h3 className="text-lg font-medium">API Details</h3>
                  <div className="grid grid-cols-2 gap-4 mt-2">
                    <div>
                      <Label>Name</Label>
                      <p className="text-sm font-medium">{parsedCollection?.name}</p>
                    </div>
                    {parsedCollection?.baseUrl && (
                      <div>
                        <Label>Base URL</Label>
                        <p className="text-sm font-medium">{parsedCollection?.baseUrl}</p>
                      </div>
                    )}
                    {parsedCollection?.description && (
                      <div className="col-span-2">
                        <Label>Description</Label>
                        <p className="text-sm">{parsedCollection?.description}</p>
                      </div>
                    )}
                  </div>
                </div>
                
                <div>
                  <h3 className="text-lg font-medium mb-2">Endpoints</h3>
                  <div className="border rounded-md">
                    <Table>
                      <TableHeader>
                        <TableRow>
                          <TableHead>Method</TableHead>
                          <TableHead>Path</TableHead>
                          <TableHead>Description</TableHead>
                          <TableHead>Status</TableHead>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {parsedCollection?.endpoints.map((endpoint, index) => (
                          <TableRow key={`${endpoint.method}-${endpoint.path}-${index}`}>
                            <TableCell>
                              <div 
                                className={`inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold 
                                  ${endpoint.method === "GET" ? "bg-blue-500/10 text-blue-600 border-blue-200" :
                                  endpoint.method === "POST" ? "bg-green-500/10 text-green-600 border-green-200" :
                                  endpoint.method === "PUT" ? "bg-amber-500/10 text-amber-600 border-amber-200" :
                                  endpoint.method === "DELETE" ? "bg-red-500/10 text-red-600 border-red-200" :
                                  "bg-gray-500/10 text-gray-600 border-gray-200"
                                }`}
                              >
                                {endpoint.method}
                              </div>
                            </TableCell>
                            <TableCell className="font-mono text-xs">
// ...
                            </TableCell>
                            <TableCell className="max-w-[200px] truncate">
                              {endpoint.description || "-"}
                            </TableCell>
                            <TableCell>
                              {endpoint.valid ? (
                                <div className="inline-flex items-center rounded-md border border-green-200 bg-green-500/10 px-2.5 py-0.5 text-xs font-semibold text-green-600">
                                  Valid
                                </div>
                              ) : (
                                <div className="inline-flex items-center rounded-md border border-red-200 bg-red-500/10 px-2.5 py-0.5 text-xs font-semibold text-red-600">
                                  Invalid
                                </div>
                              )}
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </div>
                </div>
              </div>
            </>
          )}
        </CardContent>
        <CardFooter className="flex justify-between">
          <Button
            className="border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground"
            onClick={goBack}
          >
            Cancel
          </Button>
          
          {!importComplete ? (
            <Button 
              onClick={handleParseCollection} 
              disabled={isImporting || (importMethod === "file" && !file) || (importMethod === "json" && !jsonInput.trim())}
            >
              {isImporting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Parse Collection
            </Button>
          ) : (
            <Button onClick={handleImport}>
              Import API
            </Button>
          )}
        </CardFooter>
      </Card>
    </div>
  );
}
```


### `frontend\src\pages\orchestrator\ApiListPage.tsx`

```tsx
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import {
  Plus,
  Search,
  Filter,
  ArrowUpDown,
  MoreHorizontal,
  FileEdit,
  Copy,
  Trash2,
  CheckCircle,
  AlertCircle,
  Download,
} from "lucide-react";

import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

// Sample API data (in a real app, this would come from an API)
const sampleApis = [
  {
    id: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    name: "Weather API",
    description: "External weather data API",
    version: "1.0.0",
    endpoints: 3,
    status: "active",
    lastUpdated: "2023-02-15T14:23:10Z",
    updatedBy: "jane.doe@example.com",
  },
  {
    id: "7d793789-f369-45c1-a7d5-8c4bb4b3a7f9",
    name: "User Service",
    description: "Internal user management service",
    version: "2.1.0",
    endpoints: 12,
    status: "active",
    lastUpdated: "2023-02-10T09:45:22Z",
    updatedBy: "john.smith@example.com",
  },
  {
    id: "e57ac3f5-0591-4d2c-98a0-c54d12c0623e",
    name: "Payment Gateway",
    description: "Integration with payment providers",
    version: "1.2.0",
    endpoints: 5,
    status: "inactive",
    lastUpdated: "2023-01-25T11:32:45Z",
    updatedBy: "john.smith@example.com",
  },
  {
    id: "a23b7c1d-e8f9-4g0h-1i2j-3k4l5m6n7o8p",
    name: "Product Catalog",
    description: "Product information and management",
    version: "3.0.1",
    endpoints: 8,
    status: "active",
    lastUpdated: "2023-02-12T16:40:18Z",
    updatedBy: "jane.doe@example.com",
  },
  {
    id: "9q8r7s6t-5u4v-3w2x-1y0z-abcdefghijkl",
    name: "Analytics Service",
    description: "Data analytics and reporting",
    version: "1.0.0",
    endpoints: 4,
    status: "draft",
    lastUpdated: "2023-02-14T08:15:30Z",
    updatedBy: "jane.doe@example.com",
  }
];

export default function ApiListPage() {
  const navigate = useNavigate();
  const [apis, setApis] = useState(sampleApis);
  const [searchQuery, setSearchQuery] = useState("");
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [apiToDelete, setApiToDelete] = useState<string | null>(null);
  
  const filteredApis = apis.filter(api => 
    api.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    api.description.toLowerCase().includes(searchQuery.toLowerCase())
  );
  
  const handleCreateApi = () => {
    navigate("/orchestrator/apis/new");
  };
  
  const handleImportApi = () => {
    navigate("/orchestrator/apis/import");
  };
  
  const handleEditApi = (apiId: string) => {
    navigate(`/orchestrator/apis/${apiId}`);
  };
  
  const handleDuplicateApi = (apiId: string) => {
    // In a real app, this would duplicate the API configuration
    console.log(`Duplicating API ${apiId}`);
  };
  
  const handleDeleteClick = (apiId: string) => {
    setApiToDelete(apiId);
    setShowDeleteDialog(true);
  };
  
  const confirmDelete = () => {
    if (apiToDelete) {
      // In a real app, this would delete the API configuration
      setApis(apis.filter(api => api.id !== apiToDelete));
      setShowDeleteDialog(false);
      setApiToDelete(null);
    }
  };
  
  const getStatusColor = (status: string) => {
    switch (status) {
      case "active":
        return "text-green-500 bg-green-500/10 border-green-500/20";
      case "inactive":
        return "text-amber-500 bg-amber-500/10 border-amber-500/20";
      case "draft":
        return "text-blue-500 bg-blue-500/10 border-blue-500/20";
      default:
        return "text-gray-500 bg-gray-500/10 border-gray-500/20";
    }
  };
  
  const getStatusIcon = (status: string) => {
    switch (status) {
      case "active":
        return <CheckCircle className="h-4 w-4 text-green-500" />;
      case "inactive":
        return <AlertCircle className="h-4 w-4 text-amber-500" />;
      default:
        return null;
    }
  };
  
  return (
    <div className="container mx-auto py-6 space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold">API Orchestrator</h1>
          <p className="text-muted-foreground">
            Manage and configure your API definitions
          </p>
          <div className="flex items-center space-x-2">
            <Button onClick={handleCreateApi} className="gap-1">
              <Plus className="h-4 w-4" />
              Create API
            </Button>
            <Button 
              className="border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground gap-1"
              onClick={handleImportApi}
            >
              <Download className="h-4 w-4" />
              Import API
            </Button>
          </div>
        </div>
        
      </div>
      
      <Card>
        <CardHeader className="pb-3">
          <CardTitle>API Configurations</CardTitle>
          <CardDescription>
            List of all API configurations in the system
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex items-center mb-4">
            <div className="relative flex-1">
              <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Search APIs..."
                className="pl-8"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>
            <Button className="h-9 w-9 p-0 ml-2 border border-input rounded-md">
              <Filter className="h-4 w-4" />
            </Button>
          </div>
          
          <div className="rounded-md border">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-[250px]">
                    <div className="flex items-center gap-1 cursor-pointer hover:text-primary">
                      Name
                      <ArrowUpDown className="h-3 w-3" />
                    </div>
                  </TableHead>
                  <TableHead>Version</TableHead>
                  <TableHead>Endpoints</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead>Last Updated</TableHead>
                  <TableHead className="text-right">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredApis.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={6} className="text-center py-6 text-muted-foreground">
                      No APIs found. Create a new API to get started.
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredApis.map((api) => (
                    <TableRow key={api.id}>
                      <TableCell>
                        <div className="font-medium">{api.name}</div>
                        <div className="text-sm text-muted-foreground truncate max-w-[230px]">
                          {api.description}
                        </div>
                      </TableCell>
                      <TableCell>{api.version}</TableCell>
                      <TableCell>{api.endpoints}</TableCell>
                      <TableCell>
                        <div className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium border ${getStatusColor(api.status)}`}>
                          {getStatusIcon(api.status)}
                          <span className="capitalize">{api.status}</span>
                        </div>
                      </TableCell>
                      <TableCell>
                        <div>
                          {new Date(api.lastUpdated).toLocaleDateString()}
                        </div>
                        <div className="text-xs text-muted-foreground">
                          by {api.updatedBy.split('@')[0]}
                        </div>
                      </TableCell>
                      <TableCell className="text-right">
                        <DropdownMenu>
                          <DropdownMenuTrigger asChild>
                            <Button className="h-8 w-8 p-0 hover:bg-accent hover:text-accent-foreground rounded-md">
                              <MoreHorizontal className="h-4 w-4" />
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent align="end">
                            <DropdownMenuItem 
                              onClick={() => handleEditApi(api.id)}
                              className="flex items-center gap-2"
                            >
                              <FileEdit className="h-4 w-4" />
                              <span>Edit</span>
                            </DropdownMenuItem>
                            <DropdownMenuItem 
                              onClick={() => handleDuplicateApi(api.id)}
                              className="flex items-center gap-2"
                            >
                              <Copy className="h-4 w-4" />
                              <span>Duplicate</span>
                            </DropdownMenuItem>
                            <DropdownMenuSeparator />
                            <DropdownMenuItem
                              className="flex items-center gap-2 text-destructive focus:text-destructive"
                              onClick={() => handleDeleteClick(api.id)}
                            >
                              <Trash2 className="h-4 w-4" />
                              <span>Delete</span>
                            </DropdownMenuItem>
                          </DropdownMenuContent>
                        </DropdownMenu>
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
        <CardFooter className="flex justify-between">
          <div className="text-sm text-muted-foreground">
            Showing {filteredApis.length} of {apis.length} APIs
          </div>
        </CardFooter>
      </Card>
      
      {/* Delete Confirmation Dialog */}
      <Dialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Delete API Configuration</DialogTitle>
            <DialogDescription>
              Are you sure you want to delete this API configuration? This action cannot be undone.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button 
              className="bg-background border border-input hover:bg-accent hover:text-accent-foreground" 
              onClick={() => setShowDeleteDialog(false)}
            >
              Cancel
            </Button>
            <Button 
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90" 
              onClick={confirmDelete}
            >
              Delete
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
```


### `shared\schemas\index.ts`

```ts
import { z } from 'zod';

// Base user schema
export const userSchema = z.object({
  id: z.number().optional(),
  email: z.string().email(),
  passwordHash: z.string().optional(), // Only used backend-side
  role: z.enum(['admin', 'user']).default('user'),
  createdAt: z.string().optional(),
  updatedAt: z.string().optional()
});

// Permission schema
export const permissionSchema = z.object({
  id: z.number().optional(),
  userId: z.number(),
  apiName: z.string(),
  endpointPath: z.string(),
  verb: z.string(),
  allowed: z.boolean().default(true)
});

// API schema
export const apiSchema = z.object({
  id: z.number().optional(),
  name: z.string(),
  baseUrl: z.string().optional(),
  type: z.enum(['http', 'websocket', 'rpc']).default('http'),
  configJson: z.string(),
  createdAt: z.string().optional(),
  updatedAt: z.string().optional()
});

// Endpoint schema
export const endpointSchema = z.object({
  id: z.number().optional(),
  apiId: z.number(),
  path: z.string(),
  method: z.string(),
  configJson: z.string(),
  createdAt: z.string().optional(),
  updatedAt: z.string().optional()
});

// Log schema
export const logSchema = z.object({
  id: z.number().optional(),
  timestamp: z.string().optional(),
  endpointId: z.number().optional(),
  phase: z.enum([
    'beforeRequest', 
    'request', 
    'afterRequest',
    'beforeExecute',
    'execute',
    'afterExecute'
  ]),
  success: z.boolean(),
  message: z.string(),
  metadataJson: z.string().optional()
});

// Webhook schema
export const webhookSchema = z.object({
  id: z.number().optional(),
  endpointId: z.number(),
  phase: z.enum([
    'beforeRequest', 
    'request', 
    'afterRequest',
    'beforeExecute',
    'execute',
    'afterExecute'
  ]),
  statusCode: z.number().optional(),
  url: z.string()
});

// Cache schema
export const cacheSchema = z.object({
  key: z.string(),
  valueJson: z.string(),
  expiresAt: z.number()
});

// Retry schedule schema
export const retryScheduleSchema = z.object({
  id: z.number().optional(),
  requestId: z.string(),
  endpointId: z.number().optional(),
  nextTry: z.number(),
  attempts: z.number().default(0),
  status: z.enum(['pending', 'processing', 'completed', 'failed']).default('pending')
});

// Export all types
export type User = z.infer<typeof userSchema>;
export type Permission = z.infer<typeof permissionSchema>;
export type Api = z.infer<typeof apiSchema>;
export type Endpoint = z.infer<typeof endpointSchema>;
export type Log = z.infer<typeof logSchema>;
export type Webhook = z.infer<typeof webhookSchema>;
export type Cache = z.infer<typeof cacheSchema>;
export type RetrySchedule = z.infer<typeof retryScheduleSchema>;
```
